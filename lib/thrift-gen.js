/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/*jshint evil:true*/

/**
 * The Thrift namespace houses the Apache Thrift JavaScript library
 * elements providing JavaScript bindings for the Apache Thrift RPC
 * system. End users will typically only directly make use of the
 * Transport (TXHRTransport/TWebSocketTransport) and Protocol
 * (TJSONPRotocol/TBinaryProtocol) constructors.
 *
 * Object methods beginning with a __ (e.g. __onOpen()) are internal
 * and should not be called outside of the object's own methods.
 *
 * This library creates one global object: Thrift
 * Code in this library must never create additional global identifiers,
 * all features must be scoped within the Thrift namespace.
 * @namespace
 * @example
 *     var transport = new Thrift.Transport('http://localhost:8585');
 *     var protocol  = new Thrift.Protocol(transport);
 *     var client = new MyThriftSvcClient(protocol);
 *     var result = client.MyMethod();
 */
var Thrift = {
    /**
     * Thrift JavaScript library version.
     * @readonly
     * @const {string} Version
     * @memberof Thrift
     */
    Version: '0.14.0',

    /**
     * Thrift IDL type string to Id mapping.
     * @readonly
     * @property {number}  STOP   - End of a set of fields.
     * @property {number}  VOID   - No value (only legal for return types).
     * @property {number}  BOOL   - True/False integer.
     * @property {number}  BYTE   - Signed 8 bit integer.
     * @property {number}  I08    - Signed 8 bit integer.
     * @property {number}  DOUBLE - 64 bit IEEE 854 floating point.
     * @property {number}  I16    - Signed 16 bit integer.
     * @property {number}  I32    - Signed 32 bit integer.
     * @property {number}  I64    - Signed 64 bit integer.
     * @property {number}  STRING - Array of bytes representing a string of characters.
     * @property {number}  UTF7   - Array of bytes representing a string of UTF7 encoded characters.
     * @property {number}  STRUCT - A multifield type.
     * @property {number}  MAP    - A collection type (map/associative-array/dictionary).
     * @property {number}  SET    - A collection type (unordered and without repeated values).
     * @property {number}  LIST   - A collection type (unordered).
     * @property {number}  UTF8   - Array of bytes representing a string of UTF8 encoded characters.
     * @property {number}  UTF16  - Array of bytes representing a string of UTF16 encoded characters.
     */
    Type: {
        STOP: 0,
        VOID: 1,
        BOOL: 2,
        BYTE: 3,
        I08: 3,
        DOUBLE: 4,
        I16: 6,
        I32: 8,
        I64: 10,
        STRING: 11,
        UTF7: 11,
        STRUCT: 12,
        MAP: 13,
        SET: 14,
        LIST: 15,
        UTF8: 16,
        UTF16: 17
    },

    /**
     * Thrift RPC message type string to Id mapping.
     * @readonly
     * @property {number}  CALL      - RPC call sent from client to server.
     * @property {number}  REPLY     - RPC call normal response from server to client.
     * @property {number}  EXCEPTION - RPC call exception response from server to client.
     * @property {number}  ONEWAY    - Oneway RPC call from client to server with no response.
     */
    MessageType: {
        CALL: 1,
        REPLY: 2,
        EXCEPTION: 3,
        ONEWAY: 4
    },

    /**
     * Utility function returning the count of an object's own properties.
     * @param {object} obj - Object to test.
     * @returns {number} number of object's own properties
     */
    objectLength: function(obj) {
        var length = 0;
        for (var k in obj) {
            if (obj.hasOwnProperty(k)) {
                length++;
            }
        }
        return length;
    },

    /**
     * Utility function to establish prototype inheritance.
     * @see {@link http://javascript.crockford.com/prototypal.html|Prototypal Inheritance}
     * @param {function} constructor - Contstructor function to set as derived.
     * @param {function} superConstructor - Contstructor function to set as base.
     * @param {string} [name] - Type name to set as name property in derived prototype.
     */
    inherits: function(constructor, superConstructor, name) {
      function F() {}
      F.prototype = superConstructor.prototype;
      constructor.prototype = new F();
      constructor.prototype.name = name || '';
    }
};

/**
 * Initializes a Thrift TException instance.
 * @constructor
 * @augments Error
 * @param {string} message - The TException message (distinct from the Error message).
 * @classdesc TException is the base class for all Thrift exceptions types.
 */
Thrift.TException = function(message) {
    this.message = message;
};
Thrift.inherits(Thrift.TException, Error, 'TException');

/**
 * Returns the message set on the exception.
 * @readonly
 * @returns {string} exception message
 */
Thrift.TException.prototype.getMessage = function() {
    return this.message;
};

/**
 * Thrift Application Exception type string to Id mapping.
 * @readonly
 * @property {number}  UNKNOWN                 - Unknown/undefined.
 * @property {number}  UNKNOWN_METHOD          - Client attempted to call a method unknown to the server.
 * @property {number}  INVALID_MESSAGE_TYPE    - Client passed an unknown/unsupported MessageType.
 * @property {number}  WRONG_METHOD_NAME       - Unused.
 * @property {number}  BAD_SEQUENCE_ID         - Unused in Thrift RPC, used to flag proprietary sequence number errors.
 * @property {number}  MISSING_RESULT          - Raised by a server processor if a handler fails to supply the required return result.
 * @property {number}  INTERNAL_ERROR          - Something bad happened.
 * @property {number}  PROTOCOL_ERROR          - The protocol layer failed to serialize or deserialize data.
 * @property {number}  INVALID_TRANSFORM       - Unused.
 * @property {number}  INVALID_PROTOCOL        - The protocol (or version) is not supported.
 * @property {number}  UNSUPPORTED_CLIENT_TYPE - Unused.
 */
Thrift.TApplicationExceptionType = {
    UNKNOWN: 0,
    UNKNOWN_METHOD: 1,
    INVALID_MESSAGE_TYPE: 2,
    WRONG_METHOD_NAME: 3,
    BAD_SEQUENCE_ID: 4,
    MISSING_RESULT: 5,
    INTERNAL_ERROR: 6,
    PROTOCOL_ERROR: 7,
    INVALID_TRANSFORM: 8,
    INVALID_PROTOCOL: 9,
    UNSUPPORTED_CLIENT_TYPE: 10
};

/**
 * Initializes a Thrift TApplicationException instance.
 * @constructor
 * @augments Thrift.TException
 * @param {string} message - The TApplicationException message (distinct from the Error message).
 * @param {Thrift.TApplicationExceptionType} [code] - The TApplicationExceptionType code.
 * @classdesc TApplicationException is the exception class used to propagate exceptions from an RPC server back to a calling client.
*/
Thrift.TApplicationException = function(message, code) {
    this.message = message;
    this.code = typeof code === 'number' ? code : 0;
};
Thrift.inherits(Thrift.TApplicationException, Thrift.TException, 'TApplicationException');

/**
 * Read a TApplicationException from the supplied protocol.
 * @param {object} input - The input protocol to read from.
 */
Thrift.TApplicationException.prototype.read = function(input) {
    while (1) {
        var ret = input.readFieldBegin();

        if (ret.ftype == Thrift.Type.STOP) {
            break;
        }

        var fid = ret.fid;

        switch (fid) {
            case 1:
                if (ret.ftype == Thrift.Type.STRING) {
                    ret = input.readString();
                    this.message = ret.value;
                } else {
                    ret = input.skip(ret.ftype);
                }
                break;
            case 2:
                if (ret.ftype == Thrift.Type.I32) {
                    ret = input.readI32();
                    this.code = ret.value;
                } else {
                    ret = input.skip(ret.ftype);
                }
                break;
           default:
                ret = input.skip(ret.ftype);
                break;
        }

        input.readFieldEnd();
    }

    input.readStructEnd();
};

/**
 * Wite a TApplicationException to the supplied protocol.
 * @param {object} output - The output protocol to write to.
 */
Thrift.TApplicationException.prototype.write = function(output) {
    output.writeStructBegin('TApplicationException');

    if (this.message) {
        output.writeFieldBegin('message', Thrift.Type.STRING, 1);
        output.writeString(this.getMessage());
        output.writeFieldEnd();
    }

    if (this.code) {
        output.writeFieldBegin('type', Thrift.Type.I32, 2);
        output.writeI32(this.code);
        output.writeFieldEnd();
    }

    output.writeFieldStop();
    output.writeStructEnd();
};

/**
 * Returns the application exception code set on the exception.
 * @readonly
 * @returns {Thrift.TApplicationExceptionType} exception code
 */
Thrift.TApplicationException.prototype.getCode = function() {
    return this.code;
};

Thrift.TProtocolExceptionType = {
    UNKNOWN: 0,
    INVALID_DATA: 1,
    NEGATIVE_SIZE: 2,
    SIZE_LIMIT: 3,
    BAD_VERSION: 4,
    NOT_IMPLEMENTED: 5,
    DEPTH_LIMIT: 6
};

Thrift.TProtocolException = function TProtocolException(type, message) {
    Error.call(this);
    Error.captureStackTrace(this, this.constructor);
    this.name = this.constructor.name;
    this.type = type;
    this.message = message;
};
Thrift.inherits(Thrift.TProtocolException, Thrift.TException, 'TProtocolException');

/**
 * Constructor Function for the XHR transport.
 * If you do not specify a url then you must handle XHR operations on
 * your own. This type can also be constructed using the Transport alias
 * for backward compatibility.
 * @constructor
 * @param {string} [url] - The URL to connect to.
 * @classdesc The Apache Thrift Transport layer performs byte level I/O
 * between RPC clients and servers. The JavaScript TXHRTransport object
 * uses Http[s]/XHR. Target servers must implement the http[s] transport
 * (see: node.js example server_http.js).
 * @example
 *     var transport = new Thrift.TXHRTransport("http://localhost:8585");
 */
Thrift.Transport = Thrift.TXHRTransport = function(url, options) {
    this.url = url;
    this.wpos = 0;
    this.rpos = 0;
    this.useCORS = (options && options.useCORS);
    this.customHeaders = options ? (options.customHeaders ? options.customHeaders : {}): {};
    this.send_buf = '';
    this.recv_buf = '';
};

Thrift.TXHRTransport.prototype = {
    /**
     * Gets the browser specific XmlHttpRequest Object.
     * @returns {object} the browser XHR interface object
     */
    getXmlHttpRequestObject: function() {
        try { return new XMLHttpRequest(); } catch (e1) { }
        try { return new ActiveXObject('Msxml2.XMLHTTP'); } catch (e2) { }
        try { return new ActiveXObject('Microsoft.XMLHTTP'); } catch (e3) { }

        throw "Your browser doesn't support XHR.";
    },

    /**
     * Sends the current XRH request if the transport was created with a URL
     * and the async parameter is false. If the transport was not created with
     * a URL, or the async parameter is True and no callback is provided, or
     * the URL is an empty string, the current send buffer is returned.
     * @param {object} async - If true the current send buffer is returned.
     * @param {object} callback - Optional async completion callback
     * @returns {undefined|string} Nothing or the current send buffer.
     * @throws {string} If XHR fails.
     */
    flush: function(async, callback) {
        var self = this;
        if ((async && !callback) || this.url === undefined || this.url === '') {
            return this.send_buf;
        }

        var xreq = this.getXmlHttpRequestObject();

        if (xreq.overrideMimeType) {
            xreq.overrideMimeType('application/vnd.apache.thrift.json; charset=utf-8');
        }

        if (callback) {
            //Ignore XHR callbacks until the data arrives, then call the
            //  client's callback
            xreq.onreadystatechange =
              (function() {
                var clientCallback = callback;
                return function() {
                  if (this.readyState == 4 && this.status == 200) {
                    self.setRecvBuffer(this.responseText);
                    clientCallback();
                  }
                };
              }());

            // detect net::ERR_CONNECTION_REFUSED and call the callback.
            xreq.onerror =
                (function() {
                  var clientCallback = callback;
                  return function() {
                      clientCallback();
                  };
                }());

        }

        xreq.open('POST', this.url, !!async);

        // add custom headers
        Object.keys(self.customHeaders).forEach(function(prop) {
            xreq.setRequestHeader(prop, self.customHeaders[prop]);
        });

        if (xreq.setRequestHeader) {
            xreq.setRequestHeader('Accept', 'application/vnd.apache.thrift.json; charset=utf-8');
            xreq.setRequestHeader('Content-Type', 'application/vnd.apache.thrift.json; charset=utf-8');
        }

        xreq.send(this.send_buf);
        if (async && callback) {
            return;
        }

        if (xreq.readyState != 4) {
            throw 'encountered an unknown ajax ready state: ' + xreq.readyState;
        }

        if (xreq.status != 200) {
            throw 'encountered a unknown request status: ' + xreq.status;
        }

        this.recv_buf = xreq.responseText;
        this.recv_buf_sz = this.recv_buf.length;
        this.wpos = this.recv_buf.length;
        this.rpos = 0;
    },

    /**
     * Creates a jQuery XHR object to be used for a Thrift server call.
     * @param {object} client - The Thrift Service client object generated by the IDL compiler.
     * @param {object} postData - The message to send to the server.
     * @param {function} args - The original call arguments with the success call back at the end.
     * @param {function} recv_method - The Thrift Service Client receive method for the call.
     * @returns {object} A new jQuery XHR object.
     * @throws {string} If the jQuery version is prior to 1.5 or if jQuery is not found.
     */
    jqRequest: function(client, postData, args, recv_method) {
        if (typeof jQuery === 'undefined' ||
            typeof jQuery.Deferred === 'undefined') {
            throw 'Thrift.js requires jQuery 1.5+ to use asynchronous requests';
        }

        var thriftTransport = this;

        var jqXHR = jQuery.ajax({
            url: this.url,
            data: postData,
            type: 'POST',
            cache: false,
            contentType: 'application/vnd.apache.thrift.json; charset=utf-8',
            dataType: 'text thrift',
            converters: {
                'text thrift' : function(responseData) {
                    thriftTransport.setRecvBuffer(responseData);
                    var value = recv_method.call(client);
                    return value;
                }
            },
            context: client,
            success: jQuery.makeArray(args).pop(),
            beforeSend: function (xreq) {
                Object.keys(thriftTransport.customHeaders).forEach(function (prop) {
                    xreq.setRequestHeader(prop, thriftTransport.customHeaders[prop]);
                });
            }
        });

        return jqXHR;
    },

    /**
     * Sets the buffer to provide the protocol when deserializing.
     * @param {string} buf - The buffer to supply the protocol.
     */
    setRecvBuffer: function(buf) {
        this.recv_buf = buf;
        this.recv_buf_sz = this.recv_buf.length;
        this.wpos = this.recv_buf.length;
        this.rpos = 0;
    },

    /**
     * Returns true if the transport is open, XHR always returns true.
     * @readonly
     * @returns {boolean} Always True.
     */
    isOpen: function() {
        return true;
    },

    /**
     * Opens the transport connection, with XHR this is a nop.
     */
    open: function() {},

    /**
     * Closes the transport connection, with XHR this is a nop.
     */
    close: function() {},

    /**
     * Returns the specified number of characters from the response
     * buffer.
     * @param {number} len - The number of characters to return.
     * @returns {string} Characters sent by the server.
     */
    read: function(len) {
        var avail = this.wpos - this.rpos;

        if (avail === 0) {
            return '';
        }

        var give = len;

        if (avail < len) {
            give = avail;
        }

        var ret = this.read_buf.substr(this.rpos, give);
        this.rpos += give;

        //clear buf when complete?
        return ret;
    },

    /**
     * Returns the entire response buffer.
     * @returns {string} Characters sent by the server.
     */
    readAll: function() {
        return this.recv_buf;
    },

    /**
     * Sets the send buffer to buf.
     * @param {string} buf - The buffer to send.
     */
    write: function(buf) {
        this.send_buf = buf;
    },

    /**
     * Returns the send buffer.
     * @readonly
     * @returns {string} The send buffer.
     */
    getSendBuffer: function() {
        return this.send_buf;
    }

};


/**
 * Constructor Function for the WebSocket transport.
 * @constructor
 * @param {string} [url] - The URL to connect to.
 * @classdesc The Apache Thrift Transport layer performs byte level I/O
 * between RPC clients and servers. The JavaScript TWebSocketTransport object
 * uses the WebSocket protocol. Target servers must implement WebSocket.
 * (see: node.js example server_http.js).
 * @example
 *   var transport = new Thrift.TWebSocketTransport("http://localhost:8585");
 */
Thrift.TWebSocketTransport = function(url) {
    this.__reset(url);
};

Thrift.TWebSocketTransport.prototype = {
    __reset: function(url) {
      this.url = url;             //Where to connect
      this.socket = null;         //The web socket
      this.callbacks = [];        //Pending callbacks
      this.send_pending = [];     //Buffers/Callback pairs waiting to be sent
      this.send_buf = '';         //Outbound data, immutable until sent
      this.recv_buf = '';         //Inbound data
      this.rb_wpos = 0;           //Network write position in receive buffer
      this.rb_rpos = 0;           //Client read position in receive buffer
    },

    /**
     * Sends the current WS request and registers callback. The async
     * parameter is ignored (WS flush is always async) and the callback
     * function parameter is required.
     * @param {object} async - Ignored.
     * @param {object} callback - The client completion callback.
     * @returns {undefined|string} Nothing (undefined)
     */
    flush: function(async, callback) {
      var self = this;
      if (this.isOpen()) {
        //Send data and register a callback to invoke the client callback
        this.socket.send(this.send_buf);
        this.callbacks.push((function() {
          var clientCallback = callback;
          return function(msg) {
            self.setRecvBuffer(msg);
            if (clientCallback) {
                clientCallback();
            }
          };
        }()));
      } else {
        //Queue the send to go out __onOpen
        this.send_pending.push({
          buf: this.send_buf,
          cb: callback
        });
      }
    },

    __onOpen: function() {
       var self = this;
       if (this.send_pending.length > 0) {
          //If the user made calls before the connection was fully
          //open, send them now
          this.send_pending.forEach(function(elem) {
             self.socket.send(elem.buf);
             self.callbacks.push((function() {
               var clientCallback = elem.cb;
               return function(msg) {
                  self.setRecvBuffer(msg);
                  clientCallback();
               };
             }()));
          });
          this.send_pending = [];
       }
    },

    __onClose: function(evt) {
      this.__reset(this.url);
    },

    __onMessage: function(evt) {
      if (this.callbacks.length) {
        this.callbacks.shift()(evt.data);
      }
    },

    __onError: function(evt) {
      console.log('Thrift WebSocket Error: ' + evt.toString());
      this.socket.close();
    },

    /**
     * Sets the buffer to use when receiving server responses.
     * @param {string} buf - The buffer to receive server responses.
     */
    setRecvBuffer: function(buf) {
        this.recv_buf = buf;
        this.recv_buf_sz = this.recv_buf.length;
        this.wpos = this.recv_buf.length;
        this.rpos = 0;
    },

    /**
     * Returns true if the transport is open
     * @readonly
     * @returns {boolean}
     */
    isOpen: function() {
        return this.socket && this.socket.readyState == this.socket.OPEN;
    },

    /**
     * Opens the transport connection
     */
    open: function() {
      //If OPEN/CONNECTING/CLOSING ignore additional opens
      if (this.socket && this.socket.readyState != this.socket.CLOSED) {
        return;
      }
      //If there is no socket or the socket is closed:
      this.socket = new WebSocket(this.url);
      this.socket.onopen = this.__onOpen.bind(this);
      this.socket.onmessage = this.__onMessage.bind(this);
      this.socket.onerror = this.__onError.bind(this);
      this.socket.onclose = this.__onClose.bind(this);
    },

    /**
     * Closes the transport connection
     */
    close: function() {
      this.socket.close();
    },

    /**
     * Returns the specified number of characters from the response
     * buffer.
     * @param {number} len - The number of characters to return.
     * @returns {string} Characters sent by the server.
     */
    read: function(len) {
        var avail = this.wpos - this.rpos;

        if (avail === 0) {
            return '';
        }

        var give = len;

        if (avail < len) {
            give = avail;
        }

        var ret = this.read_buf.substr(this.rpos, give);
        this.rpos += give;

        //clear buf when complete?
        return ret;
    },

    /**
     * Returns the entire response buffer.
     * @returns {string} Characters sent by the server.
     */
    readAll: function() {
        return this.recv_buf;
    },

    /**
     * Sets the send buffer to buf.
     * @param {string} buf - The buffer to send.
     */
    write: function(buf) {
        this.send_buf = buf;
    },

    /**
     * Returns the send buffer.
     * @readonly
     * @returns {string} The send buffer.
     */
    getSendBuffer: function() {
        return this.send_buf;
    }

};

/**
 * Initializes a Thrift JSON protocol instance.
 * @constructor
 * @param {Thrift.Transport} transport - The transport to serialize to/from.
 * @classdesc Apache Thrift Protocols perform serialization which enables cross
 * language RPC. The Protocol type is the JavaScript browser implementation
 * of the Apache Thrift TJSONProtocol.
 * @example
 *     var protocol  = new Thrift.Protocol(transport);
 */
Thrift.TJSONProtocol = Thrift.Protocol = function(transport) {
    this.tstack = [];
    this.tpos = [];
    this.transport = transport;
};

/**
 * Thrift IDL type Id to string mapping.
 * @readonly
 * @see {@link Thrift.Type}
 */
Thrift.Protocol.Type = {};
Thrift.Protocol.Type[Thrift.Type.BOOL] = '"tf"';
Thrift.Protocol.Type[Thrift.Type.BYTE] = '"i8"';
Thrift.Protocol.Type[Thrift.Type.I16] = '"i16"';
Thrift.Protocol.Type[Thrift.Type.I32] = '"i32"';
Thrift.Protocol.Type[Thrift.Type.I64] = '"i64"';
Thrift.Protocol.Type[Thrift.Type.DOUBLE] = '"dbl"';
Thrift.Protocol.Type[Thrift.Type.STRUCT] = '"rec"';
Thrift.Protocol.Type[Thrift.Type.STRING] = '"str"';
Thrift.Protocol.Type[Thrift.Type.MAP] = '"map"';
Thrift.Protocol.Type[Thrift.Type.LIST] = '"lst"';
Thrift.Protocol.Type[Thrift.Type.SET] = '"set"';

/**
 * Thrift IDL type string to Id mapping.
 * @readonly
 * @see {@link Thrift.Type}
 */
Thrift.Protocol.RType = {};
Thrift.Protocol.RType.tf = Thrift.Type.BOOL;
Thrift.Protocol.RType.i8 = Thrift.Type.BYTE;
Thrift.Protocol.RType.i16 = Thrift.Type.I16;
Thrift.Protocol.RType.i32 = Thrift.Type.I32;
Thrift.Protocol.RType.i64 = Thrift.Type.I64;
Thrift.Protocol.RType.dbl = Thrift.Type.DOUBLE;
Thrift.Protocol.RType.rec = Thrift.Type.STRUCT;
Thrift.Protocol.RType.str = Thrift.Type.STRING;
Thrift.Protocol.RType.map = Thrift.Type.MAP;
Thrift.Protocol.RType.lst = Thrift.Type.LIST;
Thrift.Protocol.RType.set = Thrift.Type.SET;

/**
 * The TJSONProtocol version number.
 * @readonly
 * @const {number} Version
 * @memberof Thrift.Protocol
 */
 Thrift.Protocol.Version = 1;

Thrift.Protocol.prototype = {
    /**
     * Returns the underlying transport.
     * @readonly
     * @returns {Thrift.Transport} The underlying transport.
     */
    getTransport: function() {
        return this.transport;
    },

    /**
     * Serializes the beginning of a Thrift RPC message.
     * @param {string} name - The service method to call.
     * @param {Thrift.MessageType} messageType - The type of method call.
     * @param {number} seqid - The sequence number of this call (always 0 in Apache Thrift).
     */
    writeMessageBegin: function(name, messageType, seqid) {
        this.tstack = [];
        this.tpos = [];

        this.tstack.push([Thrift.Protocol.Version, '"' +
            name + '"', messageType, seqid]);
    },

    /**
     * Serializes the end of a Thrift RPC message.
     */
    writeMessageEnd: function() {
        var obj = this.tstack.pop();

        this.wobj = this.tstack.pop();
        this.wobj.push(obj);

        this.wbuf = '[' + this.wobj.join(',') + ']';

        this.transport.write(this.wbuf);
     },


    /**
     * Serializes the beginning of a struct.
     * @param {string} name - The name of the struct.
     */
    writeStructBegin: function(name) {
        this.tpos.push(this.tstack.length);
        this.tstack.push({});
    },

    /**
     * Serializes the end of a struct.
     */
    writeStructEnd: function() {

        var p = this.tpos.pop();
        var struct = this.tstack[p];
        var str = '{';
        var first = true;
        for (var key in struct) {
            if (first) {
                first = false;
            } else {
                str += ',';
            }

            str += key + ':' + struct[key];
        }

        str += '}';
        this.tstack[p] = str;
    },

    /**
     * Serializes the beginning of a struct field.
     * @param {string} name - The name of the field.
     * @param {Thrift.Protocol.Type} fieldType - The data type of the field.
     * @param {number} fieldId - The field's unique identifier.
     */
    writeFieldBegin: function(name, fieldType, fieldId) {
        this.tpos.push(this.tstack.length);
        this.tstack.push({ 'fieldId': '"' +
            fieldId + '"', 'fieldType': Thrift.Protocol.Type[fieldType]
        });

    },

    /**
     * Serializes the end of a field.
     */
    writeFieldEnd: function() {
        var value = this.tstack.pop();
        var fieldInfo = this.tstack.pop();

        this.tstack[this.tstack.length - 1][fieldInfo.fieldId] = '{' +
            fieldInfo.fieldType + ':' + value + '}';
        this.tpos.pop();
    },

    /**
     * Serializes the end of the set of fields for a struct.
     */
    writeFieldStop: function() {
        //na
    },

    /**
     * Serializes the beginning of a map collection.
     * @param {Thrift.Type} keyType - The data type of the key.
     * @param {Thrift.Type} valType - The data type of the value.
     * @param {number} [size] - The number of elements in the map (ignored).
     */
    writeMapBegin: function(keyType, valType, size) {
        this.tpos.push(this.tstack.length);
        this.tstack.push([Thrift.Protocol.Type[keyType],
            Thrift.Protocol.Type[valType], 0]);
    },

    /**
     * Serializes the end of a map.
     */
    writeMapEnd: function() {
        var p = this.tpos.pop();

        if (p == this.tstack.length) {
            return;
        }

        if ((this.tstack.length - p - 1) % 2 !== 0) {
            this.tstack.push('');
        }

        var size = (this.tstack.length - p - 1) / 2;

        this.tstack[p][this.tstack[p].length - 1] = size;

        var map = '}';
        var first = true;
        while (this.tstack.length > p + 1) {
            var v = this.tstack.pop();
            var k = this.tstack.pop();
            if (first) {
                first = false;
            } else {
                map = ',' + map;
            }

            if (! isNaN(k)) { k = '"' + k + '"'; } //json "keys" need to be strings
            map = k + ':' + v + map;
        }
        map = '{' + map;

        this.tstack[p].push(map);
        this.tstack[p] = '[' + this.tstack[p].join(',') + ']';
    },

    /**
     * Serializes the beginning of a list collection.
     * @param {Thrift.Type} elemType - The data type of the elements.
     * @param {number} size - The number of elements in the list.
     */
    writeListBegin: function(elemType, size) {
        this.tpos.push(this.tstack.length);
        this.tstack.push([Thrift.Protocol.Type[elemType], size]);
    },

    /**
     * Serializes the end of a list.
     */
    writeListEnd: function() {
        var p = this.tpos.pop();

        while (this.tstack.length > p + 1) {
            var tmpVal = this.tstack[p + 1];
            this.tstack.splice(p + 1, 1);
            this.tstack[p].push(tmpVal);
        }

        this.tstack[p] = '[' + this.tstack[p].join(',') + ']';
    },

    /**
     * Serializes the beginning of a set collection.
     * @param {Thrift.Type} elemType - The data type of the elements.
     * @param {number} size - The number of elements in the list.
     */
    writeSetBegin: function(elemType, size) {
        this.tpos.push(this.tstack.length);
        this.tstack.push([Thrift.Protocol.Type[elemType], size]);
    },

    /**
     * Serializes the end of a set.
     */
    writeSetEnd: function() {
        var p = this.tpos.pop();

        while (this.tstack.length > p + 1) {
            var tmpVal = this.tstack[p + 1];
            this.tstack.splice(p + 1, 1);
            this.tstack[p].push(tmpVal);
        }

        this.tstack[p] = '[' + this.tstack[p].join(',') + ']';
    },

    /** Serializes a boolean */
    writeBool: function(value) {
        this.tstack.push(value ? 1 : 0);
    },

    /** Serializes a number */
    writeByte: function(i8) {
        this.tstack.push(i8);
    },

    /** Serializes a number */
    writeI16: function(i16) {
        this.tstack.push(i16);
    },

    /** Serializes a number */
    writeI32: function(i32) {
        this.tstack.push(i32);
    },

    /** Serializes a number */
    writeI64: function(i64) {
        if (typeof i64 === 'number') {
            this.tstack.push(i64);
        } else {
            this.tstack.push(Int64Util.toDecimalString(i64));
        }
    },

    /** Serializes a number */
    writeDouble: function(dbl) {
        this.tstack.push(dbl);
    },

    /** Serializes a string */
    writeString: function(str) {
        // We do not encode uri components for wire transfer:
        if (str === null) {
            this.tstack.push(null);
        } else {
            // concat may be slower than building a byte buffer
            var escapedString = '';
            for (var i = 0; i < str.length; i++) {
                var ch = str.charAt(i);      // a single double quote: "
                if (ch === '\"') {
                    escapedString += '\\\"'; // write out as: \"
                } else if (ch === '\\') {    // a single backslash
                    escapedString += '\\\\'; // write out as double backslash
                } else if (ch === '\b') {    // a single backspace: invisible
                    escapedString += '\\b';  // write out as: \b"
                } else if (ch === '\f') {    // a single formfeed: invisible
                    escapedString += '\\f';  // write out as: \f"
                } else if (ch === '\n') {    // a single newline: invisible
                    escapedString += '\\n';  // write out as: \n"
                } else if (ch === '\r') {    // a single return: invisible
                    escapedString += '\\r';  // write out as: \r"
                } else if (ch === '\t') {    // a single tab: invisible
                    escapedString += '\\t';  // write out as: \t"
                } else {
                    escapedString += ch;     // Else it need not be escaped
                }
            }
            this.tstack.push('"' + escapedString + '"');
        }
    },

    /** Serializes a string */
    writeBinary: function(binary) {
        var str = '';
        if (typeof binary == 'string') {
            str = binary;
        } else if (binary instanceof Uint8Array) {
            var arr = binary;
            for (var i = 0; i < arr.length; ++i) {
                str += String.fromCharCode(arr[i]);
            }
        } else {
            throw new TypeError('writeBinary only accepts String or Uint8Array.');
        }
        this.tstack.push('"' + btoa(str) + '"');
    },

    /**
       @class
       @name AnonReadMessageBeginReturn
       @property {string} fname - The name of the service method.
       @property {Thrift.MessageType} mtype - The type of message call.
       @property {number} rseqid - The sequence number of the message (0 in Thrift RPC).
     */
    /**
     * Deserializes the beginning of a message.
     * @returns {AnonReadMessageBeginReturn}
     */
    readMessageBegin: function() {
        this.rstack = [];
        this.rpos = [];

        received = this.transport.readAll();

        if (typeof JSONInt64 !== 'undefined' && typeof JSONInt64.parse === 'function') {
            this.robj = JSONInt64.parse(received);
        } else if (typeof JSON !== 'undefined' && typeof JSON.parse === 'function') {
            this.robj = JSON.parse(received);
        } else if (typeof jQuery !== 'undefined') {
            this.robj = jQuery.parseJSON(received);
        } else {
            this.robj = eval(received);
        }

        var r = {};
        var version = this.robj.shift();

        if (version != Thrift.Protocol.Version) {
            throw 'Wrong thrift protocol version: ' + version;
        }

        r.fname = this.robj.shift();
        r.mtype = this.robj.shift();
        r.rseqid = this.robj.shift();


        //get to the main obj
        this.rstack.push(this.robj.shift());

        return r;
    },

    /** Deserializes the end of a message. */
    readMessageEnd: function() {
    },

    /**
     * Deserializes the beginning of a struct.
     * @param {string} [name] - The name of the struct (ignored)
     * @returns {object} - An object with an empty string fname property
     */
    readStructBegin: function(name) {
        var r = {};
        r.fname = '';

        //incase this is an array of structs
        if (this.rstack[this.rstack.length - 1] instanceof Array) {
            this.rstack.push(this.rstack[this.rstack.length - 1].shift());
        }

        return r;
    },

    /** Deserializes the end of a struct. */
    readStructEnd: function() {
        if (this.rstack[this.rstack.length - 2] instanceof Array) {
            this.rstack.pop();
        }
    },

    /**
       @class
       @name AnonReadFieldBeginReturn
       @property {string} fname - The name of the field (always '').
       @property {Thrift.Type} ftype - The data type of the field.
       @property {number} fid - The unique identifier of the field.
     */
    /**
     * Deserializes the beginning of a field.
     * @returns {AnonReadFieldBeginReturn}
     */
    readFieldBegin: function() {
        var r = {};

        var fid = -1;
        var ftype = Thrift.Type.STOP;

        //get a fieldId
        for (var f in (this.rstack[this.rstack.length - 1])) {
            if (f === null) {
              continue;
            }

            fid = parseInt(f, 10);
            this.rpos.push(this.rstack.length);

            var field = this.rstack[this.rstack.length - 1][fid];

            //remove so we don't see it again
            delete this.rstack[this.rstack.length - 1][fid];

            this.rstack.push(field);

            break;
        }

        if (fid != -1) {

            //should only be 1 of these but this is the only
            //way to match a key
            for (var i in (this.rstack[this.rstack.length - 1])) {
                if (Thrift.Protocol.RType[i] === null) {
                    continue;
                }

                ftype = Thrift.Protocol.RType[i];
                this.rstack[this.rstack.length - 1] =
                    this.rstack[this.rstack.length - 1][i];
            }
        }

        r.fname = '';
        r.ftype = ftype;
        r.fid = fid;

        return r;
    },

    /** Deserializes the end of a field. */
    readFieldEnd: function() {
        var pos = this.rpos.pop();

        //get back to the right place in the stack
        while (this.rstack.length > pos) {
            this.rstack.pop();
        }

    },

    /**
       @class
       @name AnonReadMapBeginReturn
       @property {Thrift.Type} ktype - The data type of the key.
       @property {Thrift.Type} vtype - The data type of the value.
       @property {number} size - The number of elements in the map.
     */
    /**
     * Deserializes the beginning of a map.
     * @returns {AnonReadMapBeginReturn}
     */
    readMapBegin: function() {
        var map = this.rstack.pop();
        var first = map.shift();
        if (first instanceof Array) {
          this.rstack.push(map);
          map = first;
          first = map.shift();
        }

        var r = {};
        r.ktype = Thrift.Protocol.RType[first];
        r.vtype = Thrift.Protocol.RType[map.shift()];
        r.size = map.shift();

        this.rpos.push(this.rstack.length);
        this.rstack.push(map.shift());

        return r;
    },

    /** Deserializes the end of a map. */
    readMapEnd: function() {
        this.readFieldEnd();
    },

    /**
       @class
       @name AnonReadColBeginReturn
       @property {Thrift.Type} etype - The data type of the element.
       @property {number} size - The number of elements in the collection.
     */
    /**
     * Deserializes the beginning of a list.
     * @returns {AnonReadColBeginReturn}
     */
    readListBegin: function() {
        var list = this.rstack[this.rstack.length - 1];

        var r = {};
        r.etype = Thrift.Protocol.RType[list.shift()];
        r.size = list.shift();

        this.rpos.push(this.rstack.length);
        this.rstack.push(list.shift());

        return r;
    },

    /** Deserializes the end of a list. */
    readListEnd: function() {
        var pos = this.rpos.pop() - 2;
        var st = this.rstack;
        st.pop();
        if (st instanceof Array && st.length > pos && st[pos].length > 0) {
          st.push(st[pos].shift());
        }
    },

    /**
     * Deserializes the beginning of a set.
     * @returns {AnonReadColBeginReturn}
     */
    readSetBegin: function(elemType, size) {
        return this.readListBegin(elemType, size);
    },

    /** Deserializes the end of a set. */
    readSetEnd: function() {
        return this.readListEnd();
    },

    /** Returns an object with a value property set to
     *  False unless the next number in the protocol buffer
     *  is 1, in which case the value property is True */
    readBool: function() {
        var r = this.readI32();

        if (r !== null && r.value == '1') {
            r.value = true;
        } else {
            r.value = false;
        }

        return r;
    },

    /** Returns the an object with a value property set to the
        next value found in the protocol buffer */
    readByte: function() {
        return this.readI32();
    },

    /** Returns the an object with a value property set to the
        next value found in the protocol buffer */
    readI16: function() {
        return this.readI32();
    },

    /** Returns the an object with a value property set to the
        next value found in the protocol buffer */
    readI32: function(f) {
        if (f === undefined) {
            f = this.rstack[this.rstack.length - 1];
        }

        var r = {};

        if (f instanceof Array) {
            if (f.length === 0) {
                r.value = undefined;
            } else {
                if (!f.isReversed) {
                    f.reverse();
                    f.isReversed = true;
                }
                r.value = f.pop();
            }
        } else if (f instanceof Object) {
           for (var i in f) {
                if (i === null) {
                  continue;
                }
                this.rstack.push(f[i]);
                delete f[i];

                r.value = i;
                break;
           }
        } else {
            r.value = f;
            this.rstack.pop();
        }

        return r;
    },

    /** Returns the an object with a value property set to the
        next value found in the protocol buffer */
    readI64: function(f) {
        if (f === undefined) {
            f = this.rstack[this.rstack.length - 1];
        }

        var r = {};

        if (f instanceof Array) {
            if (f.length === 0) {
                r.value = undefined;
            } else {
                if (!f.isReversed) {
                    f.reverse();
                    f.isReversed = true;
                }
                r.value = f.pop();
            }
        } else if (f instanceof Object) {
            var int64Object = true;
            var objectKeys = Object.keys(f).sort();
            var int64Keys = ['buffer', 'offset'];
            if (objectKeys.length !== int64Keys.length) {
                int64Object = false;
            }
            for (var it=0; int64Object && it < objectKeys.length; ++it) {
                if (objectKeys[it] !== int64Keys[it]) {
                    int64Object = false;
                }
            }
            if (int64Object) {
                r.value = f;
            } else {
                for (var i in f) {
                    if (i === null) {
                    continue;
                    }
                    this.rstack.push(f[i]);
                    delete f[i];

                    r.value = i;
                    break;
                }
            }
        } else {
            r.value = f;
            this.rstack.pop();
        }
        return r;
    },

    /** Returns the an object with a value property set to the
        next value found in the protocol buffer */
    readDouble: function() {
        return this.readI32();
    },

    /** Returns the an object with a value property set to the
        next value found in the protocol buffer */
    readString: function() {
        var r = this.readI32();
        return r;
    },

    /** Returns the an object with a value property set to the
        next value found in the protocol buffer */
    readBinary: function() {
        var r = this.readI32();
        r.value = atob(r.value);
        return r;
    },

    /**
     * Method to arbitrarily skip over data */
    skip: function(type) {
        var ret, i;
        switch (type) {
            case Thrift.Type.BOOL:
                return this.readBool();

            case Thrift.Type.BYTE:
                return this.readByte();

            case Thrift.Type.I16:
                return this.readI16();

            case Thrift.Type.I32:
                return this.readI32();

            case Thrift.Type.I64:
                return this.readI64();

            case Thrift.Type.DOUBLE:
                return this.readDouble();

            case Thrift.Type.STRING:
                return this.readString();

            case Thrift.Type.STRUCT:
                this.readStructBegin();
                while (true) {
                    ret = this.readFieldBegin();
                    if (ret.ftype == Thrift.Type.STOP) {
                        break;
                    }
                    this.skip(ret.ftype);
                    this.readFieldEnd();
                }
                this.readStructEnd();
                return null;

            case Thrift.Type.MAP:
                ret = this.readMapBegin();
                for (i = 0; i < ret.size; i++) {
                    if (i > 0) {
                        if (this.rstack.length > this.rpos[this.rpos.length - 1] + 1) {
                            this.rstack.pop();
                        }
                    }
                    this.skip(ret.ktype);
                    this.skip(ret.vtype);
                }
                this.readMapEnd();
                return null;

            case Thrift.Type.SET:
                ret = this.readSetBegin();
                for (i = 0; i < ret.size; i++) {
                    this.skip(ret.etype);
                }
                this.readSetEnd();
                return null;

            case Thrift.Type.LIST:
                ret = this.readListBegin();
                for (i = 0; i < ret.size; i++) {
                    this.skip(ret.etype);
                }
                this.readListEnd();
                return null;

            default:
                throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.INVALID_DATA);
        }
    }
};


/**
 * Initializes a MutilplexProtocol Implementation as a Wrapper for Thrift.Protocol
 * @constructor
 */
Thrift.MultiplexProtocol = function(srvName, trans, strictRead, strictWrite) {
    Thrift.Protocol.call(this, trans, strictRead, strictWrite);
    this.serviceName = srvName;
};
Thrift.inherits(Thrift.MultiplexProtocol, Thrift.Protocol, 'multiplexProtocol');

/** Override writeMessageBegin method of prototype*/
Thrift.MultiplexProtocol.prototype.writeMessageBegin = function(name, type, seqid) {

    if (type === Thrift.MessageType.CALL || type === Thrift.MessageType.ONEWAY) {
        Thrift.Protocol.prototype.writeMessageBegin.call(this, this.serviceName + ':' + name, type, seqid);
    } else {
        Thrift.Protocol.prototype.writeMessageBegin.call(this, name, type, seqid);
    }
};

Thrift.Multiplexer = function() {
    this.seqid = 0;
};

/** Instantiates a multiplexed client for a specific service
 * @constructor
 * @param {String} serviceName - The transport to serialize to/from.
 * @param {Thrift.ServiceClient} SCl - The Service Client Class
 * @param {Thrift.Transport} transport - Thrift.Transport instance which provides remote host:port
 * @example
 *    var mp = new Thrift.Multiplexer();
 *    var transport = new Thrift.Transport("http://localhost:9090/foo.thrift");
 *    var protocol = new Thrift.Protocol(transport);
 *    var client = mp.createClient('AuthService', AuthServiceClient, transport);
*/
Thrift.Multiplexer.prototype.createClient = function(serviceName, SCl, transport) {
    if (SCl.Client) {
        SCl = SCl.Client;
    }
    var self = this;
    SCl.prototype.new_seqid = function() {
        self.seqid += 1;
        return self.seqid;
    };
    var client = new SCl(new Thrift.MultiplexProtocol(serviceName, transport));

    return client;
};



var copyList, copyMap;

copyList = function(lst, types) {

  if (!lst) {return lst; }

  var type;

  if (types.shift === undefined) {
    type = types;
  }
  else {
    type = types[0];
  }
  var Type = type;

  var len = lst.length, result = [], i, val;
  for (i = 0; i < len; i++) {
    val = lst[i];
    if (type === null) {
      result.push(val);
    }
    else if (type === copyMap || type === copyList) {
      result.push(type(val, types.slice(1)));
    }
    else {
      result.push(new Type(val));
    }
  }
  return result;
};

copyMap = function(obj, types) {

  if (!obj) {return obj; }

  var type;

  if (types.shift === undefined) {
    type = types;
  }
  else {
    type = types[0];
  }
  var Type = type;

  var result = {}, val;
  for (var prop in obj) {
    if (obj.hasOwnProperty(prop)) {
      val = obj[prop];
      if (type === null) {
        result[prop] = val;
      }
      else if (type === copyMap || type === copyList) {
        result[prop] = type(val, types.slice(1));
      }
      else {
        result[prop] = new Type(val);
      }
    }
  }
  return result;
};

Thrift.copyMap = copyMap;
Thrift.copyList = copyList;
//
// Autogenerated by Thrift Compiler (0.13.0)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//
if (typeof Int64 === 'undefined' && typeof require === 'function') {
  const Int64 = require('node-int64');
}


//HELPER FUNCTIONS AND STRUCTURES

DocumentService_calculatePermissions_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_calculatePermissions_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 3);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_calculatePermissions_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new DocPermissions(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new DocPermissions();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_calculatePermissions_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_createOrUpdateDocument_args = class {
  constructor(args) {
    this.token = null;
    this.document = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.document !== undefined && args.document !== null) {
        this.document = new Document(args.document);
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.document = new Document();
          this.document.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_createOrUpdateDocument_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.document !== null && this.document !== undefined) {
      output.writeFieldBegin('document', Thrift.Type.STRUCT, 2);
      this.document.write(output);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 3);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_createOrUpdateDocument_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new Document(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new Document();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_createOrUpdateDocument_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_updateDocument_args = class {
  constructor(args) {
    this.token = null;
    this.document = null;
    this.accessPolicy = null;
    this.addedResponsibles = null;
    this.removedResponsibles = null;
    this.addedSecurityClassificationIds = null;
    this.removedSecurityClassificationIds = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.document !== undefined && args.document !== null) {
        this.document = new Document(args.document);
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
      if (args.addedResponsibles !== undefined && args.addedResponsibles !== null) {
        this.addedResponsibles = Thrift.copyList(args.addedResponsibles, [UserOrGroup]);
      }
      if (args.removedResponsibles !== undefined && args.removedResponsibles !== null) {
        this.removedResponsibles = Thrift.copyList(args.removedResponsibles, [UserOrGroup]);
      }
      if (args.addedSecurityClassificationIds !== undefined && args.addedSecurityClassificationIds !== null) {
        this.addedSecurityClassificationIds = Thrift.copyList(args.addedSecurityClassificationIds, [null]);
      }
      if (args.removedSecurityClassificationIds !== undefined && args.removedSecurityClassificationIds !== null) {
        this.removedSecurityClassificationIds = Thrift.copyList(args.removedSecurityClassificationIds, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.document = new Document();
          this.document.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.LIST) {
          this.addedResponsibles = [];
          const _rtmp3261 = input.readListBegin();
          const _size260 = _rtmp3261.size || 0;
          for (let _i262 = 0; _i262 < _size260; ++_i262) {
            let elem263 = null;
            elem263 = new UserOrGroup();
            elem263.read(input);
            this.addedResponsibles.push(elem263);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.LIST) {
          this.removedResponsibles = [];
          const _rtmp3265 = input.readListBegin();
          const _size264 = _rtmp3265.size || 0;
          for (let _i266 = 0; _i266 < _size264; ++_i266) {
            let elem267 = null;
            elem267 = new UserOrGroup();
            elem267.read(input);
            this.removedResponsibles.push(elem267);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.LIST) {
          this.addedSecurityClassificationIds = [];
          const _rtmp3269 = input.readListBegin();
          const _size268 = _rtmp3269.size || 0;
          for (let _i270 = 0; _i270 < _size268; ++_i270) {
            let elem271 = null;
            elem271 = input.readString().value;
            this.addedSecurityClassificationIds.push(elem271);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.LIST) {
          this.removedSecurityClassificationIds = [];
          const _rtmp3273 = input.readListBegin();
          const _size272 = _rtmp3273.size || 0;
          for (let _i274 = 0; _i274 < _size272; ++_i274) {
            let elem275 = null;
            elem275 = input.readString().value;
            this.removedSecurityClassificationIds.push(elem275);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_updateDocument_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.document !== null && this.document !== undefined) {
      output.writeFieldBegin('document', Thrift.Type.STRUCT, 2);
      this.document.write(output);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 3);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    if (this.addedResponsibles !== null && this.addedResponsibles !== undefined) {
      output.writeFieldBegin('addedResponsibles', Thrift.Type.LIST, 4);
      output.writeListBegin(Thrift.Type.STRUCT, this.addedResponsibles.length);
      for (let iter276 in this.addedResponsibles) {
        if (this.addedResponsibles.hasOwnProperty(iter276)) {
          iter276 = this.addedResponsibles[iter276];
          iter276.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.removedResponsibles !== null && this.removedResponsibles !== undefined) {
      output.writeFieldBegin('removedResponsibles', Thrift.Type.LIST, 5);
      output.writeListBegin(Thrift.Type.STRUCT, this.removedResponsibles.length);
      for (let iter277 in this.removedResponsibles) {
        if (this.removedResponsibles.hasOwnProperty(iter277)) {
          iter277 = this.removedResponsibles[iter277];
          iter277.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.addedSecurityClassificationIds !== null && this.addedSecurityClassificationIds !== undefined) {
      output.writeFieldBegin('addedSecurityClassificationIds', Thrift.Type.LIST, 6);
      output.writeListBegin(Thrift.Type.STRING, this.addedSecurityClassificationIds.length);
      for (let iter278 in this.addedSecurityClassificationIds) {
        if (this.addedSecurityClassificationIds.hasOwnProperty(iter278)) {
          iter278 = this.addedSecurityClassificationIds[iter278];
          output.writeString(iter278);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.removedSecurityClassificationIds !== null && this.removedSecurityClassificationIds !== undefined) {
      output.writeFieldBegin('removedSecurityClassificationIds', Thrift.Type.LIST, 7);
      output.writeListBegin(Thrift.Type.STRING, this.removedSecurityClassificationIds.length);
      for (let iter279 in this.removedSecurityClassificationIds) {
        if (this.removedSecurityClassificationIds.hasOwnProperty(iter279)) {
          iter279 = this.removedSecurityClassificationIds[iter279];
          output.writeString(iter279);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_updateDocument_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new Document(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new Document();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_updateDocument_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_createDocument_args = class {
  constructor(args) {
    this.token = null;
    this.document = null;
    this.users = null;
    this.holderLinks = null;
    this.securityClassificationsId = null;
    this.attachments = null;
    this.docRelations = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.document !== undefined && args.document !== null) {
        this.document = new Document(args.document);
      }
      if (args.users !== undefined && args.users !== null) {
        this.users = Thrift.copyList(args.users, [UserOrGroup]);
      }
      if (args.holderLinks !== undefined && args.holderLinks !== null) {
        this.holderLinks = Thrift.copyList(args.holderLinks, [ContentHolderLink]);
      }
      if (args.securityClassificationsId !== undefined && args.securityClassificationsId !== null) {
        this.securityClassificationsId = Thrift.copyList(args.securityClassificationsId, [null]);
      }
      if (args.attachments !== undefined && args.attachments !== null) {
        this.attachments = Thrift.copyList(args.attachments, [AttCreateInfo]);
      }
      if (args.docRelations !== undefined && args.docRelations !== null) {
        this.docRelations = Thrift.copyList(args.docRelations, [DocumentRelation]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.document = new Document();
          this.document.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.users = [];
          const _rtmp3281 = input.readListBegin();
          const _size280 = _rtmp3281.size || 0;
          for (let _i282 = 0; _i282 < _size280; ++_i282) {
            let elem283 = null;
            elem283 = new UserOrGroup();
            elem283.read(input);
            this.users.push(elem283);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.LIST) {
          this.holderLinks = [];
          const _rtmp3285 = input.readListBegin();
          const _size284 = _rtmp3285.size || 0;
          for (let _i286 = 0; _i286 < _size284; ++_i286) {
            let elem287 = null;
            elem287 = new ContentHolderLink();
            elem287.read(input);
            this.holderLinks.push(elem287);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.SET) {
          this.securityClassificationsId = [];
          const _rtmp3289 = input.readSetBegin();
          const _size288 = _rtmp3289.size || 0;
          for (let _i290 = 0; _i290 < _size288; ++_i290) {
            let elem291 = null;
            elem291 = input.readString().value;
            this.securityClassificationsId.push(elem291);
          }
          input.readSetEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.LIST) {
          this.attachments = [];
          const _rtmp3293 = input.readListBegin();
          const _size292 = _rtmp3293.size || 0;
          for (let _i294 = 0; _i294 < _size292; ++_i294) {
            let elem295 = null;
            elem295 = new AttCreateInfo();
            elem295.read(input);
            this.attachments.push(elem295);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.LIST) {
          this.docRelations = [];
          const _rtmp3297 = input.readListBegin();
          const _size296 = _rtmp3297.size || 0;
          for (let _i298 = 0; _i298 < _size296; ++_i298) {
            let elem299 = null;
            elem299 = new DocumentRelation();
            elem299.read(input);
            this.docRelations.push(elem299);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_createDocument_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.document !== null && this.document !== undefined) {
      output.writeFieldBegin('document', Thrift.Type.STRUCT, 2);
      this.document.write(output);
      output.writeFieldEnd();
    }
    if (this.users !== null && this.users !== undefined) {
      output.writeFieldBegin('users', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRUCT, this.users.length);
      for (let iter300 in this.users) {
        if (this.users.hasOwnProperty(iter300)) {
          iter300 = this.users[iter300];
          iter300.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.holderLinks !== null && this.holderLinks !== undefined) {
      output.writeFieldBegin('holderLinks', Thrift.Type.LIST, 4);
      output.writeListBegin(Thrift.Type.STRUCT, this.holderLinks.length);
      for (let iter301 in this.holderLinks) {
        if (this.holderLinks.hasOwnProperty(iter301)) {
          iter301 = this.holderLinks[iter301];
          iter301.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.securityClassificationsId !== null && this.securityClassificationsId !== undefined) {
      output.writeFieldBegin('securityClassificationsId', Thrift.Type.SET, 5);
      output.writeSetBegin(Thrift.Type.STRING, this.securityClassificationsId.length);
      for (let iter302 in this.securityClassificationsId) {
        if (this.securityClassificationsId.hasOwnProperty(iter302)) {
          iter302 = this.securityClassificationsId[iter302];
          output.writeString(iter302);
        }
      }
      output.writeSetEnd();
      output.writeFieldEnd();
    }
    if (this.attachments !== null && this.attachments !== undefined) {
      output.writeFieldBegin('attachments', Thrift.Type.LIST, 6);
      output.writeListBegin(Thrift.Type.STRUCT, this.attachments.length);
      for (let iter303 in this.attachments) {
        if (this.attachments.hasOwnProperty(iter303)) {
          iter303 = this.attachments[iter303];
          iter303.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.docRelations !== null && this.docRelations !== undefined) {
      output.writeFieldBegin('docRelations', Thrift.Type.LIST, 7);
      output.writeListBegin(Thrift.Type.STRUCT, this.docRelations.length);
      for (let iter304 in this.docRelations) {
        if (this.docRelations.hasOwnProperty(iter304)) {
          iter304 = this.docRelations[iter304];
          iter304.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_createDocument_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new Document(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new Document();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_createDocument_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_createDocumentFromXML_args = class {
  constructor(args) {
    this.token = null;
    this.xmlDoc = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.xmlDoc !== undefined && args.xmlDoc !== null) {
        this.xmlDoc = args.xmlDoc;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.xmlDoc = input.readBinary().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_createDocumentFromXML_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.xmlDoc !== null && this.xmlDoc !== undefined) {
      output.writeFieldBegin('xmlDoc', Thrift.Type.STRING, 2);
      output.writeBinary(this.xmlDoc);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_createDocumentFromXML_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new Document(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new Document();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_createDocumentFromXML_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getDocument_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.accessPolicy = null;
    this.decrypt = null;
    this.executorsPortion = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
      if (args.decrypt !== undefined && args.decrypt !== null) {
        this.decrypt = args.decrypt;
      }
      if (args.executorsPortion !== undefined && args.executorsPortion !== null) {
        this.executorsPortion = args.executorsPortion;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.BOOL) {
          this.decrypt = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.I32) {
          this.executorsPortion = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getDocument_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 3);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    if (this.decrypt !== null && this.decrypt !== undefined) {
      output.writeFieldBegin('decrypt', Thrift.Type.BOOL, 4);
      output.writeBool(this.decrypt);
      output.writeFieldEnd();
    }
    if (this.executorsPortion !== null && this.executorsPortion !== undefined) {
      output.writeFieldBegin('executorsPortion', Thrift.Type.I32, 5);
      output.writeI32(this.executorsPortion);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getDocument_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new Document(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new Document();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getDocument_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getAllDocuments_args = class {
  constructor(args) {
    this.token = null;
    this.accessPolicy = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getAllDocuments_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 2);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 3);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getAllDocuments_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [Document]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3306 = input.readListBegin();
          const _size305 = _rtmp3306.size || 0;
          for (let _i307 = 0; _i307 < _size305; ++_i307) {
            let elem308 = null;
            elem308 = new Document();
            elem308.read(input);
            this.success.push(elem308);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getAllDocuments_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter309 in this.success) {
        if (this.success.hasOwnProperty(iter309)) {
          iter309 = this.success[iter309];
          iter309.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getCountAllDocuments_args = class {
  constructor(args) {
    this.token = null;
    this.accessPolicy = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getCountAllDocuments_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 2);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 3);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getCountAllDocuments_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.I32) {
          this.success = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getCountAllDocuments_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.I32, 0);
      output.writeI32(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_deleteDocument_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_deleteDocument_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 3);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_deleteDocument_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_deleteDocument_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getAllPassedStages_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.accessPolicy = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getAllPassedStages_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 3);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 4);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getAllPassedStages_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [PassedStage]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3311 = input.readListBegin();
          const _size310 = _rtmp3311.size || 0;
          for (let _i312 = 0; _i312 < _size310; ++_i312) {
            let elem313 = null;
            elem313 = new PassedStage();
            elem313.read(input);
            this.success.push(elem313);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getAllPassedStages_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter314 in this.success) {
        if (this.success.hasOwnProperty(iter314)) {
          iter314 = this.success[iter314];
          iter314.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getExecutionTree_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.accessPolicy = null;
    this.iteration = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
      if (args.iteration !== undefined && args.iteration !== null) {
        this.iteration = args.iteration;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I32) {
          this.iteration = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getExecutionTree_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 3);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    if (this.iteration !== null && this.iteration !== undefined) {
      output.writeFieldBegin('iteration', Thrift.Type.I32, 4);
      output.writeI32(this.iteration);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 5);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getExecutionTree_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [ExecutionTree]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3316 = input.readListBegin();
          const _size315 = _rtmp3316.size || 0;
          for (let _i317 = 0; _i317 < _size315; ++_i317) {
            let elem318 = null;
            elem318 = new ExecutionTree();
            elem318.read(input);
            this.success.push(elem318);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getExecutionTree_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter319 in this.success) {
        if (this.success.hasOwnProperty(iter319)) {
          iter319 = this.success[iter319];
          iter319.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getActiveStages_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getActiveStages_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 3);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getActiveStages_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [DocumentPatternStage]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3321 = input.readListBegin();
          const _size320 = _rtmp3321.size || 0;
          for (let _i322 = 0; _i322 < _size320; ++_i322) {
            let elem323 = null;
            elem323 = new DocumentPatternStage();
            elem323.read(input);
            this.success.push(elem323);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getActiveStages_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter324 in this.success) {
        if (this.success.hasOwnProperty(iter324)) {
          iter324 = this.success[iter324];
          iter324.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getCountPeoplesWhenRenderedDecision_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.stageId = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.stageId !== undefined && args.stageId !== null) {
        this.stageId = args.stageId;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.stageId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getCountPeoplesWhenRenderedDecision_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.stageId !== null && this.stageId !== undefined) {
      output.writeFieldBegin('stageId', Thrift.Type.STRING, 3);
      output.writeString(this.stageId);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 4);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getCountPeoplesWhenRenderedDecision_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyMap(args.success, [null]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.MAP) {
          this.success = {};
          const _rtmp3326 = input.readMapBegin();
          const _size325 = _rtmp3326.size || 0;
          for (let _i327 = 0; _i327 < _size325; ++_i327) {
            if (_i327 > 0 ) {
              if (input.rstack.length > input.rpos[input.rpos.length -1] + 1) {
                input.rstack.pop();
              }
            }
            let key328 = null;
            let val329 = null;
            key328 = input.readString().value;
            val329 = input.readI32().value;
            this.success[key328] = val329;
          }
          input.readMapEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getCountPeoplesWhenRenderedDecision_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.MAP, 0);
      output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.I32, Thrift.objectLength(this.success));
      for (let kiter330 in this.success) {
        if (this.success.hasOwnProperty(kiter330)) {
          let viter331 = this.success[kiter330];
          output.writeString(kiter330);
          output.writeI32(viter331);
        }
      }
      output.writeMapEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_setDocumentDecision_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.decision = null;
    this.documentComment = null;
    this.force = null;
    this.signature = null;
    this.cardId = null;
    this.attachments = null;
    this.holderLinks = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.decision !== undefined && args.decision !== null) {
        this.decision = args.decision;
      }
      if (args.documentComment !== undefined && args.documentComment !== null) {
        this.documentComment = args.documentComment;
      }
      if (args.force !== undefined && args.force !== null) {
        this.force = args.force;
      }
      if (args.signature !== undefined && args.signature !== null) {
        this.signature = args.signature;
      }
      if (args.cardId !== undefined && args.cardId !== null) {
        this.cardId = args.cardId;
      }
      if (args.attachments !== undefined && args.attachments !== null) {
        this.attachments = Thrift.copyList(args.attachments, [AttCreateInfo]);
      }
      if (args.holderLinks !== undefined && args.holderLinks !== null) {
        this.holderLinks = Thrift.copyList(args.holderLinks, [ContentHolderLink]);
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.decision = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.documentComment = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.BOOL) {
          this.force = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.STRING) {
          this.signature = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.STRING) {
          this.cardId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.LIST) {
          this.attachments = [];
          const _rtmp3333 = input.readListBegin();
          const _size332 = _rtmp3333.size || 0;
          for (let _i334 = 0; _i334 < _size332; ++_i334) {
            let elem335 = null;
            elem335 = new AttCreateInfo();
            elem335.read(input);
            this.attachments.push(elem335);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 9:
        if (ftype == Thrift.Type.LIST) {
          this.holderLinks = [];
          const _rtmp3337 = input.readListBegin();
          const _size336 = _rtmp3337.size || 0;
          for (let _i338 = 0; _i338 < _size336; ++_i338) {
            let elem339 = null;
            elem339 = new ContentHolderLink();
            elem339.read(input);
            this.holderLinks.push(elem339);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 10:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_setDocumentDecision_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.decision !== null && this.decision !== undefined) {
      output.writeFieldBegin('decision', Thrift.Type.STRING, 3);
      output.writeString(this.decision);
      output.writeFieldEnd();
    }
    if (this.documentComment !== null && this.documentComment !== undefined) {
      output.writeFieldBegin('documentComment', Thrift.Type.STRING, 4);
      output.writeString(this.documentComment);
      output.writeFieldEnd();
    }
    if (this.force !== null && this.force !== undefined) {
      output.writeFieldBegin('force', Thrift.Type.BOOL, 5);
      output.writeBool(this.force);
      output.writeFieldEnd();
    }
    if (this.signature !== null && this.signature !== undefined) {
      output.writeFieldBegin('signature', Thrift.Type.STRING, 6);
      output.writeString(this.signature);
      output.writeFieldEnd();
    }
    if (this.cardId !== null && this.cardId !== undefined) {
      output.writeFieldBegin('cardId', Thrift.Type.STRING, 7);
      output.writeString(this.cardId);
      output.writeFieldEnd();
    }
    if (this.attachments !== null && this.attachments !== undefined) {
      output.writeFieldBegin('attachments', Thrift.Type.LIST, 8);
      output.writeListBegin(Thrift.Type.STRUCT, this.attachments.length);
      for (let iter340 in this.attachments) {
        if (this.attachments.hasOwnProperty(iter340)) {
          iter340 = this.attachments[iter340];
          iter340.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.holderLinks !== null && this.holderLinks !== undefined) {
      output.writeFieldBegin('holderLinks', Thrift.Type.LIST, 9);
      output.writeListBegin(Thrift.Type.STRUCT, this.holderLinks.length);
      for (let iter341 in this.holderLinks) {
        if (this.holderLinks.hasOwnProperty(iter341)) {
          iter341 = this.holderLinks[iter341];
          iter341.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 10);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_setDocumentDecision_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new Document(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new Document();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_setDocumentDecision_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_setDocumentDecisionUsingServerKeyStorage_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.decision = null;
    this.documentComment = null;
    this.force = null;
    this.pKeyId = null;
    this.password = null;
    this.cardId = null;
    this.attachments = null;
    this.holderLinks = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.decision !== undefined && args.decision !== null) {
        this.decision = args.decision;
      }
      if (args.documentComment !== undefined && args.documentComment !== null) {
        this.documentComment = args.documentComment;
      }
      if (args.force !== undefined && args.force !== null) {
        this.force = args.force;
      }
      if (args.pKeyId !== undefined && args.pKeyId !== null) {
        this.pKeyId = args.pKeyId;
      }
      if (args.password !== undefined && args.password !== null) {
        this.password = args.password;
      }
      if (args.cardId !== undefined && args.cardId !== null) {
        this.cardId = args.cardId;
      }
      if (args.attachments !== undefined && args.attachments !== null) {
        this.attachments = Thrift.copyList(args.attachments, [AttCreateInfo]);
      }
      if (args.holderLinks !== undefined && args.holderLinks !== null) {
        this.holderLinks = Thrift.copyList(args.holderLinks, [ContentHolderLink]);
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.decision = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.documentComment = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.BOOL) {
          this.force = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.STRING) {
          this.pKeyId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.STRING) {
          this.password = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.STRING) {
          this.cardId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 9:
        if (ftype == Thrift.Type.LIST) {
          this.attachments = [];
          const _rtmp3343 = input.readListBegin();
          const _size342 = _rtmp3343.size || 0;
          for (let _i344 = 0; _i344 < _size342; ++_i344) {
            let elem345 = null;
            elem345 = new AttCreateInfo();
            elem345.read(input);
            this.attachments.push(elem345);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 10:
        if (ftype == Thrift.Type.LIST) {
          this.holderLinks = [];
          const _rtmp3347 = input.readListBegin();
          const _size346 = _rtmp3347.size || 0;
          for (let _i348 = 0; _i348 < _size346; ++_i348) {
            let elem349 = null;
            elem349 = new ContentHolderLink();
            elem349.read(input);
            this.holderLinks.push(elem349);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 11:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_setDocumentDecisionUsingServerKeyStorage_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.decision !== null && this.decision !== undefined) {
      output.writeFieldBegin('decision', Thrift.Type.STRING, 3);
      output.writeString(this.decision);
      output.writeFieldEnd();
    }
    if (this.documentComment !== null && this.documentComment !== undefined) {
      output.writeFieldBegin('documentComment', Thrift.Type.STRING, 4);
      output.writeString(this.documentComment);
      output.writeFieldEnd();
    }
    if (this.force !== null && this.force !== undefined) {
      output.writeFieldBegin('force', Thrift.Type.BOOL, 5);
      output.writeBool(this.force);
      output.writeFieldEnd();
    }
    if (this.pKeyId !== null && this.pKeyId !== undefined) {
      output.writeFieldBegin('pKeyId', Thrift.Type.STRING, 6);
      output.writeString(this.pKeyId);
      output.writeFieldEnd();
    }
    if (this.password !== null && this.password !== undefined) {
      output.writeFieldBegin('password', Thrift.Type.STRING, 7);
      output.writeString(this.password);
      output.writeFieldEnd();
    }
    if (this.cardId !== null && this.cardId !== undefined) {
      output.writeFieldBegin('cardId', Thrift.Type.STRING, 8);
      output.writeString(this.cardId);
      output.writeFieldEnd();
    }
    if (this.attachments !== null && this.attachments !== undefined) {
      output.writeFieldBegin('attachments', Thrift.Type.LIST, 9);
      output.writeListBegin(Thrift.Type.STRUCT, this.attachments.length);
      for (let iter350 in this.attachments) {
        if (this.attachments.hasOwnProperty(iter350)) {
          iter350 = this.attachments[iter350];
          iter350.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.holderLinks !== null && this.holderLinks !== undefined) {
      output.writeFieldBegin('holderLinks', Thrift.Type.LIST, 10);
      output.writeListBegin(Thrift.Type.STRUCT, this.holderLinks.length);
      for (let iter351 in this.holderLinks) {
        if (this.holderLinks.hasOwnProperty(iter351)) {
          iter351 = this.holderLinks[iter351];
          iter351.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 11);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_setDocumentDecisionUsingServerKeyStorage_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new Document(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new Document();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_setDocumentDecisionUsingServerKeyStorage_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_approveDocumentDecision_args = class {
  constructor(args) {
    this.token = null;
    this.executionId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.executionId !== undefined && args.executionId !== null) {
        this.executionId = args.executionId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.executionId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_approveDocumentDecision_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.executionId !== null && this.executionId !== undefined) {
      output.writeFieldBegin('executionId', Thrift.Type.STRING, 2);
      output.writeString(this.executionId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_approveDocumentDecision_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_approveDocumentDecision_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_shareDocument_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.accessPolicy = null;
    this.usersOrGroups = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
      if (args.usersOrGroups !== undefined && args.usersOrGroups !== null) {
        this.usersOrGroups = Thrift.copyList(args.usersOrGroups, [UserOrGroup]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.LIST) {
          this.usersOrGroups = [];
          const _rtmp3353 = input.readListBegin();
          const _size352 = _rtmp3353.size || 0;
          for (let _i354 = 0; _i354 < _size352; ++_i354) {
            let elem355 = null;
            elem355 = new UserOrGroup();
            elem355.read(input);
            this.usersOrGroups.push(elem355);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_shareDocument_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 3);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    if (this.usersOrGroups !== null && this.usersOrGroups !== undefined) {
      output.writeFieldBegin('usersOrGroups', Thrift.Type.LIST, 4);
      output.writeListBegin(Thrift.Type.STRUCT, this.usersOrGroups.length);
      for (let iter356 in this.usersOrGroups) {
        if (this.usersOrGroups.hasOwnProperty(iter356)) {
          iter356 = this.usersOrGroups[iter356];
          iter356.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_shareDocument_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [DocumentExecution]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3358 = input.readListBegin();
          const _size357 = _rtmp3358.size || 0;
          for (let _i359 = 0; _i359 < _size357; ++_i359) {
            let elem360 = null;
            elem360 = new DocumentExecution();
            elem360.read(input);
            this.success.push(elem360);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_shareDocument_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter361 in this.success) {
        if (this.success.hasOwnProperty(iter361)) {
          iter361 = this.success[iter361];
          iter361.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_revokeDocument_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.usersOrGroups = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.usersOrGroups !== undefined && args.usersOrGroups !== null) {
        this.usersOrGroups = Thrift.copyList(args.usersOrGroups, [UserOrGroup]);
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.usersOrGroups = [];
          const _rtmp3363 = input.readListBegin();
          const _size362 = _rtmp3363.size || 0;
          for (let _i364 = 0; _i364 < _size362; ++_i364) {
            let elem365 = null;
            elem365 = new UserOrGroup();
            elem365.read(input);
            this.usersOrGroups.push(elem365);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_revokeDocument_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.usersOrGroups !== null && this.usersOrGroups !== undefined) {
      output.writeFieldBegin('usersOrGroups', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRUCT, this.usersOrGroups.length);
      for (let iter366 in this.usersOrGroups) {
        if (this.usersOrGroups.hasOwnProperty(iter366)) {
          iter366 = this.usersOrGroups[iter366];
          iter366.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 4);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_revokeDocument_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_revokeDocument_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getAllDocumentSharings_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.accessPolicy = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getAllDocumentSharings_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 3);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 4);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getAllDocumentSharings_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [UserOrGroup]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3368 = input.readListBegin();
          const _size367 = _rtmp3368.size || 0;
          for (let _i369 = 0; _i369 < _size367; ++_i369) {
            let elem370 = null;
            elem370 = new UserOrGroup();
            elem370.read(input);
            this.success.push(elem370);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getAllDocumentSharings_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter371 in this.success) {
        if (this.success.hasOwnProperty(iter371)) {
          iter371 = this.success[iter371];
          iter371.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getAllDocumentReassign_args = class {
  constructor(args) {
    this.token = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getAllDocumentReassign_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 2);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getAllDocumentReassign_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [DocumentReassign]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3373 = input.readListBegin();
          const _size372 = _rtmp3373.size || 0;
          for (let _i374 = 0; _i374 < _size372; ++_i374) {
            let elem375 = null;
            elem375 = new DocumentReassign();
            elem375.read(input);
            this.success.push(elem375);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getAllDocumentReassign_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter376 in this.success) {
        if (this.success.hasOwnProperty(iter376)) {
          iter376 = this.success[iter376];
          iter376.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_reassignDocument_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.documentReassign = null;
    this.cardId = null;
    this.signature = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.documentReassign !== undefined && args.documentReassign !== null) {
        this.documentReassign = Thrift.copyList(args.documentReassign, [DocumentReassign]);
      }
      if (args.cardId !== undefined && args.cardId !== null) {
        this.cardId = args.cardId;
      }
      if (args.signature !== undefined && args.signature !== null) {
        this.signature = args.signature;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.documentReassign = [];
          const _rtmp3378 = input.readListBegin();
          const _size377 = _rtmp3378.size || 0;
          for (let _i379 = 0; _i379 < _size377; ++_i379) {
            let elem380 = null;
            elem380 = new DocumentReassign();
            elem380.read(input);
            this.documentReassign.push(elem380);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.cardId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRING) {
          this.signature = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_reassignDocument_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.documentReassign !== null && this.documentReassign !== undefined) {
      output.writeFieldBegin('documentReassign', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRUCT, this.documentReassign.length);
      for (let iter381 in this.documentReassign) {
        if (this.documentReassign.hasOwnProperty(iter381)) {
          iter381 = this.documentReassign[iter381];
          iter381.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.cardId !== null && this.cardId !== undefined) {
      output.writeFieldBegin('cardId', Thrift.Type.STRING, 4);
      output.writeString(this.cardId);
      output.writeFieldEnd();
    }
    if (this.signature !== null && this.signature !== undefined) {
      output.writeFieldBegin('signature', Thrift.Type.STRING, 5);
      output.writeString(this.signature);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_reassignDocument_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [DocumentExecution]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3383 = input.readListBegin();
          const _size382 = _rtmp3383.size || 0;
          for (let _i384 = 0; _i384 < _size382; ++_i384) {
            let elem385 = null;
            elem385 = new DocumentExecution();
            elem385.read(input);
            this.success.push(elem385);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_reassignDocument_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter386 in this.success) {
        if (this.success.hasOwnProperty(iter386)) {
          iter386 = this.success[iter386];
          iter386.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_reassignDocumentUsingServerKeyStorage_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.documentReassign = null;
    this.cardId = null;
    this.pKeyId = null;
    this.password = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.documentReassign !== undefined && args.documentReassign !== null) {
        this.documentReassign = Thrift.copyList(args.documentReassign, [DocumentReassign]);
      }
      if (args.cardId !== undefined && args.cardId !== null) {
        this.cardId = args.cardId;
      }
      if (args.pKeyId !== undefined && args.pKeyId !== null) {
        this.pKeyId = args.pKeyId;
      }
      if (args.password !== undefined && args.password !== null) {
        this.password = args.password;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.documentReassign = [];
          const _rtmp3388 = input.readListBegin();
          const _size387 = _rtmp3388.size || 0;
          for (let _i389 = 0; _i389 < _size387; ++_i389) {
            let elem390 = null;
            elem390 = new DocumentReassign();
            elem390.read(input);
            this.documentReassign.push(elem390);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.cardId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRING) {
          this.pKeyId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.STRING) {
          this.password = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_reassignDocumentUsingServerKeyStorage_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.documentReassign !== null && this.documentReassign !== undefined) {
      output.writeFieldBegin('documentReassign', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRUCT, this.documentReassign.length);
      for (let iter391 in this.documentReassign) {
        if (this.documentReassign.hasOwnProperty(iter391)) {
          iter391 = this.documentReassign[iter391];
          iter391.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.cardId !== null && this.cardId !== undefined) {
      output.writeFieldBegin('cardId', Thrift.Type.STRING, 4);
      output.writeString(this.cardId);
      output.writeFieldEnd();
    }
    if (this.pKeyId !== null && this.pKeyId !== undefined) {
      output.writeFieldBegin('pKeyId', Thrift.Type.STRING, 5);
      output.writeString(this.pKeyId);
      output.writeFieldEnd();
    }
    if (this.password !== null && this.password !== undefined) {
      output.writeFieldBegin('password', Thrift.Type.STRING, 6);
      output.writeString(this.password);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_reassignDocumentUsingServerKeyStorage_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [DocumentExecution]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3393 = input.readListBegin();
          const _size392 = _rtmp3393.size || 0;
          for (let _i394 = 0; _i394 < _size392; ++_i394) {
            let elem395 = null;
            elem395 = new DocumentExecution();
            elem395.read(input);
            this.success.push(elem395);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_reassignDocumentUsingServerKeyStorage_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter396 in this.success) {
        if (this.success.hasOwnProperty(iter396)) {
          iter396 = this.success[iter396];
          iter396.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_revokeChildCards_args = class {
  constructor(args) {
    this.token = null;
    this.cardId = null;
    this.deleteCard = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.cardId !== undefined && args.cardId !== null) {
        this.cardId = args.cardId;
      }
      if (args.deleteCard !== undefined && args.deleteCard !== null) {
        this.deleteCard = args.deleteCard;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.cardId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.BOOL) {
          this.deleteCard = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_revokeChildCards_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.cardId !== null && this.cardId !== undefined) {
      output.writeFieldBegin('cardId', Thrift.Type.STRING, 2);
      output.writeString(this.cardId);
      output.writeFieldEnd();
    }
    if (this.deleteCard !== null && this.deleteCard !== undefined) {
      output.writeFieldBegin('deleteCard', Thrift.Type.BOOL, 3);
      output.writeBool(this.deleteCard);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 4);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_revokeChildCards_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_revokeChildCards_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_createOrUpdateAutomaticDocumentReassign_args = class {
  constructor(args) {
    this.token = null;
    this.documentReassign = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentReassign !== undefined && args.documentReassign !== null) {
        this.documentReassign = new DocumentReassign(args.documentReassign);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.documentReassign = new DocumentReassign();
          this.documentReassign.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_createOrUpdateAutomaticDocumentReassign_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentReassign !== null && this.documentReassign !== undefined) {
      output.writeFieldBegin('documentReassign', Thrift.Type.STRUCT, 2);
      this.documentReassign.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_createOrUpdateAutomaticDocumentReassign_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new DocumentReassign(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new DocumentReassign();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_createOrUpdateAutomaticDocumentReassign_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_deleteAutomaticDocumentReassign_args = class {
  constructor(args) {
    this.token = null;
    this.documentReassignId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentReassignId !== undefined && args.documentReassignId !== null) {
        this.documentReassignId = args.documentReassignId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentReassignId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_deleteAutomaticDocumentReassign_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentReassignId !== null && this.documentReassignId !== undefined) {
      output.writeFieldBegin('documentReassignId', Thrift.Type.STRING, 2);
      output.writeString(this.documentReassignId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_deleteAutomaticDocumentReassign_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_deleteAutomaticDocumentReassign_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_changeReassignControl_args = class {
  constructor(args) {
    this.token = null;
    this.documentExecutionId = null;
    this.userId = null;
    this.reassignType = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentExecutionId !== undefined && args.documentExecutionId !== null) {
        this.documentExecutionId = args.documentExecutionId;
      }
      if (args.userId !== undefined && args.userId !== null) {
        this.userId = args.userId;
      }
      if (args.reassignType !== undefined && args.reassignType !== null) {
        this.reassignType = args.reassignType;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentExecutionId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.userId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I32) {
          this.reassignType = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_changeReassignControl_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentExecutionId !== null && this.documentExecutionId !== undefined) {
      output.writeFieldBegin('documentExecutionId', Thrift.Type.STRING, 2);
      output.writeString(this.documentExecutionId);
      output.writeFieldEnd();
    }
    if (this.userId !== null && this.userId !== undefined) {
      output.writeFieldBegin('userId', Thrift.Type.STRING, 3);
      output.writeString(this.userId);
      output.writeFieldEnd();
    }
    if (this.reassignType !== null && this.reassignType !== undefined) {
      output.writeFieldBegin('reassignType', Thrift.Type.I32, 4);
      output.writeI32(this.reassignType);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_changeReassignControl_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new DocumentExecution(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new DocumentExecution();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_changeReassignControl_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getAllDocumentExecutions_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.stageId = null;
    this.typeLink = null;
    this.filter = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.stageId !== undefined && args.stageId !== null) {
        this.stageId = args.stageId;
      }
      if (args.typeLink !== undefined && args.typeLink !== null) {
        this.typeLink = args.typeLink;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.stageId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I32) {
          this.typeLink = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getAllDocumentExecutions_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.stageId !== null && this.stageId !== undefined) {
      output.writeFieldBegin('stageId', Thrift.Type.STRING, 3);
      output.writeString(this.stageId);
      output.writeFieldEnd();
    }
    if (this.typeLink !== null && this.typeLink !== undefined) {
      output.writeFieldBegin('typeLink', Thrift.Type.I32, 4);
      output.writeI32(this.typeLink);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 5);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 6);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getAllDocumentExecutions_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [DocumentExecution]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3398 = input.readListBegin();
          const _size397 = _rtmp3398.size || 0;
          for (let _i399 = 0; _i399 < _size397; ++_i399) {
            let elem400 = null;
            elem400 = new DocumentExecution();
            elem400.read(input);
            this.success.push(elem400);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getAllDocumentExecutions_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter401 in this.success) {
        if (this.success.hasOwnProperty(iter401)) {
          iter401 = this.success[iter401];
          iter401.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getDocumentExecution_args = class {
  constructor(args) {
    this.token = null;
    this.docExecutionId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.docExecutionId !== undefined && args.docExecutionId !== null) {
        this.docExecutionId = args.docExecutionId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.docExecutionId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getDocumentExecution_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.docExecutionId !== null && this.docExecutionId !== undefined) {
      output.writeFieldBegin('docExecutionId', Thrift.Type.STRING, 2);
      output.writeString(this.docExecutionId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getDocumentExecution_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new DocumentExecution(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new DocumentExecution();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getDocumentExecution_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_changeExecutorsForDocument_args = class {
  constructor(args) {
    this.token = null;
    this.docId = null;
    this.toAdd = null;
    this.toClose = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.docId !== undefined && args.docId !== null) {
        this.docId = args.docId;
      }
      if (args.toAdd !== undefined && args.toAdd !== null) {
        this.toAdd = Thrift.copyList(args.toAdd, [DocumentReassign]);
      }
      if (args.toClose !== undefined && args.toClose !== null) {
        this.toClose = Thrift.copyList(args.toClose, [null]);
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.docId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.toAdd = [];
          const _rtmp3403 = input.readListBegin();
          const _size402 = _rtmp3403.size || 0;
          for (let _i404 = 0; _i404 < _size402; ++_i404) {
            let elem405 = null;
            elem405 = new DocumentReassign();
            elem405.read(input);
            this.toAdd.push(elem405);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.LIST) {
          this.toClose = [];
          const _rtmp3407 = input.readListBegin();
          const _size406 = _rtmp3407.size || 0;
          for (let _i408 = 0; _i408 < _size406; ++_i408) {
            let elem409 = null;
            elem409 = input.readString().value;
            this.toClose.push(elem409);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_changeExecutorsForDocument_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.docId !== null && this.docId !== undefined) {
      output.writeFieldBegin('docId', Thrift.Type.STRING, 2);
      output.writeString(this.docId);
      output.writeFieldEnd();
    }
    if (this.toAdd !== null && this.toAdd !== undefined) {
      output.writeFieldBegin('toAdd', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRUCT, this.toAdd.length);
      for (let iter410 in this.toAdd) {
        if (this.toAdd.hasOwnProperty(iter410)) {
          iter410 = this.toAdd[iter410];
          iter410.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.toClose !== null && this.toClose !== undefined) {
      output.writeFieldBegin('toClose', Thrift.Type.LIST, 4);
      output.writeListBegin(Thrift.Type.STRING, this.toClose.length);
      for (let iter411 in this.toClose) {
        if (this.toClose.hasOwnProperty(iter411)) {
          iter411 = this.toClose[iter411];
          output.writeString(iter411);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 5);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_changeExecutorsForDocument_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_changeExecutorsForDocument_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_createAttachmentFrom_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.cardId = null;
    this.accessPolicy = null;
    this.attCreateInfoList = null;
    this.processingType = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.cardId !== undefined && args.cardId !== null) {
        this.cardId = args.cardId;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
      if (args.attCreateInfoList !== undefined && args.attCreateInfoList !== null) {
        this.attCreateInfoList = Thrift.copyList(args.attCreateInfoList, [AttCreateInfo]);
      }
      if (args.processingType !== undefined && args.processingType !== null) {
        this.processingType = args.processingType;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.cardId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.LIST) {
          this.attCreateInfoList = [];
          const _rtmp3413 = input.readListBegin();
          const _size412 = _rtmp3413.size || 0;
          for (let _i414 = 0; _i414 < _size412; ++_i414) {
            let elem415 = null;
            elem415 = new AttCreateInfo();
            elem415.read(input);
            this.attCreateInfoList.push(elem415);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.I32) {
          this.processingType = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_createAttachmentFrom_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.cardId !== null && this.cardId !== undefined) {
      output.writeFieldBegin('cardId', Thrift.Type.STRING, 3);
      output.writeString(this.cardId);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 4);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    if (this.attCreateInfoList !== null && this.attCreateInfoList !== undefined) {
      output.writeFieldBegin('attCreateInfoList', Thrift.Type.LIST, 5);
      output.writeListBegin(Thrift.Type.STRUCT, this.attCreateInfoList.length);
      for (let iter416 in this.attCreateInfoList) {
        if (this.attCreateInfoList.hasOwnProperty(iter416)) {
          iter416 = this.attCreateInfoList[iter416];
          iter416.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.processingType !== null && this.processingType !== undefined) {
      output.writeFieldBegin('processingType', Thrift.Type.I32, 6);
      output.writeI32(this.processingType);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_createAttachmentFrom_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [Attachment]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3418 = input.readListBegin();
          const _size417 = _rtmp3418.size || 0;
          for (let _i419 = 0; _i419 < _size417; ++_i419) {
            let elem420 = null;
            elem420 = new Attachment();
            elem420.read(input);
            this.success.push(elem420);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_createAttachmentFrom_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter421 in this.success) {
        if (this.success.hasOwnProperty(iter421)) {
          iter421 = this.success[iter421];
          iter421.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_createLoadableAttachment_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.fileName = null;
    this.totalSize = null;
    this.countPortions = null;
    this.cardId = null;
    this.attachmmentId = null;
    this.forDraft = null;
    this.accessPolicy = null;
    this.editMode = null;
    this.meetingId = null;
    this.extStatus = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.fileName !== undefined && args.fileName !== null) {
        this.fileName = args.fileName;
      }
      if (args.totalSize !== undefined && args.totalSize !== null) {
        this.totalSize = args.totalSize;
      }
      if (args.countPortions !== undefined && args.countPortions !== null) {
        this.countPortions = args.countPortions;
      }
      if (args.cardId !== undefined && args.cardId !== null) {
        this.cardId = args.cardId;
      }
      if (args.attachmmentId !== undefined && args.attachmmentId !== null) {
        this.attachmmentId = args.attachmmentId;
      }
      if (args.forDraft !== undefined && args.forDraft !== null) {
        this.forDraft = args.forDraft;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
      if (args.editMode !== undefined && args.editMode !== null) {
        this.editMode = args.editMode;
      }
      if (args.meetingId !== undefined && args.meetingId !== null) {
        this.meetingId = args.meetingId;
      }
      if (args.extStatus !== undefined && args.extStatus !== null) {
        this.extStatus = args.extStatus;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.fileName = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I64) {
          this.totalSize = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.I32) {
          this.countPortions = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.STRING) {
          this.cardId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.STRING) {
          this.attachmmentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.BOOL) {
          this.forDraft = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 9:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 10:
        if (ftype == Thrift.Type.I32) {
          this.editMode = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 11:
        if (ftype == Thrift.Type.STRING) {
          this.meetingId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 12:
        if (ftype == Thrift.Type.I32) {
          this.extStatus = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_createLoadableAttachment_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.fileName !== null && this.fileName !== undefined) {
      output.writeFieldBegin('fileName', Thrift.Type.STRING, 3);
      output.writeString(this.fileName);
      output.writeFieldEnd();
    }
    if (this.totalSize !== null && this.totalSize !== undefined) {
      output.writeFieldBegin('totalSize', Thrift.Type.I64, 4);
      output.writeI64(this.totalSize);
      output.writeFieldEnd();
    }
    if (this.countPortions !== null && this.countPortions !== undefined) {
      output.writeFieldBegin('countPortions', Thrift.Type.I32, 5);
      output.writeI32(this.countPortions);
      output.writeFieldEnd();
    }
    if (this.cardId !== null && this.cardId !== undefined) {
      output.writeFieldBegin('cardId', Thrift.Type.STRING, 6);
      output.writeString(this.cardId);
      output.writeFieldEnd();
    }
    if (this.attachmmentId !== null && this.attachmmentId !== undefined) {
      output.writeFieldBegin('attachmmentId', Thrift.Type.STRING, 7);
      output.writeString(this.attachmmentId);
      output.writeFieldEnd();
    }
    if (this.forDraft !== null && this.forDraft !== undefined) {
      output.writeFieldBegin('forDraft', Thrift.Type.BOOL, 8);
      output.writeBool(this.forDraft);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 9);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    if (this.editMode !== null && this.editMode !== undefined) {
      output.writeFieldBegin('editMode', Thrift.Type.I32, 10);
      output.writeI32(this.editMode);
      output.writeFieldEnd();
    }
    if (this.meetingId !== null && this.meetingId !== undefined) {
      output.writeFieldBegin('meetingId', Thrift.Type.STRING, 11);
      output.writeString(this.meetingId);
      output.writeFieldEnd();
    }
    if (this.extStatus !== null && this.extStatus !== undefined) {
      output.writeFieldBegin('extStatus', Thrift.Type.I32, 12);
      output.writeI32(this.extStatus);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_createLoadableAttachment_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRING) {
          this.success = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_createLoadableAttachment_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRING, 0);
      output.writeString(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_uploadDocumentAttachmentPortions_args = class {
  constructor(args) {
    this.token = null;
    this.attachmentId = null;
    this.numberPortion = null;
    this.fileContentBytes = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.attachmentId !== undefined && args.attachmentId !== null) {
        this.attachmentId = args.attachmentId;
      }
      if (args.numberPortion !== undefined && args.numberPortion !== null) {
        this.numberPortion = args.numberPortion;
      }
      if (args.fileContentBytes !== undefined && args.fileContentBytes !== null) {
        this.fileContentBytes = args.fileContentBytes;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.attachmentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I32) {
          this.numberPortion = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.fileContentBytes = input.readBinary().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_uploadDocumentAttachmentPortions_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.attachmentId !== null && this.attachmentId !== undefined) {
      output.writeFieldBegin('attachmentId', Thrift.Type.STRING, 2);
      output.writeString(this.attachmentId);
      output.writeFieldEnd();
    }
    if (this.numberPortion !== null && this.numberPortion !== undefined) {
      output.writeFieldBegin('numberPortion', Thrift.Type.I32, 3);
      output.writeI32(this.numberPortion);
      output.writeFieldEnd();
    }
    if (this.fileContentBytes !== null && this.fileContentBytes !== undefined) {
      output.writeFieldBegin('fileContentBytes', Thrift.Type.STRING, 4);
      output.writeBinary(this.fileContentBytes);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_uploadDocumentAttachmentPortions_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new Attachment(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new Attachment();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_uploadDocumentAttachmentPortions_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_downloadDocumentAttachment_args = class {
  constructor(args) {
    this.token = null;
    this.attachmentId = null;
    this.attachmentType = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.attachmentId !== undefined && args.attachmentId !== null) {
        this.attachmentId = args.attachmentId;
      }
      if (args.attachmentType !== undefined && args.attachmentType !== null) {
        this.attachmentType = args.attachmentType;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.attachmentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I32) {
          this.attachmentType = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_downloadDocumentAttachment_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.attachmentId !== null && this.attachmentId !== undefined) {
      output.writeFieldBegin('attachmentId', Thrift.Type.STRING, 2);
      output.writeString(this.attachmentId);
      output.writeFieldEnd();
    }
    if (this.attachmentType !== null && this.attachmentType !== undefined) {
      output.writeFieldBegin('attachmentType', Thrift.Type.I32, 3);
      output.writeI32(this.attachmentType);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 4);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_downloadDocumentAttachment_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRING) {
          this.success = input.readBinary().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_downloadDocumentAttachment_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRING, 0);
      output.writeBinary(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_rotatePdfPages_args = class {
  constructor(args) {
    this.token = null;
    this.attachmentId = null;
    this.pages = null;
    this.angle = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.attachmentId !== undefined && args.attachmentId !== null) {
        this.attachmentId = args.attachmentId;
      }
      if (args.pages !== undefined && args.pages !== null) {
        this.pages = args.pages;
      }
      if (args.angle !== undefined && args.angle !== null) {
        this.angle = args.angle;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.attachmentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.pages = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I32) {
          this.angle = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_rotatePdfPages_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.attachmentId !== null && this.attachmentId !== undefined) {
      output.writeFieldBegin('attachmentId', Thrift.Type.STRING, 2);
      output.writeString(this.attachmentId);
      output.writeFieldEnd();
    }
    if (this.pages !== null && this.pages !== undefined) {
      output.writeFieldBegin('pages', Thrift.Type.STRING, 3);
      output.writeString(this.pages);
      output.writeFieldEnd();
    }
    if (this.angle !== null && this.angle !== undefined) {
      output.writeFieldBegin('angle', Thrift.Type.I32, 4);
      output.writeI32(this.angle);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 5);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_rotatePdfPages_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_rotatePdfPages_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_addAttachmentsToDocument_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.attachments = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.attachments !== undefined && args.attachments !== null) {
        this.attachments = Thrift.copyList(args.attachments, [AttCreateInfo]);
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.attachments = [];
          const _rtmp3423 = input.readListBegin();
          const _size422 = _rtmp3423.size || 0;
          for (let _i424 = 0; _i424 < _size422; ++_i424) {
            let elem425 = null;
            elem425 = new AttCreateInfo();
            elem425.read(input);
            this.attachments.push(elem425);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_addAttachmentsToDocument_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.attachments !== null && this.attachments !== undefined) {
      output.writeFieldBegin('attachments', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRUCT, this.attachments.length);
      for (let iter426 in this.attachments) {
        if (this.attachments.hasOwnProperty(iter426)) {
          iter426 = this.attachments[iter426];
          iter426.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 4);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_addAttachmentsToDocument_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_addAttachmentsToDocument_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_removeDocumentAttachment_args = class {
  constructor(args) {
    this.token = null;
    this.attachmentId = null;
    this.removeOldVersions = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.attachmentId !== undefined && args.attachmentId !== null) {
        this.attachmentId = args.attachmentId;
      }
      if (args.removeOldVersions !== undefined && args.removeOldVersions !== null) {
        this.removeOldVersions = args.removeOldVersions;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.attachmentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.BOOL) {
          this.removeOldVersions = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_removeDocumentAttachment_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.attachmentId !== null && this.attachmentId !== undefined) {
      output.writeFieldBegin('attachmentId', Thrift.Type.STRING, 2);
      output.writeString(this.attachmentId);
      output.writeFieldEnd();
    }
    if (this.removeOldVersions !== null && this.removeOldVersions !== undefined) {
      output.writeFieldBegin('removeOldVersions', Thrift.Type.BOOL, 3);
      output.writeBool(this.removeOldVersions);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 4);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_removeDocumentAttachment_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_removeDocumentAttachment_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_markAsWaitForPublish_args = class {
  constructor(args) {
    this.token = null;
    this.attachmentId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.attachmentId !== undefined && args.attachmentId !== null) {
        this.attachmentId = args.attachmentId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.attachmentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_markAsWaitForPublish_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.attachmentId !== null && this.attachmentId !== undefined) {
      output.writeFieldBegin('attachmentId', Thrift.Type.STRING, 2);
      output.writeString(this.attachmentId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_markAsWaitForPublish_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_markAsWaitForPublish_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_changeAttachmentEditMode_args = class {
  constructor(args) {
    this.token = null;
    this.attachmentId = null;
    this.editMode = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.attachmentId !== undefined && args.attachmentId !== null) {
        this.attachmentId = args.attachmentId;
      }
      if (args.editMode !== undefined && args.editMode !== null) {
        this.editMode = args.editMode;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.attachmentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I32) {
          this.editMode = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_changeAttachmentEditMode_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.attachmentId !== null && this.attachmentId !== undefined) {
      output.writeFieldBegin('attachmentId', Thrift.Type.STRING, 2);
      output.writeString(this.attachmentId);
      output.writeFieldEnd();
    }
    if (this.editMode !== null && this.editMode !== undefined) {
      output.writeFieldBegin('editMode', Thrift.Type.I32, 3);
      output.writeI32(this.editMode);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_changeAttachmentEditMode_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new Attachment(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new Attachment();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_changeAttachmentEditMode_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getDocumentAttachments_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.latestOnly = null;
    this.filter = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.latestOnly !== undefined && args.latestOnly !== null) {
        this.latestOnly = args.latestOnly;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.BOOL) {
          this.latestOnly = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getDocumentAttachments_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.latestOnly !== null && this.latestOnly !== undefined) {
      output.writeFieldBegin('latestOnly', Thrift.Type.BOOL, 3);
      output.writeBool(this.latestOnly);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 4);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 5);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getDocumentAttachments_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [Attachment]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3428 = input.readListBegin();
          const _size427 = _rtmp3428.size || 0;
          for (let _i429 = 0; _i429 < _size427; ++_i429) {
            let elem430 = null;
            elem430 = new Attachment();
            elem430.read(input);
            this.success.push(elem430);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getDocumentAttachments_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter431 in this.success) {
        if (this.success.hasOwnProperty(iter431)) {
          iter431 = this.success[iter431];
          iter431.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getDocumentAttachmentById_args = class {
  constructor(args) {
    this.token = null;
    this.attachmentId = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.attachmentId !== undefined && args.attachmentId !== null) {
        this.attachmentId = args.attachmentId;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.attachmentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getDocumentAttachmentById_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.attachmentId !== null && this.attachmentId !== undefined) {
      output.writeFieldBegin('attachmentId', Thrift.Type.STRING, 2);
      output.writeString(this.attachmentId);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 3);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getDocumentAttachmentById_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new Attachment(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new Attachment();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getDocumentAttachmentById_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getAllDocumentAttachmentVersions_args = class {
  constructor(args) {
    this.token = null;
    this.attachmentId = null;
    this.filter = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.attachmentId !== undefined && args.attachmentId !== null) {
        this.attachmentId = args.attachmentId;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.attachmentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getAllDocumentAttachmentVersions_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.attachmentId !== null && this.attachmentId !== undefined) {
      output.writeFieldBegin('attachmentId', Thrift.Type.STRING, 2);
      output.writeString(this.attachmentId);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 3);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 4);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getAllDocumentAttachmentVersions_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [Attachment]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3433 = input.readListBegin();
          const _size432 = _rtmp3433.size || 0;
          for (let _i434 = 0; _i434 < _size432; ++_i434) {
            let elem435 = null;
            elem435 = new Attachment();
            elem435.read(input);
            this.success.push(elem435);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getAllDocumentAttachmentVersions_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter436 in this.success) {
        if (this.success.hasOwnProperty(iter436)) {
          iter436 = this.success[iter436];
          iter436.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_changeAttachmentsVisibility_args = class {
  constructor(args) {
    this.token = null;
    this.toHideList = null;
    this.toShowList = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.toHideList !== undefined && args.toHideList !== null) {
        this.toHideList = Thrift.copyList(args.toHideList, [null]);
      }
      if (args.toShowList !== undefined && args.toShowList !== null) {
        this.toShowList = Thrift.copyList(args.toShowList, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.LIST) {
          this.toHideList = [];
          const _rtmp3438 = input.readListBegin();
          const _size437 = _rtmp3438.size || 0;
          for (let _i439 = 0; _i439 < _size437; ++_i439) {
            let elem440 = null;
            elem440 = input.readString().value;
            this.toHideList.push(elem440);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.toShowList = [];
          const _rtmp3442 = input.readListBegin();
          const _size441 = _rtmp3442.size || 0;
          for (let _i443 = 0; _i443 < _size441; ++_i443) {
            let elem444 = null;
            elem444 = input.readString().value;
            this.toShowList.push(elem444);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_changeAttachmentsVisibility_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.toHideList !== null && this.toHideList !== undefined) {
      output.writeFieldBegin('toHideList', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.STRING, this.toHideList.length);
      for (let iter445 in this.toHideList) {
        if (this.toHideList.hasOwnProperty(iter445)) {
          iter445 = this.toHideList[iter445];
          output.writeString(iter445);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.toShowList !== null && this.toShowList !== undefined) {
      output.writeFieldBegin('toShowList', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRING, this.toShowList.length);
      for (let iter446 in this.toShowList) {
        if (this.toShowList.hasOwnProperty(iter446)) {
          iter446 = this.toShowList[iter446];
          output.writeString(iter446);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_changeAttachmentsVisibility_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_changeAttachmentsVisibility_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_createOrUpdateDocumentComment_args = class {
  constructor(args) {
    this.token = null;
    this.documentComment = null;
    this.addToComment = null;
    this.changeType = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentComment !== undefined && args.documentComment !== null) {
        this.documentComment = new DocumentComment(args.documentComment);
      }
      if (args.addToComment !== undefined && args.addToComment !== null) {
        this.addToComment = args.addToComment;
      }
      if (args.changeType !== undefined && args.changeType !== null) {
        this.changeType = args.changeType;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.documentComment = new DocumentComment();
          this.documentComment.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.addToComment = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I32) {
          this.changeType = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_createOrUpdateDocumentComment_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentComment !== null && this.documentComment !== undefined) {
      output.writeFieldBegin('documentComment', Thrift.Type.STRUCT, 2);
      this.documentComment.write(output);
      output.writeFieldEnd();
    }
    if (this.addToComment !== null && this.addToComment !== undefined) {
      output.writeFieldBegin('addToComment', Thrift.Type.STRING, 3);
      output.writeString(this.addToComment);
      output.writeFieldEnd();
    }
    if (this.changeType !== null && this.changeType !== undefined) {
      output.writeFieldBegin('changeType', Thrift.Type.I32, 4);
      output.writeI32(this.changeType);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 5);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_createOrUpdateDocumentComment_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new DocumentComment(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new DocumentComment();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_createOrUpdateDocumentComment_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getAllDocumentComments_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.filter = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getAllDocumentComments_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 3);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 4);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getAllDocumentComments_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [DocumentComment]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3448 = input.readListBegin();
          const _size447 = _rtmp3448.size || 0;
          for (let _i449 = 0; _i449 < _size447; ++_i449) {
            let elem450 = null;
            elem450 = new DocumentComment();
            elem450.read(input);
            this.success.push(elem450);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getAllDocumentComments_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter451 in this.success) {
        if (this.success.hasOwnProperty(iter451)) {
          iter451 = this.success[iter451];
          iter451.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_deleteDocumentComment_args = class {
  constructor(args) {
    this.token = null;
    this.documentCommentId = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentCommentId !== undefined && args.documentCommentId !== null) {
        this.documentCommentId = args.documentCommentId;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentCommentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_deleteDocumentComment_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentCommentId !== null && this.documentCommentId !== undefined) {
      output.writeFieldBegin('documentCommentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentCommentId);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 3);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_deleteDocumentComment_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_deleteDocumentComment_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_createOrUpdateDocumentContentHolderLink_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.holderLinks = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.holderLinks !== undefined && args.holderLinks !== null) {
        this.holderLinks = Thrift.copyList(args.holderLinks, [ContentHolderLink]);
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.holderLinks = [];
          const _rtmp3453 = input.readListBegin();
          const _size452 = _rtmp3453.size || 0;
          for (let _i454 = 0; _i454 < _size452; ++_i454) {
            let elem455 = null;
            elem455 = new ContentHolderLink();
            elem455.read(input);
            this.holderLinks.push(elem455);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_createOrUpdateDocumentContentHolderLink_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.holderLinks !== null && this.holderLinks !== undefined) {
      output.writeFieldBegin('holderLinks', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRUCT, this.holderLinks.length);
      for (let iter456 in this.holderLinks) {
        if (this.holderLinks.hasOwnProperty(iter456)) {
          iter456 = this.holderLinks[iter456];
          iter456.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 4);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_createOrUpdateDocumentContentHolderLink_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [ContentHolderShowPlace]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3458 = input.readListBegin();
          const _size457 = _rtmp3458.size || 0;
          for (let _i459 = 0; _i459 < _size457; ++_i459) {
            let elem460 = null;
            elem460 = new ContentHolderShowPlace();
            elem460.read(input);
            this.success.push(elem460);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_createOrUpdateDocumentContentHolderLink_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter461 in this.success) {
        if (this.success.hasOwnProperty(iter461)) {
          iter461 = this.success[iter461];
          iter461.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_createOrUpdateDocumentContentTab_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.documentContentTab = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.documentContentTab !== undefined && args.documentContentTab !== null) {
        this.documentContentTab = new ContentTab(args.documentContentTab);
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.documentContentTab = new ContentTab();
          this.documentContentTab.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_createOrUpdateDocumentContentTab_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.documentContentTab !== null && this.documentContentTab !== undefined) {
      output.writeFieldBegin('documentContentTab', Thrift.Type.STRUCT, 3);
      this.documentContentTab.write(output);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 4);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_createOrUpdateDocumentContentTab_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ContentTab(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ContentTab();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_createOrUpdateDocumentContentTab_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getDocumentContentTabsByFilter_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.filter = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getDocumentContentTabsByFilter_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 3);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 4);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getDocumentContentTabsByFilter_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [ContentTab]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3463 = input.readListBegin();
          const _size462 = _rtmp3463.size || 0;
          for (let _i464 = 0; _i464 < _size462; ++_i464) {
            let elem465 = null;
            elem465 = new ContentTab();
            elem465.read(input);
            this.success.push(elem465);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getDocumentContentTabsByFilter_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter466 in this.success) {
        if (this.success.hasOwnProperty(iter466)) {
          iter466 = this.success[iter466];
          iter466.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_deleteDocumentContentTab_args = class {
  constructor(args) {
    this.token = null;
    this.documentContentTabId = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentContentTabId !== undefined && args.documentContentTabId !== null) {
        this.documentContentTabId = args.documentContentTabId;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentContentTabId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_deleteDocumentContentTab_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentContentTabId !== null && this.documentContentTabId !== undefined) {
      output.writeFieldBegin('documentContentTabId', Thrift.Type.STRING, 2);
      output.writeString(this.documentContentTabId);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 3);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_deleteDocumentContentTab_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_deleteDocumentContentTab_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_documentToArchive_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_documentToArchive_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 3);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_documentToArchive_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_documentToArchive_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getAllResponsibleForDocument_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.accessPolicy = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getAllResponsibleForDocument_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 3);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 4);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getAllResponsibleForDocument_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [UserOrGroup]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.SET) {
          this.success = [];
          const _rtmp3468 = input.readSetBegin();
          const _size467 = _rtmp3468.size || 0;
          for (let _i469 = 0; _i469 < _size467; ++_i469) {
            let elem470 = null;
            elem470 = new UserOrGroup();
            elem470.read(input);
            this.success.push(elem470);
          }
          input.readSetEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getAllResponsibleForDocument_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.SET, 0);
      output.writeSetBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter471 in this.success) {
        if (this.success.hasOwnProperty(iter471)) {
          iter471 = this.success[iter471];
          iter471.write(output);
        }
      }
      output.writeSetEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_addResponsibleForDocument_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.users = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.users !== undefined && args.users !== null) {
        this.users = Thrift.copyList(args.users, [UserOrGroup]);
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.users = [];
          const _rtmp3473 = input.readListBegin();
          const _size472 = _rtmp3473.size || 0;
          for (let _i474 = 0; _i474 < _size472; ++_i474) {
            let elem475 = null;
            elem475 = new UserOrGroup();
            elem475.read(input);
            this.users.push(elem475);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_addResponsibleForDocument_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.users !== null && this.users !== undefined) {
      output.writeFieldBegin('users', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRUCT, this.users.length);
      for (let iter476 in this.users) {
        if (this.users.hasOwnProperty(iter476)) {
          iter476 = this.users[iter476];
          iter476.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 4);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_addResponsibleForDocument_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_addResponsibleForDocument_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_removeResponsibleForDocument_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.users = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.users !== undefined && args.users !== null) {
        this.users = Thrift.copyList(args.users, [UserOrGroup]);
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.users = [];
          const _rtmp3478 = input.readListBegin();
          const _size477 = _rtmp3478.size || 0;
          for (let _i479 = 0; _i479 < _size477; ++_i479) {
            let elem480 = null;
            elem480 = new UserOrGroup();
            elem480.read(input);
            this.users.push(elem480);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_removeResponsibleForDocument_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.users !== null && this.users !== undefined) {
      output.writeFieldBegin('users', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRUCT, this.users.length);
      for (let iter481 in this.users) {
        if (this.users.hasOwnProperty(iter481)) {
          iter481 = this.users[iter481];
          iter481.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 4);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_removeResponsibleForDocument_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_removeResponsibleForDocument_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getDocHistoryPage_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.accessPolicy = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getDocHistoryPage_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 3);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 4);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getDocHistoryPage_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new HistoryPage(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new HistoryPage();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getDocHistoryPage_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getAllNews_args = class {
  constructor(args) {
    this.token = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getAllNews_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 2);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getAllNews_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [News]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3483 = input.readListBegin();
          const _size482 = _rtmp3483.size || 0;
          for (let _i484 = 0; _i484 < _size482; ++_i484) {
            let elem485 = null;
            elem485 = new News();
            elem485.read(input);
            this.success.push(elem485);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getAllNews_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter486 in this.success) {
        if (this.success.hasOwnProperty(iter486)) {
          iter486 = this.success[iter486];
          iter486.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getTasksByDate_args = class {
  constructor(args) {
    this.token = null;
    this.date = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.date !== undefined && args.date !== null) {
        this.date = args.date;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I64) {
          this.date = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getTasksByDate_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.date !== null && this.date !== undefined) {
      output.writeFieldBegin('date', Thrift.Type.I64, 2);
      output.writeI64(this.date);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getTasksByDate_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyMap(args.success, [null]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.MAP) {
          this.success = {};
          const _rtmp3488 = input.readMapBegin();
          const _size487 = _rtmp3488.size || 0;
          for (let _i489 = 0; _i489 < _size487; ++_i489) {
            if (_i489 > 0 ) {
              if (input.rstack.length > input.rpos[input.rpos.length -1] + 1) {
                input.rstack.pop();
              }
            }
            let key490 = null;
            let val491 = null;
            key490 = input.readI32().value;
            val491 = input.readI32().value;
            this.success[key490] = val491;
          }
          input.readMapEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getTasksByDate_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.MAP, 0);
      output.writeMapBegin(Thrift.Type.I32, Thrift.Type.I32, Thrift.objectLength(this.success));
      for (let kiter492 in this.success) {
        if (this.success.hasOwnProperty(kiter492)) {
          let viter493 = this.success[kiter492];
          output.writeI32(kiter492);
          output.writeI32(viter493);
        }
      }
      output.writeMapEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_generateDocumentNumber_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.docNumber = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.docNumber !== undefined && args.docNumber !== null) {
        this.docNumber = args.docNumber;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.docNumber = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_generateDocumentNumber_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.docNumber !== null && this.docNumber !== undefined) {
      output.writeFieldBegin('docNumber', Thrift.Type.STRING, 3);
      output.writeString(this.docNumber);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 4);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_generateDocumentNumber_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRING) {
          this.success = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_generateDocumentNumber_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRING, 0);
      output.writeString(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_setDocumentViewed_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.viewed = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.viewed !== undefined && args.viewed !== null) {
        this.viewed = args.viewed;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.BOOL) {
          this.viewed = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_setDocumentViewed_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.viewed !== null && this.viewed !== undefined) {
      output.writeFieldBegin('viewed', Thrift.Type.BOOL, 3);
      output.writeBool(this.viewed);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 4);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_setDocumentViewed_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_setDocumentViewed_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getAllDocumentRelations_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.filter = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getAllDocumentRelations_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 3);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 4);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getAllDocumentRelations_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [DocumentRelation]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3495 = input.readListBegin();
          const _size494 = _rtmp3495.size || 0;
          for (let _i496 = 0; _i496 < _size494; ++_i496) {
            let elem497 = null;
            elem497 = new DocumentRelation();
            elem497.read(input);
            this.success.push(elem497);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getAllDocumentRelations_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter498 in this.success) {
        if (this.success.hasOwnProperty(iter498)) {
          iter498 = this.success[iter498];
          iter498.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_changeRelations_args = class {
  constructor(args) {
    this.token = null;
    this.toCreate = null;
    this.toRemove = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.toCreate !== undefined && args.toCreate !== null) {
        this.toCreate = Thrift.copyList(args.toCreate, [DocumentRelation]);
      }
      if (args.toRemove !== undefined && args.toRemove !== null) {
        this.toRemove = Thrift.copyList(args.toRemove, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.LIST) {
          this.toCreate = [];
          const _rtmp3500 = input.readListBegin();
          const _size499 = _rtmp3500.size || 0;
          for (let _i501 = 0; _i501 < _size499; ++_i501) {
            let elem502 = null;
            elem502 = new DocumentRelation();
            elem502.read(input);
            this.toCreate.push(elem502);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.toRemove = [];
          const _rtmp3504 = input.readListBegin();
          const _size503 = _rtmp3504.size || 0;
          for (let _i505 = 0; _i505 < _size503; ++_i505) {
            let elem506 = null;
            elem506 = input.readString().value;
            this.toRemove.push(elem506);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_changeRelations_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.toCreate !== null && this.toCreate !== undefined) {
      output.writeFieldBegin('toCreate', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.STRUCT, this.toCreate.length);
      for (let iter507 in this.toCreate) {
        if (this.toCreate.hasOwnProperty(iter507)) {
          iter507 = this.toCreate[iter507];
          iter507.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.toRemove !== null && this.toRemove !== undefined) {
      output.writeFieldBegin('toRemove', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRING, this.toRemove.length);
      for (let iter508 in this.toRemove) {
        if (this.toRemove.hasOwnProperty(iter508)) {
          iter508 = this.toRemove[iter508];
          output.writeString(iter508);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_changeRelations_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [DocumentRelation]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3510 = input.readListBegin();
          const _size509 = _rtmp3510.size || 0;
          for (let _i511 = 0; _i511 < _size509; ++_i511) {
            let elem512 = null;
            elem512 = new DocumentRelation();
            elem512.read(input);
            this.success.push(elem512);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_changeRelations_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter513 in this.success) {
        if (this.success.hasOwnProperty(iter513)) {
          iter513 = this.success[iter513];
          iter513.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_changeSubStatus_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.subStatus = null;
    this.comment = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.subStatus !== undefined && args.subStatus !== null) {
        this.subStatus = args.subStatus;
      }
      if (args.comment !== undefined && args.comment !== null) {
        this.comment = args.comment;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I32) {
          this.subStatus = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.comment = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_changeSubStatus_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.subStatus !== null && this.subStatus !== undefined) {
      output.writeFieldBegin('subStatus', Thrift.Type.I32, 3);
      output.writeI32(this.subStatus);
      output.writeFieldEnd();
    }
    if (this.comment !== null && this.comment !== undefined) {
      output.writeFieldBegin('comment', Thrift.Type.STRING, 4);
      output.writeString(this.comment);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 5);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_changeSubStatus_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_changeSubStatus_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_increaseDeadlineForDocumentOrDocumentExecution_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.documentExecution = null;
    this.deadlineTime = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.documentExecution !== undefined && args.documentExecution !== null) {
        this.documentExecution = args.documentExecution;
      }
      if (args.deadlineTime !== undefined && args.deadlineTime !== null) {
        this.deadlineTime = args.deadlineTime;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.documentExecution = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I64) {
          this.deadlineTime = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_increaseDeadlineForDocumentOrDocumentExecution_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.documentExecution !== null && this.documentExecution !== undefined) {
      output.writeFieldBegin('documentExecution', Thrift.Type.STRING, 3);
      output.writeString(this.documentExecution);
      output.writeFieldEnd();
    }
    if (this.deadlineTime !== null && this.deadlineTime !== undefined) {
      output.writeFieldBegin('deadlineTime', Thrift.Type.I64, 4);
      output.writeI64(this.deadlineTime);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 5);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_increaseDeadlineForDocumentOrDocumentExecution_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_increaseDeadlineForDocumentOrDocumentExecution_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_addAdditionalConfirmers_args = class {
  constructor(args) {
    this.token = null;
    this.cardId = null;
    this.users = null;
    this.deadlineDate = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.cardId !== undefined && args.cardId !== null) {
        this.cardId = args.cardId;
      }
      if (args.users !== undefined && args.users !== null) {
        this.users = Thrift.copyList(args.users, [null]);
      }
      if (args.deadlineDate !== undefined && args.deadlineDate !== null) {
        this.deadlineDate = args.deadlineDate;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.cardId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.users = [];
          const _rtmp3515 = input.readListBegin();
          const _size514 = _rtmp3515.size || 0;
          for (let _i516 = 0; _i516 < _size514; ++_i516) {
            let elem517 = null;
            elem517 = input.readString().value;
            this.users.push(elem517);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I64) {
          this.deadlineDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_addAdditionalConfirmers_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.cardId !== null && this.cardId !== undefined) {
      output.writeFieldBegin('cardId', Thrift.Type.STRING, 2);
      output.writeString(this.cardId);
      output.writeFieldEnd();
    }
    if (this.users !== null && this.users !== undefined) {
      output.writeFieldBegin('users', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRING, this.users.length);
      for (let iter518 in this.users) {
        if (this.users.hasOwnProperty(iter518)) {
          iter518 = this.users[iter518];
          output.writeString(iter518);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.deadlineDate !== null && this.deadlineDate !== undefined) {
      output.writeFieldBegin('deadlineDate', Thrift.Type.I64, 4);
      output.writeI64(this.deadlineDate);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 5);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_addAdditionalConfirmers_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_addAdditionalConfirmers_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_setAdditionalDecision_args = class {
  constructor(args) {
    this.token = null;
    this.userDecision = null;
    this.cardId = null;
    this.comment = null;
    this.returnToParentStage = null;
    this.signature = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.userDecision !== undefined && args.userDecision !== null) {
        this.userDecision = Thrift.copyMap(args.userDecision, [null]);
      }
      if (args.cardId !== undefined && args.cardId !== null) {
        this.cardId = args.cardId;
      }
      if (args.comment !== undefined && args.comment !== null) {
        this.comment = args.comment;
      }
      if (args.returnToParentStage !== undefined && args.returnToParentStage !== null) {
        this.returnToParentStage = args.returnToParentStage;
      }
      if (args.signature !== undefined && args.signature !== null) {
        this.signature = args.signature;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.MAP) {
          this.userDecision = {};
          const _rtmp3520 = input.readMapBegin();
          const _size519 = _rtmp3520.size || 0;
          for (let _i521 = 0; _i521 < _size519; ++_i521) {
            if (_i521 > 0 ) {
              if (input.rstack.length > input.rpos[input.rpos.length -1] + 1) {
                input.rstack.pop();
              }
            }
            let key522 = null;
            let val523 = null;
            key522 = input.readString().value;
            val523 = input.readString().value;
            this.userDecision[key522] = val523;
          }
          input.readMapEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.cardId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.comment = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.BOOL) {
          this.returnToParentStage = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.STRING) {
          this.signature = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_setAdditionalDecision_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.userDecision !== null && this.userDecision !== undefined) {
      output.writeFieldBegin('userDecision', Thrift.Type.MAP, 2);
      output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.STRING, Thrift.objectLength(this.userDecision));
      for (let kiter524 in this.userDecision) {
        if (this.userDecision.hasOwnProperty(kiter524)) {
          let viter525 = this.userDecision[kiter524];
          output.writeString(kiter524);
          output.writeString(viter525);
        }
      }
      output.writeMapEnd();
      output.writeFieldEnd();
    }
    if (this.cardId !== null && this.cardId !== undefined) {
      output.writeFieldBegin('cardId', Thrift.Type.STRING, 3);
      output.writeString(this.cardId);
      output.writeFieldEnd();
    }
    if (this.comment !== null && this.comment !== undefined) {
      output.writeFieldBegin('comment', Thrift.Type.STRING, 4);
      output.writeString(this.comment);
      output.writeFieldEnd();
    }
    if (this.returnToParentStage !== null && this.returnToParentStage !== undefined) {
      output.writeFieldBegin('returnToParentStage', Thrift.Type.BOOL, 5);
      output.writeBool(this.returnToParentStage);
      output.writeFieldEnd();
    }
    if (this.signature !== null && this.signature !== undefined) {
      output.writeFieldBegin('signature', Thrift.Type.STRING, 6);
      output.writeString(this.signature);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_setAdditionalDecision_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new Document(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new Document();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_setAdditionalDecision_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_revokeDecision_args = class {
  constructor(args) {
    this.token = null;
    this.documentReassign = null;
    this.cardId = null;
    this.comment = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentReassign !== undefined && args.documentReassign !== null) {
        this.documentReassign = Thrift.copyList(args.documentReassign, [DocumentReassign]);
      }
      if (args.cardId !== undefined && args.cardId !== null) {
        this.cardId = args.cardId;
      }
      if (args.comment !== undefined && args.comment !== null) {
        this.comment = args.comment;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.LIST) {
          this.documentReassign = [];
          const _rtmp3527 = input.readListBegin();
          const _size526 = _rtmp3527.size || 0;
          for (let _i528 = 0; _i528 < _size526; ++_i528) {
            let elem529 = null;
            elem529 = new DocumentReassign();
            elem529.read(input);
            this.documentReassign.push(elem529);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.cardId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.comment = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_revokeDecision_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentReassign !== null && this.documentReassign !== undefined) {
      output.writeFieldBegin('documentReassign', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.STRUCT, this.documentReassign.length);
      for (let iter530 in this.documentReassign) {
        if (this.documentReassign.hasOwnProperty(iter530)) {
          iter530 = this.documentReassign[iter530];
          iter530.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.cardId !== null && this.cardId !== undefined) {
      output.writeFieldBegin('cardId', Thrift.Type.STRING, 3);
      output.writeString(this.cardId);
      output.writeFieldEnd();
    }
    if (this.comment !== null && this.comment !== undefined) {
      output.writeFieldBegin('comment', Thrift.Type.STRING, 4);
      output.writeString(this.comment);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_revokeDecision_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new Document(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new Document();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_revokeDecision_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_markDecisionAsRemoved_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.cardId = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.cardId !== undefined && args.cardId !== null) {
        this.cardId = args.cardId;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.cardId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_markDecisionAsRemoved_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.cardId !== null && this.cardId !== undefined) {
      output.writeFieldBegin('cardId', Thrift.Type.STRING, 3);
      output.writeString(this.cardId);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 4);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_markDecisionAsRemoved_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new DocumentExecution(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new DocumentExecution();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_markDecisionAsRemoved_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getAllOpenDocumentExecutionsStatistic_args = class {
  constructor(args) {
    this.token = null;
    this.userId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.userId !== undefined && args.userId !== null) {
        this.userId = args.userId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.userId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getAllOpenDocumentExecutionsStatistic_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.userId !== null && this.userId !== undefined) {
      output.writeFieldBegin('userId', Thrift.Type.STRING, 2);
      output.writeString(this.userId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getAllOpenDocumentExecutionsStatistic_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyMap(args.success, [null]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.MAP) {
          this.success = {};
          const _rtmp3532 = input.readMapBegin();
          const _size531 = _rtmp3532.size || 0;
          for (let _i533 = 0; _i533 < _size531; ++_i533) {
            if (_i533 > 0 ) {
              if (input.rstack.length > input.rpos[input.rpos.length -1] + 1) {
                input.rstack.pop();
              }
            }
            let key534 = null;
            let val535 = null;
            key534 = input.readI32().value;
            val535 = input.readI32().value;
            this.success[key534] = val535;
          }
          input.readMapEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getAllOpenDocumentExecutionsStatistic_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.MAP, 0);
      output.writeMapBegin(Thrift.Type.I32, Thrift.Type.I32, Thrift.objectLength(this.success));
      for (let kiter536 in this.success) {
        if (this.success.hasOwnProperty(kiter536)) {
          let viter537 = this.success[kiter536];
          output.writeI32(kiter536);
          output.writeI32(viter537);
        }
      }
      output.writeMapEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_changeControlForDocument_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.control = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.control !== undefined && args.control !== null) {
        this.control = args.control;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.BOOL) {
          this.control = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_changeControlForDocument_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.control !== null && this.control !== undefined) {
      output.writeFieldBegin('control', Thrift.Type.BOOL, 3);
      output.writeBool(this.control);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 4);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_changeControlForDocument_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_changeControlForDocument_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_addTagsToDocument_args = class {
  constructor(args) {
    this.token = null;
    this.docId = null;
    this.tags = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.docId !== undefined && args.docId !== null) {
        this.docId = args.docId;
      }
      if (args.tags !== undefined && args.tags !== null) {
        this.tags = Thrift.copyList(args.tags, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.docId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.SET) {
          this.tags = [];
          const _rtmp3539 = input.readSetBegin();
          const _size538 = _rtmp3539.size || 0;
          for (let _i540 = 0; _i540 < _size538; ++_i540) {
            let elem541 = null;
            elem541 = input.readString().value;
            this.tags.push(elem541);
          }
          input.readSetEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_addTagsToDocument_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.docId !== null && this.docId !== undefined) {
      output.writeFieldBegin('docId', Thrift.Type.STRING, 2);
      output.writeString(this.docId);
      output.writeFieldEnd();
    }
    if (this.tags !== null && this.tags !== undefined) {
      output.writeFieldBegin('tags', Thrift.Type.SET, 3);
      output.writeSetBegin(Thrift.Type.STRING, this.tags.length);
      for (let iter542 in this.tags) {
        if (this.tags.hasOwnProperty(iter542)) {
          iter542 = this.tags[iter542];
          output.writeString(iter542);
        }
      }
      output.writeSetEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_addTagsToDocument_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_addTagsToDocument_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_removeTagsToDocument_args = class {
  constructor(args) {
    this.token = null;
    this.docId = null;
    this.tags = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.docId !== undefined && args.docId !== null) {
        this.docId = args.docId;
      }
      if (args.tags !== undefined && args.tags !== null) {
        this.tags = Thrift.copyList(args.tags, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.docId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.SET) {
          this.tags = [];
          const _rtmp3544 = input.readSetBegin();
          const _size543 = _rtmp3544.size || 0;
          for (let _i545 = 0; _i545 < _size543; ++_i545) {
            let elem546 = null;
            elem546 = input.readString().value;
            this.tags.push(elem546);
          }
          input.readSetEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_removeTagsToDocument_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.docId !== null && this.docId !== undefined) {
      output.writeFieldBegin('docId', Thrift.Type.STRING, 2);
      output.writeString(this.docId);
      output.writeFieldEnd();
    }
    if (this.tags !== null && this.tags !== undefined) {
      output.writeFieldBegin('tags', Thrift.Type.SET, 3);
      output.writeSetBegin(Thrift.Type.STRING, this.tags.length);
      for (let iter547 in this.tags) {
        if (this.tags.hasOwnProperty(iter547)) {
          iter547 = this.tags[iter547];
          output.writeString(iter547);
        }
      }
      output.writeSetEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_removeTagsToDocument_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_removeTagsToDocument_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_addExecutorsToStage_args = class {
  constructor(args) {
    this.token = null;
    this.docId = null;
    this.documentReassign = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.docId !== undefined && args.docId !== null) {
        this.docId = args.docId;
      }
      if (args.documentReassign !== undefined && args.documentReassign !== null) {
        this.documentReassign = Thrift.copyList(args.documentReassign, [DocumentReassign]);
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.docId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.documentReassign = [];
          const _rtmp3549 = input.readListBegin();
          const _size548 = _rtmp3549.size || 0;
          for (let _i550 = 0; _i550 < _size548; ++_i550) {
            let elem551 = null;
            elem551 = new DocumentReassign();
            elem551.read(input);
            this.documentReassign.push(elem551);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_addExecutorsToStage_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.docId !== null && this.docId !== undefined) {
      output.writeFieldBegin('docId', Thrift.Type.STRING, 2);
      output.writeString(this.docId);
      output.writeFieldEnd();
    }
    if (this.documentReassign !== null && this.documentReassign !== undefined) {
      output.writeFieldBegin('documentReassign', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRUCT, this.documentReassign.length);
      for (let iter552 in this.documentReassign) {
        if (this.documentReassign.hasOwnProperty(iter552)) {
          iter552 = this.documentReassign[iter552];
          iter552.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 4);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_addExecutorsToStage_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [DocumentExecution]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3554 = input.readListBegin();
          const _size553 = _rtmp3554.size || 0;
          for (let _i555 = 0; _i555 < _size553; ++_i555) {
            let elem556 = null;
            elem556 = new DocumentExecution();
            elem556.read(input);
            this.success.push(elem556);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_addExecutorsToStage_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter557 in this.success) {
        if (this.success.hasOwnProperty(iter557)) {
          iter557 = this.success[iter557];
          iter557.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getCountDocsByFilterNoPermission_args = class {
  constructor(args) {
    this.token = null;
    this.patternGroupId = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.patternGroupId !== undefined && args.patternGroupId !== null) {
        this.patternGroupId = args.patternGroupId;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.patternGroupId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getCountDocsByFilterNoPermission_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.patternGroupId !== null && this.patternGroupId !== undefined) {
      output.writeFieldBegin('patternGroupId', Thrift.Type.STRING, 2);
      output.writeString(this.patternGroupId);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 3);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getCountDocsByFilterNoPermission_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.I64) {
          this.success = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getCountDocsByFilterNoPermission_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.I64, 0);
      output.writeI64(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getTinyDocsByFilterNoPermission_args = class {
  constructor(args) {
    this.token = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getTinyDocsByFilterNoPermission_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 2);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getTinyDocsByFilterNoPermission_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [Document]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3559 = input.readListBegin();
          const _size558 = _rtmp3559.size || 0;
          for (let _i560 = 0; _i560 < _size558; ++_i560) {
            let elem561 = null;
            elem561 = new Document();
            elem561.read(input);
            this.success.push(elem561);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getTinyDocsByFilterNoPermission_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter562 in this.success) {
        if (this.success.hasOwnProperty(iter562)) {
          iter562 = this.success[iter562];
          iter562.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_changeRegistrationInfoForDocument_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.newRegistrationDate = null;
    this.newRegistrationNumber = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.newRegistrationDate !== undefined && args.newRegistrationDate !== null) {
        this.newRegistrationDate = args.newRegistrationDate;
      }
      if (args.newRegistrationNumber !== undefined && args.newRegistrationNumber !== null) {
        this.newRegistrationNumber = args.newRegistrationNumber;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I64) {
          this.newRegistrationDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.newRegistrationNumber = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_changeRegistrationInfoForDocument_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.newRegistrationDate !== null && this.newRegistrationDate !== undefined) {
      output.writeFieldBegin('newRegistrationDate', Thrift.Type.I64, 3);
      output.writeI64(this.newRegistrationDate);
      output.writeFieldEnd();
    }
    if (this.newRegistrationNumber !== null && this.newRegistrationNumber !== undefined) {
      output.writeFieldBegin('newRegistrationNumber', Thrift.Type.STRING, 4);
      output.writeString(this.newRegistrationNumber);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 5);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_changeRegistrationInfoForDocument_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_changeRegistrationInfoForDocument_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_createChatForDocument_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_createChatForDocument_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_createChatForDocument_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRING) {
          this.success = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_createChatForDocument_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRING, 0);
      output.writeString(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getDocumentExtShareList_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.accessPolicy = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getDocumentExtShareList_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 3);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 4);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getDocumentExtShareList_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [DocumentExtShare]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3564 = input.readListBegin();
          const _size563 = _rtmp3564.size || 0;
          for (let _i565 = 0; _i565 < _size563; ++_i565) {
            let elem566 = null;
            elem566 = new DocumentExtShare();
            elem566.read(input);
            this.success.push(elem566);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getDocumentExtShareList_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter567 in this.success) {
        if (this.success.hasOwnProperty(iter567)) {
          iter567 = this.success[iter567];
          iter567.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_changeDocumentExtShare_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.accessPolicy = null;
    this.toAdd = null;
    this.toRemove = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
      if (args.toAdd !== undefined && args.toAdd !== null) {
        this.toAdd = Thrift.copyList(args.toAdd, [DocumentExtShare]);
      }
      if (args.toRemove !== undefined && args.toRemove !== null) {
        this.toRemove = Thrift.copyList(args.toRemove, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.LIST) {
          this.toAdd = [];
          const _rtmp3569 = input.readListBegin();
          const _size568 = _rtmp3569.size || 0;
          for (let _i570 = 0; _i570 < _size568; ++_i570) {
            let elem571 = null;
            elem571 = new DocumentExtShare();
            elem571.read(input);
            this.toAdd.push(elem571);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.LIST) {
          this.toRemove = [];
          const _rtmp3573 = input.readListBegin();
          const _size572 = _rtmp3573.size || 0;
          for (let _i574 = 0; _i574 < _size572; ++_i574) {
            let elem575 = null;
            elem575 = input.readString().value;
            this.toRemove.push(elem575);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_changeDocumentExtShare_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 3);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    if (this.toAdd !== null && this.toAdd !== undefined) {
      output.writeFieldBegin('toAdd', Thrift.Type.LIST, 4);
      output.writeListBegin(Thrift.Type.STRUCT, this.toAdd.length);
      for (let iter576 in this.toAdd) {
        if (this.toAdd.hasOwnProperty(iter576)) {
          iter576 = this.toAdd[iter576];
          iter576.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.toRemove !== null && this.toRemove !== undefined) {
      output.writeFieldBegin('toRemove', Thrift.Type.LIST, 5);
      output.writeListBegin(Thrift.Type.STRING, this.toRemove.length);
      for (let iter577 in this.toRemove) {
        if (this.toRemove.hasOwnProperty(iter577)) {
          iter577 = this.toRemove[iter577];
          output.writeString(iter577);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_changeDocumentExtShare_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [DocumentExtShare]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3579 = input.readListBegin();
          const _size578 = _rtmp3579.size || 0;
          for (let _i580 = 0; _i580 < _size578; ++_i580) {
            let elem581 = null;
            elem581 = new DocumentExtShare();
            elem581.read(input);
            this.success.push(elem581);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_changeDocumentExtShare_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter582 in this.success) {
        if (this.success.hasOwnProperty(iter582)) {
          iter582 = this.success[iter582];
          iter582.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_changeAttachmentExtStatus_args = class {
  constructor(args) {
    this.token = null;
    this.statusMap = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.statusMap !== undefined && args.statusMap !== null) {
        this.statusMap = Thrift.copyMap(args.statusMap, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.MAP) {
          this.statusMap = {};
          const _rtmp3584 = input.readMapBegin();
          const _size583 = _rtmp3584.size || 0;
          for (let _i585 = 0; _i585 < _size583; ++_i585) {
            if (_i585 > 0 ) {
              if (input.rstack.length > input.rpos[input.rpos.length -1] + 1) {
                input.rstack.pop();
              }
            }
            let key586 = null;
            let val587 = null;
            key586 = input.readString().value;
            val587 = input.readI32().value;
            this.statusMap[key586] = val587;
          }
          input.readMapEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_changeAttachmentExtStatus_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.statusMap !== null && this.statusMap !== undefined) {
      output.writeFieldBegin('statusMap', Thrift.Type.MAP, 2);
      output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.I32, Thrift.objectLength(this.statusMap));
      for (let kiter588 in this.statusMap) {
        if (this.statusMap.hasOwnProperty(kiter588)) {
          let viter589 = this.statusMap[kiter588];
          output.writeString(kiter588);
          output.writeI32(viter589);
        }
      }
      output.writeMapEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_changeAttachmentExtStatus_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_changeAttachmentExtStatus_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_remindDocumentExecutor_args = class {
  constructor(args) {
    this.token = null;
    this.cardId = null;
    this.comment = null;
    this.policy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.cardId !== undefined && args.cardId !== null) {
        this.cardId = args.cardId;
      }
      if (args.comment !== undefined && args.comment !== null) {
        this.comment = args.comment;
      }
      if (args.policy !== undefined && args.policy !== null) {
        this.policy = new DocumentAccessPolicy(args.policy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.cardId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.comment = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.policy = new DocumentAccessPolicy();
          this.policy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_remindDocumentExecutor_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.cardId !== null && this.cardId !== undefined) {
      output.writeFieldBegin('cardId', Thrift.Type.STRING, 2);
      output.writeString(this.cardId);
      output.writeFieldEnd();
    }
    if (this.comment !== null && this.comment !== undefined) {
      output.writeFieldBegin('comment', Thrift.Type.STRING, 3);
      output.writeString(this.comment);
      output.writeFieldEnd();
    }
    if (this.policy !== null && this.policy !== undefined) {
      output.writeFieldBegin('policy', Thrift.Type.STRUCT, 4);
      this.policy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_remindDocumentExecutor_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_remindDocumentExecutor_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_updateReassignResolution_args = class {
  constructor(args) {
    this.token = null;
    this.cardId = null;
    this.resolution = null;
    this.policy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.cardId !== undefined && args.cardId !== null) {
        this.cardId = args.cardId;
      }
      if (args.resolution !== undefined && args.resolution !== null) {
        this.resolution = args.resolution;
      }
      if (args.policy !== undefined && args.policy !== null) {
        this.policy = new DocumentAccessPolicy(args.policy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.cardId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.resolution = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.policy = new DocumentAccessPolicy();
          this.policy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_updateReassignResolution_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.cardId !== null && this.cardId !== undefined) {
      output.writeFieldBegin('cardId', Thrift.Type.STRING, 2);
      output.writeString(this.cardId);
      output.writeFieldEnd();
    }
    if (this.resolution !== null && this.resolution !== undefined) {
      output.writeFieldBegin('resolution', Thrift.Type.STRING, 3);
      output.writeString(this.resolution);
      output.writeFieldEnd();
    }
    if (this.policy !== null && this.policy !== undefined) {
      output.writeFieldBegin('policy', Thrift.Type.STRUCT, 4);
      this.policy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_updateReassignResolution_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_updateReassignResolution_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_updateSubStatusComment_args = class {
  constructor(args) {
    this.token = null;
    this.docCommentId = null;
    this.comment = null;
    this.policy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.docCommentId !== undefined && args.docCommentId !== null) {
        this.docCommentId = args.docCommentId;
      }
      if (args.comment !== undefined && args.comment !== null) {
        this.comment = args.comment;
      }
      if (args.policy !== undefined && args.policy !== null) {
        this.policy = new DocumentAccessPolicy(args.policy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.docCommentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.comment = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.policy = new DocumentAccessPolicy();
          this.policy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_updateSubStatusComment_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.docCommentId !== null && this.docCommentId !== undefined) {
      output.writeFieldBegin('docCommentId', Thrift.Type.STRING, 2);
      output.writeString(this.docCommentId);
      output.writeFieldEnd();
    }
    if (this.comment !== null && this.comment !== undefined) {
      output.writeFieldBegin('comment', Thrift.Type.STRING, 3);
      output.writeString(this.comment);
      output.writeFieldEnd();
    }
    if (this.policy !== null && this.policy !== undefined) {
      output.writeFieldBegin('policy', Thrift.Type.STRUCT, 4);
      this.policy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_updateSubStatusComment_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_updateSubStatusComment_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_changeDocumentType_args = class {
  constructor(args) {
    this.token = null;
    this.docId = null;
    this.startStageId = null;
    this.stages = null;
    this.contentItems = null;
    this.roles = null;
    this.patternVariables = null;
    this.accessPolicy = null;
    this.newRegNumber = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.docId !== undefined && args.docId !== null) {
        this.docId = args.docId;
      }
      if (args.startStageId !== undefined && args.startStageId !== null) {
        this.startStageId = args.startStageId;
      }
      if (args.stages !== undefined && args.stages !== null) {
        this.stages = Thrift.copyList(args.stages, [DocumentPatternStage]);
      }
      if (args.contentItems !== undefined && args.contentItems !== null) {
        this.contentItems = Thrift.copyList(args.contentItems, [ContentItem]);
      }
      if (args.roles !== undefined && args.roles !== null) {
        this.roles = Thrift.copyList(args.roles, [PatternProcessRole]);
      }
      if (args.patternVariables !== undefined && args.patternVariables !== null) {
        this.patternVariables = Thrift.copyList(args.patternVariables, [PatternVariable]);
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
      if (args.newRegNumber !== undefined && args.newRegNumber !== null) {
        this.newRegNumber = args.newRegNumber;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.docId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.startStageId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.LIST) {
          this.stages = [];
          const _rtmp3591 = input.readListBegin();
          const _size590 = _rtmp3591.size || 0;
          for (let _i592 = 0; _i592 < _size590; ++_i592) {
            let elem593 = null;
            elem593 = new DocumentPatternStage();
            elem593.read(input);
            this.stages.push(elem593);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.LIST) {
          this.contentItems = [];
          const _rtmp3595 = input.readListBegin();
          const _size594 = _rtmp3595.size || 0;
          for (let _i596 = 0; _i596 < _size594; ++_i596) {
            let elem597 = null;
            elem597 = new ContentItem();
            elem597.read(input);
            this.contentItems.push(elem597);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.LIST) {
          this.roles = [];
          const _rtmp3599 = input.readListBegin();
          const _size598 = _rtmp3599.size || 0;
          for (let _i600 = 0; _i600 < _size598; ++_i600) {
            let elem601 = null;
            elem601 = new PatternProcessRole();
            elem601.read(input);
            this.roles.push(elem601);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.LIST) {
          this.patternVariables = [];
          const _rtmp3603 = input.readListBegin();
          const _size602 = _rtmp3603.size || 0;
          for (let _i604 = 0; _i604 < _size602; ++_i604) {
            let elem605 = null;
            elem605 = new PatternVariable();
            elem605.read(input);
            this.patternVariables.push(elem605);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 9:
        if (ftype == Thrift.Type.STRING) {
          this.newRegNumber = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_changeDocumentType_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.docId !== null && this.docId !== undefined) {
      output.writeFieldBegin('docId', Thrift.Type.STRING, 2);
      output.writeString(this.docId);
      output.writeFieldEnd();
    }
    if (this.startStageId !== null && this.startStageId !== undefined) {
      output.writeFieldBegin('startStageId', Thrift.Type.STRING, 3);
      output.writeString(this.startStageId);
      output.writeFieldEnd();
    }
    if (this.stages !== null && this.stages !== undefined) {
      output.writeFieldBegin('stages', Thrift.Type.LIST, 4);
      output.writeListBegin(Thrift.Type.STRUCT, this.stages.length);
      for (let iter606 in this.stages) {
        if (this.stages.hasOwnProperty(iter606)) {
          iter606 = this.stages[iter606];
          iter606.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.contentItems !== null && this.contentItems !== undefined) {
      output.writeFieldBegin('contentItems', Thrift.Type.LIST, 5);
      output.writeListBegin(Thrift.Type.STRUCT, this.contentItems.length);
      for (let iter607 in this.contentItems) {
        if (this.contentItems.hasOwnProperty(iter607)) {
          iter607 = this.contentItems[iter607];
          iter607.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.roles !== null && this.roles !== undefined) {
      output.writeFieldBegin('roles', Thrift.Type.LIST, 6);
      output.writeListBegin(Thrift.Type.STRUCT, this.roles.length);
      for (let iter608 in this.roles) {
        if (this.roles.hasOwnProperty(iter608)) {
          iter608 = this.roles[iter608];
          iter608.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.patternVariables !== null && this.patternVariables !== undefined) {
      output.writeFieldBegin('patternVariables', Thrift.Type.LIST, 7);
      output.writeListBegin(Thrift.Type.STRUCT, this.patternVariables.length);
      for (let iter609 in this.patternVariables) {
        if (this.patternVariables.hasOwnProperty(iter609)) {
          iter609 = this.patternVariables[iter609];
          iter609.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 8);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    if (this.newRegNumber !== null && this.newRegNumber !== undefined) {
      output.writeFieldBegin('newRegNumber', Thrift.Type.STRING, 9);
      output.writeString(this.newRegNumber);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_changeDocumentType_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_changeDocumentType_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getDocumentRelationModel_args = class {
  constructor(args) {
    this.token = null;
    this.docId = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.docId !== undefined && args.docId !== null) {
        this.docId = args.docId;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.docId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getDocumentRelationModel_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.docId !== null && this.docId !== undefined) {
      output.writeFieldBegin('docId', Thrift.Type.STRING, 2);
      output.writeString(this.docId);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 3);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getDocumentRelationModel_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new DocumentRelationModel(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new DocumentRelationModel();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getDocumentRelationModel_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getNewConvertedAttachmentVersion_args = class {
  constructor(args) {
    this.token = null;
    this.prevAttId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.prevAttId !== undefined && args.prevAttId !== null) {
        this.prevAttId = args.prevAttId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.prevAttId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getNewConvertedAttachmentVersion_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.prevAttId !== null && this.prevAttId !== undefined) {
      output.writeFieldBegin('prevAttId', Thrift.Type.STRING, 2);
      output.writeString(this.prevAttId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getNewConvertedAttachmentVersion_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new Attachment(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new Attachment();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getNewConvertedAttachmentVersion_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_exportAsXML_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_exportAsXML_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 3);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_exportAsXML_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRING) {
          this.success = input.readBinary().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_exportAsXML_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRING, 0);
      output.writeBinary(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_importFromXML_args = class {
  constructor(args) {
    this.token = null;
    this.xml = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.xml !== undefined && args.xml !== null) {
        this.xml = args.xml;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.xml = input.readBinary().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_importFromXML_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.xml !== null && this.xml !== undefined) {
      output.writeFieldBegin('xml', Thrift.Type.STRING, 2);
      output.writeBinary(this.xml);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_importFromXML_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new Document(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new Document();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_importFromXML_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getDocContentItemsForChangeType_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getDocContentItemsForChangeType_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getDocContentItemsForChangeType_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [ContentItem]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3611 = input.readListBegin();
          const _size610 = _rtmp3611.size || 0;
          for (let _i612 = 0; _i612 < _size610; ++_i612) {
            let elem613 = null;
            elem613 = new ContentItem();
            elem613.read(input);
            this.success.push(elem613);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getDocContentItemsForChangeType_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter614 in this.success) {
        if (this.success.hasOwnProperty(iter614)) {
          iter614 = this.success[iter614];
          iter614.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentServiceClient = class {
  constructor(input, output) {
    this.input = input;
    this.output = (!output) ? input : output;
    this.seqid = 0;
  }

  calculatePermissions (token, documentId, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_calculatePermissions(token, documentId, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_calculatePermissions (token, documentId, accessPolicy, callback) {
    const params = {
      token: token,
      documentId: documentId,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_calculatePermissions_args(params);
    try {
      this.output.writeMessageBegin('calculatePermissions', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_calculatePermissions();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_calculatePermissions () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_calculatePermissions_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'calculatePermissions failed: unknown result';
  }

  createOrUpdateDocument (token, document, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_createOrUpdateDocument(token, document, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_createOrUpdateDocument (token, document, accessPolicy, callback) {
    const params = {
      token: token,
      document: document,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_createOrUpdateDocument_args(params);
    try {
      this.output.writeMessageBegin('createOrUpdateDocument', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_createOrUpdateDocument();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_createOrUpdateDocument () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_createOrUpdateDocument_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'createOrUpdateDocument failed: unknown result';
  }

  updateDocument (token, document, accessPolicy, addedResponsibles, removedResponsibles, addedSecurityClassificationIds, removedSecurityClassificationIds) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_updateDocument(token, document, accessPolicy, addedResponsibles, removedResponsibles, addedSecurityClassificationIds, removedSecurityClassificationIds, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_updateDocument (token, document, accessPolicy, addedResponsibles, removedResponsibles, addedSecurityClassificationIds, removedSecurityClassificationIds, callback) {
    const params = {
      token: token,
      document: document,
      accessPolicy: accessPolicy,
      addedResponsibles: addedResponsibles,
      removedResponsibles: removedResponsibles,
      addedSecurityClassificationIds: addedSecurityClassificationIds,
      removedSecurityClassificationIds: removedSecurityClassificationIds
    };
    const args = new DocumentService_updateDocument_args(params);
    try {
      this.output.writeMessageBegin('updateDocument', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_updateDocument();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_updateDocument () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_updateDocument_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'updateDocument failed: unknown result';
  }

  createDocument (token, document, users, holderLinks, securityClassificationsId, attachments, docRelations) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_createDocument(token, document, users, holderLinks, securityClassificationsId, attachments, docRelations, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_createDocument (token, document, users, holderLinks, securityClassificationsId, attachments, docRelations, callback) {
    const params = {
      token: token,
      document: document,
      users: users,
      holderLinks: holderLinks,
      securityClassificationsId: securityClassificationsId,
      attachments: attachments,
      docRelations: docRelations
    };
    const args = new DocumentService_createDocument_args(params);
    try {
      this.output.writeMessageBegin('createDocument', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_createDocument();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_createDocument () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_createDocument_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'createDocument failed: unknown result';
  }

  createDocumentFromXML (token, xmlDoc) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_createDocumentFromXML(token, xmlDoc, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_createDocumentFromXML (token, xmlDoc, callback) {
    const params = {
      token: token,
      xmlDoc: xmlDoc
    };
    const args = new DocumentService_createDocumentFromXML_args(params);
    try {
      this.output.writeMessageBegin('createDocumentFromXML', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_createDocumentFromXML();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_createDocumentFromXML () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_createDocumentFromXML_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'createDocumentFromXML failed: unknown result';
  }

  getDocument (token, documentId, accessPolicy, decrypt, executorsPortion) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getDocument(token, documentId, accessPolicy, decrypt, executorsPortion, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getDocument (token, documentId, accessPolicy, decrypt, executorsPortion, callback) {
    const params = {
      token: token,
      documentId: documentId,
      accessPolicy: accessPolicy,
      decrypt: decrypt,
      executorsPortion: executorsPortion
    };
    const args = new DocumentService_getDocument_args(params);
    try {
      this.output.writeMessageBegin('getDocument', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getDocument();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getDocument () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_getDocument_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getDocument failed: unknown result';
  }

  getAllDocuments (token, accessPolicy, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllDocuments(token, accessPolicy, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllDocuments (token, accessPolicy, filter, callback) {
    const params = {
      token: token,
      accessPolicy: accessPolicy,
      filter: filter
    };
    const args = new DocumentService_getAllDocuments_args(params);
    try {
      this.output.writeMessageBegin('getAllDocuments', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllDocuments();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllDocuments () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_getAllDocuments_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllDocuments failed: unknown result';
  }

  getCountAllDocuments (token, accessPolicy, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getCountAllDocuments(token, accessPolicy, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getCountAllDocuments (token, accessPolicy, filter, callback) {
    const params = {
      token: token,
      accessPolicy: accessPolicy,
      filter: filter
    };
    const args = new DocumentService_getCountAllDocuments_args(params);
    try {
      this.output.writeMessageBegin('getCountAllDocuments', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getCountAllDocuments();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getCountAllDocuments () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_getCountAllDocuments_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getCountAllDocuments failed: unknown result';
  }

  deleteDocument (token, documentId, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_deleteDocument(token, documentId, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_deleteDocument (token, documentId, accessPolicy, callback) {
    const params = {
      token: token,
      documentId: documentId,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_deleteDocument_args(params);
    try {
      this.output.writeMessageBegin('deleteDocument', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_deleteDocument();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_deleteDocument () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_deleteDocument_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'deleteDocument failed: unknown result';
  }

  getAllPassedStages (token, documentId, accessPolicy, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllPassedStages(token, documentId, accessPolicy, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllPassedStages (token, documentId, accessPolicy, filter, callback) {
    const params = {
      token: token,
      documentId: documentId,
      accessPolicy: accessPolicy,
      filter: filter
    };
    const args = new DocumentService_getAllPassedStages_args(params);
    try {
      this.output.writeMessageBegin('getAllPassedStages', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllPassedStages();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllPassedStages () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_getAllPassedStages_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllPassedStages failed: unknown result';
  }

  getExecutionTree (token, documentId, accessPolicy, iteration, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getExecutionTree(token, documentId, accessPolicy, iteration, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getExecutionTree (token, documentId, accessPolicy, iteration, filter, callback) {
    const params = {
      token: token,
      documentId: documentId,
      accessPolicy: accessPolicy,
      iteration: iteration,
      filter: filter
    };
    const args = new DocumentService_getExecutionTree_args(params);
    try {
      this.output.writeMessageBegin('getExecutionTree', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getExecutionTree();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getExecutionTree () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_getExecutionTree_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getExecutionTree failed: unknown result';
  }

  getActiveStages (token, documentId, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getActiveStages(token, documentId, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getActiveStages (token, documentId, accessPolicy, callback) {
    const params = {
      token: token,
      documentId: documentId,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_getActiveStages_args(params);
    try {
      this.output.writeMessageBegin('getActiveStages', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getActiveStages();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getActiveStages () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_getActiveStages_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getActiveStages failed: unknown result';
  }

  getCountPeoplesWhenRenderedDecision (token, documentId, stageId, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getCountPeoplesWhenRenderedDecision(token, documentId, stageId, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getCountPeoplesWhenRenderedDecision (token, documentId, stageId, accessPolicy, callback) {
    const params = {
      token: token,
      documentId: documentId,
      stageId: stageId,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_getCountPeoplesWhenRenderedDecision_args(params);
    try {
      this.output.writeMessageBegin('getCountPeoplesWhenRenderedDecision', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getCountPeoplesWhenRenderedDecision();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getCountPeoplesWhenRenderedDecision () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_getCountPeoplesWhenRenderedDecision_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getCountPeoplesWhenRenderedDecision failed: unknown result';
  }

  setDocumentDecision (token, documentId, decision, documentComment, force, signature, cardId, attachments, holderLinks, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_setDocumentDecision(token, documentId, decision, documentComment, force, signature, cardId, attachments, holderLinks, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_setDocumentDecision (token, documentId, decision, documentComment, force, signature, cardId, attachments, holderLinks, accessPolicy, callback) {
    const params = {
      token: token,
      documentId: documentId,
      decision: decision,
      documentComment: documentComment,
      force: force,
      signature: signature,
      cardId: cardId,
      attachments: attachments,
      holderLinks: holderLinks,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_setDocumentDecision_args(params);
    try {
      this.output.writeMessageBegin('setDocumentDecision', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_setDocumentDecision();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_setDocumentDecision () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_setDocumentDecision_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'setDocumentDecision failed: unknown result';
  }

  setDocumentDecisionUsingServerKeyStorage (token, documentId, decision, documentComment, force, pKeyId, password, cardId, attachments, holderLinks, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_setDocumentDecisionUsingServerKeyStorage(token, documentId, decision, documentComment, force, pKeyId, password, cardId, attachments, holderLinks, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_setDocumentDecisionUsingServerKeyStorage (token, documentId, decision, documentComment, force, pKeyId, password, cardId, attachments, holderLinks, accessPolicy, callback) {
    const params = {
      token: token,
      documentId: documentId,
      decision: decision,
      documentComment: documentComment,
      force: force,
      pKeyId: pKeyId,
      password: password,
      cardId: cardId,
      attachments: attachments,
      holderLinks: holderLinks,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_setDocumentDecisionUsingServerKeyStorage_args(params);
    try {
      this.output.writeMessageBegin('setDocumentDecisionUsingServerKeyStorage', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_setDocumentDecisionUsingServerKeyStorage();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_setDocumentDecisionUsingServerKeyStorage () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_setDocumentDecisionUsingServerKeyStorage_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'setDocumentDecisionUsingServerKeyStorage failed: unknown result';
  }

  approveDocumentDecision (token, executionId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_approveDocumentDecision(token, executionId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_approveDocumentDecision (token, executionId, callback) {
    const params = {
      token: token,
      executionId: executionId
    };
    const args = new DocumentService_approveDocumentDecision_args(params);
    try {
      this.output.writeMessageBegin('approveDocumentDecision', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_approveDocumentDecision();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_approveDocumentDecision () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_approveDocumentDecision_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'approveDocumentDecision failed: unknown result';
  }

  shareDocument (token, documentId, accessPolicy, usersOrGroups) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_shareDocument(token, documentId, accessPolicy, usersOrGroups, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_shareDocument (token, documentId, accessPolicy, usersOrGroups, callback) {
    const params = {
      token: token,
      documentId: documentId,
      accessPolicy: accessPolicy,
      usersOrGroups: usersOrGroups
    };
    const args = new DocumentService_shareDocument_args(params);
    try {
      this.output.writeMessageBegin('shareDocument', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_shareDocument();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_shareDocument () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_shareDocument_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'shareDocument failed: unknown result';
  }

  revokeDocument (token, documentId, usersOrGroups, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_revokeDocument(token, documentId, usersOrGroups, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_revokeDocument (token, documentId, usersOrGroups, accessPolicy, callback) {
    const params = {
      token: token,
      documentId: documentId,
      usersOrGroups: usersOrGroups,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_revokeDocument_args(params);
    try {
      this.output.writeMessageBegin('revokeDocument', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_revokeDocument();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_revokeDocument () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_revokeDocument_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'revokeDocument failed: unknown result';
  }

  getAllDocumentSharings (token, documentId, accessPolicy, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllDocumentSharings(token, documentId, accessPolicy, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllDocumentSharings (token, documentId, accessPolicy, filter, callback) {
    const params = {
      token: token,
      documentId: documentId,
      accessPolicy: accessPolicy,
      filter: filter
    };
    const args = new DocumentService_getAllDocumentSharings_args(params);
    try {
      this.output.writeMessageBegin('getAllDocumentSharings', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllDocumentSharings();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllDocumentSharings () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_getAllDocumentSharings_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllDocumentSharings failed: unknown result';
  }

  getAllDocumentReassign (token, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllDocumentReassign(token, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllDocumentReassign (token, filter, callback) {
    const params = {
      token: token,
      filter: filter
    };
    const args = new DocumentService_getAllDocumentReassign_args(params);
    try {
      this.output.writeMessageBegin('getAllDocumentReassign', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllDocumentReassign();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllDocumentReassign () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_getAllDocumentReassign_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllDocumentReassign failed: unknown result';
  }

  reassignDocument (token, documentId, documentReassign, cardId, signature) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_reassignDocument(token, documentId, documentReassign, cardId, signature, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_reassignDocument (token, documentId, documentReassign, cardId, signature, callback) {
    const params = {
      token: token,
      documentId: documentId,
      documentReassign: documentReassign,
      cardId: cardId,
      signature: signature
    };
    const args = new DocumentService_reassignDocument_args(params);
    try {
      this.output.writeMessageBegin('reassignDocument', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_reassignDocument();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_reassignDocument () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_reassignDocument_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'reassignDocument failed: unknown result';
  }

  reassignDocumentUsingServerKeyStorage (token, documentId, documentReassign, cardId, pKeyId, password) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_reassignDocumentUsingServerKeyStorage(token, documentId, documentReassign, cardId, pKeyId, password, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_reassignDocumentUsingServerKeyStorage (token, documentId, documentReassign, cardId, pKeyId, password, callback) {
    const params = {
      token: token,
      documentId: documentId,
      documentReassign: documentReassign,
      cardId: cardId,
      pKeyId: pKeyId,
      password: password
    };
    const args = new DocumentService_reassignDocumentUsingServerKeyStorage_args(params);
    try {
      this.output.writeMessageBegin('reassignDocumentUsingServerKeyStorage', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_reassignDocumentUsingServerKeyStorage();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_reassignDocumentUsingServerKeyStorage () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_reassignDocumentUsingServerKeyStorage_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'reassignDocumentUsingServerKeyStorage failed: unknown result';
  }

  revokeChildCards (token, cardId, deleteCard, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_revokeChildCards(token, cardId, deleteCard, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_revokeChildCards (token, cardId, deleteCard, accessPolicy, callback) {
    const params = {
      token: token,
      cardId: cardId,
      deleteCard: deleteCard,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_revokeChildCards_args(params);
    try {
      this.output.writeMessageBegin('revokeChildCards', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_revokeChildCards();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_revokeChildCards () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_revokeChildCards_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'revokeChildCards failed: unknown result';
  }

  createOrUpdateAutomaticDocumentReassign (token, documentReassign) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_createOrUpdateAutomaticDocumentReassign(token, documentReassign, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_createOrUpdateAutomaticDocumentReassign (token, documentReassign, callback) {
    const params = {
      token: token,
      documentReassign: documentReassign
    };
    const args = new DocumentService_createOrUpdateAutomaticDocumentReassign_args(params);
    try {
      this.output.writeMessageBegin('createOrUpdateAutomaticDocumentReassign', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_createOrUpdateAutomaticDocumentReassign();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_createOrUpdateAutomaticDocumentReassign () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_createOrUpdateAutomaticDocumentReassign_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'createOrUpdateAutomaticDocumentReassign failed: unknown result';
  }

  deleteAutomaticDocumentReassign (token, documentReassignId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_deleteAutomaticDocumentReassign(token, documentReassignId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_deleteAutomaticDocumentReassign (token, documentReassignId, callback) {
    const params = {
      token: token,
      documentReassignId: documentReassignId
    };
    const args = new DocumentService_deleteAutomaticDocumentReassign_args(params);
    try {
      this.output.writeMessageBegin('deleteAutomaticDocumentReassign', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_deleteAutomaticDocumentReassign();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_deleteAutomaticDocumentReassign () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_deleteAutomaticDocumentReassign_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'deleteAutomaticDocumentReassign failed: unknown result';
  }

  changeReassignControl (token, documentExecutionId, userId, reassignType) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_changeReassignControl(token, documentExecutionId, userId, reassignType, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_changeReassignControl (token, documentExecutionId, userId, reassignType, callback) {
    const params = {
      token: token,
      documentExecutionId: documentExecutionId,
      userId: userId,
      reassignType: reassignType
    };
    const args = new DocumentService_changeReassignControl_args(params);
    try {
      this.output.writeMessageBegin('changeReassignControl', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_changeReassignControl();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_changeReassignControl () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_changeReassignControl_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'changeReassignControl failed: unknown result';
  }

  getAllDocumentExecutions (token, documentId, stageId, typeLink, filter, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllDocumentExecutions(token, documentId, stageId, typeLink, filter, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllDocumentExecutions (token, documentId, stageId, typeLink, filter, accessPolicy, callback) {
    const params = {
      token: token,
      documentId: documentId,
      stageId: stageId,
      typeLink: typeLink,
      filter: filter,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_getAllDocumentExecutions_args(params);
    try {
      this.output.writeMessageBegin('getAllDocumentExecutions', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllDocumentExecutions();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllDocumentExecutions () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_getAllDocumentExecutions_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllDocumentExecutions failed: unknown result';
  }

  getDocumentExecution (token, docExecutionId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getDocumentExecution(token, docExecutionId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getDocumentExecution (token, docExecutionId, callback) {
    const params = {
      token: token,
      docExecutionId: docExecutionId
    };
    const args = new DocumentService_getDocumentExecution_args(params);
    try {
      this.output.writeMessageBegin('getDocumentExecution', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getDocumentExecution();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getDocumentExecution () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_getDocumentExecution_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getDocumentExecution failed: unknown result';
  }

  changeExecutorsForDocument (token, docId, toAdd, toClose, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_changeExecutorsForDocument(token, docId, toAdd, toClose, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_changeExecutorsForDocument (token, docId, toAdd, toClose, accessPolicy, callback) {
    const params = {
      token: token,
      docId: docId,
      toAdd: toAdd,
      toClose: toClose,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_changeExecutorsForDocument_args(params);
    try {
      this.output.writeMessageBegin('changeExecutorsForDocument', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_changeExecutorsForDocument();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_changeExecutorsForDocument () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_changeExecutorsForDocument_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'changeExecutorsForDocument failed: unknown result';
  }

  createAttachmentFrom (token, documentId, cardId, accessPolicy, attCreateInfoList, processingType) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_createAttachmentFrom(token, documentId, cardId, accessPolicy, attCreateInfoList, processingType, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_createAttachmentFrom (token, documentId, cardId, accessPolicy, attCreateInfoList, processingType, callback) {
    const params = {
      token: token,
      documentId: documentId,
      cardId: cardId,
      accessPolicy: accessPolicy,
      attCreateInfoList: attCreateInfoList,
      processingType: processingType
    };
    const args = new DocumentService_createAttachmentFrom_args(params);
    try {
      this.output.writeMessageBegin('createAttachmentFrom', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_createAttachmentFrom();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_createAttachmentFrom () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_createAttachmentFrom_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'createAttachmentFrom failed: unknown result';
  }

  createLoadableAttachment (token, documentId, fileName, totalSize, countPortions, cardId, attachmmentId, forDraft, accessPolicy, editMode, meetingId, extStatus) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_createLoadableAttachment(token, documentId, fileName, totalSize, countPortions, cardId, attachmmentId, forDraft, accessPolicy, editMode, meetingId, extStatus, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_createLoadableAttachment (token, documentId, fileName, totalSize, countPortions, cardId, attachmmentId, forDraft, accessPolicy, editMode, meetingId, extStatus, callback) {
    const params = {
      token: token,
      documentId: documentId,
      fileName: fileName,
      totalSize: totalSize,
      countPortions: countPortions,
      cardId: cardId,
      attachmmentId: attachmmentId,
      forDraft: forDraft,
      accessPolicy: accessPolicy,
      editMode: editMode,
      meetingId: meetingId,
      extStatus: extStatus
    };
    const args = new DocumentService_createLoadableAttachment_args(params);
    try {
      this.output.writeMessageBegin('createLoadableAttachment', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_createLoadableAttachment();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_createLoadableAttachment () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_createLoadableAttachment_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'createLoadableAttachment failed: unknown result';
  }

  uploadDocumentAttachmentPortions (token, attachmentId, numberPortion, fileContentBytes) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_uploadDocumentAttachmentPortions(token, attachmentId, numberPortion, fileContentBytes, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_uploadDocumentAttachmentPortions (token, attachmentId, numberPortion, fileContentBytes, callback) {
    const params = {
      token: token,
      attachmentId: attachmentId,
      numberPortion: numberPortion,
      fileContentBytes: fileContentBytes
    };
    const args = new DocumentService_uploadDocumentAttachmentPortions_args(params);
    try {
      this.output.writeMessageBegin('uploadDocumentAttachmentPortions', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_uploadDocumentAttachmentPortions();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_uploadDocumentAttachmentPortions () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_uploadDocumentAttachmentPortions_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'uploadDocumentAttachmentPortions failed: unknown result';
  }

  downloadDocumentAttachment (token, attachmentId, attachmentType, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_downloadDocumentAttachment(token, attachmentId, attachmentType, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_downloadDocumentAttachment (token, attachmentId, attachmentType, accessPolicy, callback) {
    const params = {
      token: token,
      attachmentId: attachmentId,
      attachmentType: attachmentType,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_downloadDocumentAttachment_args(params);
    try {
      this.output.writeMessageBegin('downloadDocumentAttachment', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_downloadDocumentAttachment();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_downloadDocumentAttachment () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_downloadDocumentAttachment_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'downloadDocumentAttachment failed: unknown result';
  }

  rotatePdfPages (token, attachmentId, pages, angle, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_rotatePdfPages(token, attachmentId, pages, angle, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_rotatePdfPages (token, attachmentId, pages, angle, accessPolicy, callback) {
    const params = {
      token: token,
      attachmentId: attachmentId,
      pages: pages,
      angle: angle,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_rotatePdfPages_args(params);
    try {
      this.output.writeMessageBegin('rotatePdfPages', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_rotatePdfPages();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_rotatePdfPages () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_rotatePdfPages_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'rotatePdfPages failed: unknown result';
  }

  addAttachmentsToDocument (token, documentId, attachments, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_addAttachmentsToDocument(token, documentId, attachments, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_addAttachmentsToDocument (token, documentId, attachments, accessPolicy, callback) {
    const params = {
      token: token,
      documentId: documentId,
      attachments: attachments,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_addAttachmentsToDocument_args(params);
    try {
      this.output.writeMessageBegin('addAttachmentsToDocument', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_addAttachmentsToDocument();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_addAttachmentsToDocument () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_addAttachmentsToDocument_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'addAttachmentsToDocument failed: unknown result';
  }

  removeDocumentAttachment (token, attachmentId, removeOldVersions, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_removeDocumentAttachment(token, attachmentId, removeOldVersions, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_removeDocumentAttachment (token, attachmentId, removeOldVersions, accessPolicy, callback) {
    const params = {
      token: token,
      attachmentId: attachmentId,
      removeOldVersions: removeOldVersions,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_removeDocumentAttachment_args(params);
    try {
      this.output.writeMessageBegin('removeDocumentAttachment', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_removeDocumentAttachment();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_removeDocumentAttachment () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_removeDocumentAttachment_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'removeDocumentAttachment failed: unknown result';
  }

  markAsWaitForPublish (token, attachmentId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_markAsWaitForPublish(token, attachmentId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_markAsWaitForPublish (token, attachmentId, callback) {
    const params = {
      token: token,
      attachmentId: attachmentId
    };
    const args = new DocumentService_markAsWaitForPublish_args(params);
    try {
      this.output.writeMessageBegin('markAsWaitForPublish', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_markAsWaitForPublish();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_markAsWaitForPublish () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_markAsWaitForPublish_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'markAsWaitForPublish failed: unknown result';
  }

  changeAttachmentEditMode (token, attachmentId, editMode) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_changeAttachmentEditMode(token, attachmentId, editMode, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_changeAttachmentEditMode (token, attachmentId, editMode, callback) {
    const params = {
      token: token,
      attachmentId: attachmentId,
      editMode: editMode
    };
    const args = new DocumentService_changeAttachmentEditMode_args(params);
    try {
      this.output.writeMessageBegin('changeAttachmentEditMode', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_changeAttachmentEditMode();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_changeAttachmentEditMode () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_changeAttachmentEditMode_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'changeAttachmentEditMode failed: unknown result';
  }

  getDocumentAttachments (token, documentId, latestOnly, filter, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getDocumentAttachments(token, documentId, latestOnly, filter, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getDocumentAttachments (token, documentId, latestOnly, filter, accessPolicy, callback) {
    const params = {
      token: token,
      documentId: documentId,
      latestOnly: latestOnly,
      filter: filter,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_getDocumentAttachments_args(params);
    try {
      this.output.writeMessageBegin('getDocumentAttachments', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getDocumentAttachments();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getDocumentAttachments () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_getDocumentAttachments_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getDocumentAttachments failed: unknown result';
  }

  getDocumentAttachmentById (token, attachmentId, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getDocumentAttachmentById(token, attachmentId, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getDocumentAttachmentById (token, attachmentId, accessPolicy, callback) {
    const params = {
      token: token,
      attachmentId: attachmentId,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_getDocumentAttachmentById_args(params);
    try {
      this.output.writeMessageBegin('getDocumentAttachmentById', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getDocumentAttachmentById();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getDocumentAttachmentById () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_getDocumentAttachmentById_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getDocumentAttachmentById failed: unknown result';
  }

  getAllDocumentAttachmentVersions (token, attachmentId, filter, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllDocumentAttachmentVersions(token, attachmentId, filter, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllDocumentAttachmentVersions (token, attachmentId, filter, accessPolicy, callback) {
    const params = {
      token: token,
      attachmentId: attachmentId,
      filter: filter,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_getAllDocumentAttachmentVersions_args(params);
    try {
      this.output.writeMessageBegin('getAllDocumentAttachmentVersions', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllDocumentAttachmentVersions();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllDocumentAttachmentVersions () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_getAllDocumentAttachmentVersions_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllDocumentAttachmentVersions failed: unknown result';
  }

  changeAttachmentsVisibility (token, toHideList, toShowList) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_changeAttachmentsVisibility(token, toHideList, toShowList, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_changeAttachmentsVisibility (token, toHideList, toShowList, callback) {
    const params = {
      token: token,
      toHideList: toHideList,
      toShowList: toShowList
    };
    const args = new DocumentService_changeAttachmentsVisibility_args(params);
    try {
      this.output.writeMessageBegin('changeAttachmentsVisibility', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_changeAttachmentsVisibility();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_changeAttachmentsVisibility () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_changeAttachmentsVisibility_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'changeAttachmentsVisibility failed: unknown result';
  }

  createOrUpdateDocumentComment (token, documentComment, addToComment, changeType, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_createOrUpdateDocumentComment(token, documentComment, addToComment, changeType, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_createOrUpdateDocumentComment (token, documentComment, addToComment, changeType, accessPolicy, callback) {
    const params = {
      token: token,
      documentComment: documentComment,
      addToComment: addToComment,
      changeType: changeType,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_createOrUpdateDocumentComment_args(params);
    try {
      this.output.writeMessageBegin('createOrUpdateDocumentComment', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_createOrUpdateDocumentComment();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_createOrUpdateDocumentComment () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_createOrUpdateDocumentComment_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'createOrUpdateDocumentComment failed: unknown result';
  }

  getAllDocumentComments (token, documentId, filter, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllDocumentComments(token, documentId, filter, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllDocumentComments (token, documentId, filter, accessPolicy, callback) {
    const params = {
      token: token,
      documentId: documentId,
      filter: filter,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_getAllDocumentComments_args(params);
    try {
      this.output.writeMessageBegin('getAllDocumentComments', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllDocumentComments();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllDocumentComments () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_getAllDocumentComments_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllDocumentComments failed: unknown result';
  }

  deleteDocumentComment (token, documentCommentId, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_deleteDocumentComment(token, documentCommentId, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_deleteDocumentComment (token, documentCommentId, accessPolicy, callback) {
    const params = {
      token: token,
      documentCommentId: documentCommentId,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_deleteDocumentComment_args(params);
    try {
      this.output.writeMessageBegin('deleteDocumentComment', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_deleteDocumentComment();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_deleteDocumentComment () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_deleteDocumentComment_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'deleteDocumentComment failed: unknown result';
  }

  createOrUpdateDocumentContentHolderLink (token, documentId, holderLinks, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_createOrUpdateDocumentContentHolderLink(token, documentId, holderLinks, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_createOrUpdateDocumentContentHolderLink (token, documentId, holderLinks, accessPolicy, callback) {
    const params = {
      token: token,
      documentId: documentId,
      holderLinks: holderLinks,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_createOrUpdateDocumentContentHolderLink_args(params);
    try {
      this.output.writeMessageBegin('createOrUpdateDocumentContentHolderLink', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_createOrUpdateDocumentContentHolderLink();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_createOrUpdateDocumentContentHolderLink () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_createOrUpdateDocumentContentHolderLink_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'createOrUpdateDocumentContentHolderLink failed: unknown result';
  }

  createOrUpdateDocumentContentTab (token, documentId, documentContentTab, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_createOrUpdateDocumentContentTab(token, documentId, documentContentTab, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_createOrUpdateDocumentContentTab (token, documentId, documentContentTab, accessPolicy, callback) {
    const params = {
      token: token,
      documentId: documentId,
      documentContentTab: documentContentTab,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_createOrUpdateDocumentContentTab_args(params);
    try {
      this.output.writeMessageBegin('createOrUpdateDocumentContentTab', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_createOrUpdateDocumentContentTab();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_createOrUpdateDocumentContentTab () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_createOrUpdateDocumentContentTab_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'createOrUpdateDocumentContentTab failed: unknown result';
  }

  getDocumentContentTabsByFilter (token, documentId, filter, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getDocumentContentTabsByFilter(token, documentId, filter, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getDocumentContentTabsByFilter (token, documentId, filter, accessPolicy, callback) {
    const params = {
      token: token,
      documentId: documentId,
      filter: filter,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_getDocumentContentTabsByFilter_args(params);
    try {
      this.output.writeMessageBegin('getDocumentContentTabsByFilter', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getDocumentContentTabsByFilter();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getDocumentContentTabsByFilter () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_getDocumentContentTabsByFilter_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getDocumentContentTabsByFilter failed: unknown result';
  }

  deleteDocumentContentTab (token, documentContentTabId, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_deleteDocumentContentTab(token, documentContentTabId, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_deleteDocumentContentTab (token, documentContentTabId, accessPolicy, callback) {
    const params = {
      token: token,
      documentContentTabId: documentContentTabId,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_deleteDocumentContentTab_args(params);
    try {
      this.output.writeMessageBegin('deleteDocumentContentTab', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_deleteDocumentContentTab();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_deleteDocumentContentTab () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_deleteDocumentContentTab_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'deleteDocumentContentTab failed: unknown result';
  }

  documentToArchive (token, documentId, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_documentToArchive(token, documentId, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_documentToArchive (token, documentId, accessPolicy, callback) {
    const params = {
      token: token,
      documentId: documentId,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_documentToArchive_args(params);
    try {
      this.output.writeMessageBegin('documentToArchive', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_documentToArchive();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_documentToArchive () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_documentToArchive_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'documentToArchive failed: unknown result';
  }

  getAllResponsibleForDocument (token, documentId, accessPolicy, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllResponsibleForDocument(token, documentId, accessPolicy, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllResponsibleForDocument (token, documentId, accessPolicy, filter, callback) {
    const params = {
      token: token,
      documentId: documentId,
      accessPolicy: accessPolicy,
      filter: filter
    };
    const args = new DocumentService_getAllResponsibleForDocument_args(params);
    try {
      this.output.writeMessageBegin('getAllResponsibleForDocument', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllResponsibleForDocument();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllResponsibleForDocument () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_getAllResponsibleForDocument_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllResponsibleForDocument failed: unknown result';
  }

  addResponsibleForDocument (token, documentId, users, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_addResponsibleForDocument(token, documentId, users, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_addResponsibleForDocument (token, documentId, users, accessPolicy, callback) {
    const params = {
      token: token,
      documentId: documentId,
      users: users,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_addResponsibleForDocument_args(params);
    try {
      this.output.writeMessageBegin('addResponsibleForDocument', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_addResponsibleForDocument();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_addResponsibleForDocument () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_addResponsibleForDocument_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'addResponsibleForDocument failed: unknown result';
  }

  removeResponsibleForDocument (token, documentId, users, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_removeResponsibleForDocument(token, documentId, users, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_removeResponsibleForDocument (token, documentId, users, accessPolicy, callback) {
    const params = {
      token: token,
      documentId: documentId,
      users: users,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_removeResponsibleForDocument_args(params);
    try {
      this.output.writeMessageBegin('removeResponsibleForDocument', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_removeResponsibleForDocument();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_removeResponsibleForDocument () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_removeResponsibleForDocument_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'removeResponsibleForDocument failed: unknown result';
  }

  getDocHistoryPage (token, documentId, accessPolicy, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getDocHistoryPage(token, documentId, accessPolicy, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getDocHistoryPage (token, documentId, accessPolicy, filter, callback) {
    const params = {
      token: token,
      documentId: documentId,
      accessPolicy: accessPolicy,
      filter: filter
    };
    const args = new DocumentService_getDocHistoryPage_args(params);
    try {
      this.output.writeMessageBegin('getDocHistoryPage', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getDocHistoryPage();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getDocHistoryPage () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_getDocHistoryPage_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getDocHistoryPage failed: unknown result';
  }

  getAllNews (token, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllNews(token, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllNews (token, filter, callback) {
    const params = {
      token: token,
      filter: filter
    };
    const args = new DocumentService_getAllNews_args(params);
    try {
      this.output.writeMessageBegin('getAllNews', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllNews();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllNews () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_getAllNews_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllNews failed: unknown result';
  }

  getTasksByDate (token, date) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getTasksByDate(token, date, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getTasksByDate (token, date, callback) {
    const params = {
      token: token,
      date: date
    };
    const args = new DocumentService_getTasksByDate_args(params);
    try {
      this.output.writeMessageBegin('getTasksByDate', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getTasksByDate();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getTasksByDate () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_getTasksByDate_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getTasksByDate failed: unknown result';
  }

  generateDocumentNumber (token, documentId, docNumber, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_generateDocumentNumber(token, documentId, docNumber, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_generateDocumentNumber (token, documentId, docNumber, accessPolicy, callback) {
    const params = {
      token: token,
      documentId: documentId,
      docNumber: docNumber,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_generateDocumentNumber_args(params);
    try {
      this.output.writeMessageBegin('generateDocumentNumber', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_generateDocumentNumber();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_generateDocumentNumber () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_generateDocumentNumber_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'generateDocumentNumber failed: unknown result';
  }

  setDocumentViewed (token, documentId, viewed, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_setDocumentViewed(token, documentId, viewed, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_setDocumentViewed (token, documentId, viewed, accessPolicy, callback) {
    const params = {
      token: token,
      documentId: documentId,
      viewed: viewed,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_setDocumentViewed_args(params);
    try {
      this.output.writeMessageBegin('setDocumentViewed', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_setDocumentViewed();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_setDocumentViewed () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_setDocumentViewed_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'setDocumentViewed failed: unknown result';
  }

  getAllDocumentRelations (token, documentId, filter, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllDocumentRelations(token, documentId, filter, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllDocumentRelations (token, documentId, filter, accessPolicy, callback) {
    const params = {
      token: token,
      documentId: documentId,
      filter: filter,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_getAllDocumentRelations_args(params);
    try {
      this.output.writeMessageBegin('getAllDocumentRelations', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllDocumentRelations();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllDocumentRelations () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_getAllDocumentRelations_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllDocumentRelations failed: unknown result';
  }

  changeRelations (token, toCreate, toRemove) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_changeRelations(token, toCreate, toRemove, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_changeRelations (token, toCreate, toRemove, callback) {
    const params = {
      token: token,
      toCreate: toCreate,
      toRemove: toRemove
    };
    const args = new DocumentService_changeRelations_args(params);
    try {
      this.output.writeMessageBegin('changeRelations', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_changeRelations();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_changeRelations () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_changeRelations_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'changeRelations failed: unknown result';
  }

  changeSubStatus (token, documentId, subStatus, comment, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_changeSubStatus(token, documentId, subStatus, comment, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_changeSubStatus (token, documentId, subStatus, comment, accessPolicy, callback) {
    const params = {
      token: token,
      documentId: documentId,
      subStatus: subStatus,
      comment: comment,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_changeSubStatus_args(params);
    try {
      this.output.writeMessageBegin('changeSubStatus', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_changeSubStatus();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_changeSubStatus () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_changeSubStatus_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'changeSubStatus failed: unknown result';
  }

  increaseDeadlineForDocumentOrDocumentExecution (token, documentId, documentExecution, deadlineTime, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_increaseDeadlineForDocumentOrDocumentExecution(token, documentId, documentExecution, deadlineTime, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_increaseDeadlineForDocumentOrDocumentExecution (token, documentId, documentExecution, deadlineTime, accessPolicy, callback) {
    const params = {
      token: token,
      documentId: documentId,
      documentExecution: documentExecution,
      deadlineTime: deadlineTime,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_increaseDeadlineForDocumentOrDocumentExecution_args(params);
    try {
      this.output.writeMessageBegin('increaseDeadlineForDocumentOrDocumentExecution', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_increaseDeadlineForDocumentOrDocumentExecution();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_increaseDeadlineForDocumentOrDocumentExecution () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_increaseDeadlineForDocumentOrDocumentExecution_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'increaseDeadlineForDocumentOrDocumentExecution failed: unknown result';
  }

  addAdditionalConfirmers (token, cardId, users, deadlineDate, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_addAdditionalConfirmers(token, cardId, users, deadlineDate, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_addAdditionalConfirmers (token, cardId, users, deadlineDate, accessPolicy, callback) {
    const params = {
      token: token,
      cardId: cardId,
      users: users,
      deadlineDate: deadlineDate,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_addAdditionalConfirmers_args(params);
    try {
      this.output.writeMessageBegin('addAdditionalConfirmers', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_addAdditionalConfirmers();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_addAdditionalConfirmers () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_addAdditionalConfirmers_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'addAdditionalConfirmers failed: unknown result';
  }

  setAdditionalDecision (token, userDecision, cardId, comment, returnToParentStage, signature) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_setAdditionalDecision(token, userDecision, cardId, comment, returnToParentStage, signature, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_setAdditionalDecision (token, userDecision, cardId, comment, returnToParentStage, signature, callback) {
    const params = {
      token: token,
      userDecision: userDecision,
      cardId: cardId,
      comment: comment,
      returnToParentStage: returnToParentStage,
      signature: signature
    };
    const args = new DocumentService_setAdditionalDecision_args(params);
    try {
      this.output.writeMessageBegin('setAdditionalDecision', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_setAdditionalDecision();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_setAdditionalDecision () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_setAdditionalDecision_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'setAdditionalDecision failed: unknown result';
  }

  revokeDecision (token, documentReassign, cardId, comment) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_revokeDecision(token, documentReassign, cardId, comment, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_revokeDecision (token, documentReassign, cardId, comment, callback) {
    const params = {
      token: token,
      documentReassign: documentReassign,
      cardId: cardId,
      comment: comment
    };
    const args = new DocumentService_revokeDecision_args(params);
    try {
      this.output.writeMessageBegin('revokeDecision', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_revokeDecision();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_revokeDecision () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_revokeDecision_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'revokeDecision failed: unknown result';
  }

  markDecisionAsRemoved (token, documentId, cardId, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_markDecisionAsRemoved(token, documentId, cardId, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_markDecisionAsRemoved (token, documentId, cardId, accessPolicy, callback) {
    const params = {
      token: token,
      documentId: documentId,
      cardId: cardId,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_markDecisionAsRemoved_args(params);
    try {
      this.output.writeMessageBegin('markDecisionAsRemoved', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_markDecisionAsRemoved();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_markDecisionAsRemoved () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_markDecisionAsRemoved_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'markDecisionAsRemoved failed: unknown result';
  }

  getAllOpenDocumentExecutionsStatistic (token, userId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllOpenDocumentExecutionsStatistic(token, userId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllOpenDocumentExecutionsStatistic (token, userId, callback) {
    const params = {
      token: token,
      userId: userId
    };
    const args = new DocumentService_getAllOpenDocumentExecutionsStatistic_args(params);
    try {
      this.output.writeMessageBegin('getAllOpenDocumentExecutionsStatistic', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllOpenDocumentExecutionsStatistic();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllOpenDocumentExecutionsStatistic () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_getAllOpenDocumentExecutionsStatistic_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllOpenDocumentExecutionsStatistic failed: unknown result';
  }

  changeControlForDocument (token, documentId, control, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_changeControlForDocument(token, documentId, control, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_changeControlForDocument (token, documentId, control, accessPolicy, callback) {
    const params = {
      token: token,
      documentId: documentId,
      control: control,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_changeControlForDocument_args(params);
    try {
      this.output.writeMessageBegin('changeControlForDocument', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_changeControlForDocument();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_changeControlForDocument () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_changeControlForDocument_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'changeControlForDocument failed: unknown result';
  }

  addTagsToDocument (token, docId, tags) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_addTagsToDocument(token, docId, tags, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_addTagsToDocument (token, docId, tags, callback) {
    const params = {
      token: token,
      docId: docId,
      tags: tags
    };
    const args = new DocumentService_addTagsToDocument_args(params);
    try {
      this.output.writeMessageBegin('addTagsToDocument', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_addTagsToDocument();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_addTagsToDocument () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_addTagsToDocument_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'addTagsToDocument failed: unknown result';
  }

  removeTagsToDocument (token, docId, tags) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_removeTagsToDocument(token, docId, tags, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_removeTagsToDocument (token, docId, tags, callback) {
    const params = {
      token: token,
      docId: docId,
      tags: tags
    };
    const args = new DocumentService_removeTagsToDocument_args(params);
    try {
      this.output.writeMessageBegin('removeTagsToDocument', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_removeTagsToDocument();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_removeTagsToDocument () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_removeTagsToDocument_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'removeTagsToDocument failed: unknown result';
  }

  addExecutorsToStage (token, docId, documentReassign, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_addExecutorsToStage(token, docId, documentReassign, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_addExecutorsToStage (token, docId, documentReassign, accessPolicy, callback) {
    const params = {
      token: token,
      docId: docId,
      documentReassign: documentReassign,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_addExecutorsToStage_args(params);
    try {
      this.output.writeMessageBegin('addExecutorsToStage', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_addExecutorsToStage();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_addExecutorsToStage () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_addExecutorsToStage_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'addExecutorsToStage failed: unknown result';
  }

  getCountDocsByFilterNoPermission (token, patternGroupId, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getCountDocsByFilterNoPermission(token, patternGroupId, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getCountDocsByFilterNoPermission (token, patternGroupId, filter, callback) {
    const params = {
      token: token,
      patternGroupId: patternGroupId,
      filter: filter
    };
    const args = new DocumentService_getCountDocsByFilterNoPermission_args(params);
    try {
      this.output.writeMessageBegin('getCountDocsByFilterNoPermission', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getCountDocsByFilterNoPermission();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getCountDocsByFilterNoPermission () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_getCountDocsByFilterNoPermission_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getCountDocsByFilterNoPermission failed: unknown result';
  }

  getTinyDocsByFilterNoPermission (token, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getTinyDocsByFilterNoPermission(token, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getTinyDocsByFilterNoPermission (token, filter, callback) {
    const params = {
      token: token,
      filter: filter
    };
    const args = new DocumentService_getTinyDocsByFilterNoPermission_args(params);
    try {
      this.output.writeMessageBegin('getTinyDocsByFilterNoPermission', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getTinyDocsByFilterNoPermission();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getTinyDocsByFilterNoPermission () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_getTinyDocsByFilterNoPermission_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getTinyDocsByFilterNoPermission failed: unknown result';
  }

  changeRegistrationInfoForDocument (token, documentId, newRegistrationDate, newRegistrationNumber, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_changeRegistrationInfoForDocument(token, documentId, newRegistrationDate, newRegistrationNumber, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_changeRegistrationInfoForDocument (token, documentId, newRegistrationDate, newRegistrationNumber, accessPolicy, callback) {
    const params = {
      token: token,
      documentId: documentId,
      newRegistrationDate: newRegistrationDate,
      newRegistrationNumber: newRegistrationNumber,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_changeRegistrationInfoForDocument_args(params);
    try {
      this.output.writeMessageBegin('changeRegistrationInfoForDocument', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_changeRegistrationInfoForDocument();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_changeRegistrationInfoForDocument () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_changeRegistrationInfoForDocument_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'changeRegistrationInfoForDocument failed: unknown result';
  }

  createChatForDocument (token, documentId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_createChatForDocument(token, documentId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_createChatForDocument (token, documentId, callback) {
    const params = {
      token: token,
      documentId: documentId
    };
    const args = new DocumentService_createChatForDocument_args(params);
    try {
      this.output.writeMessageBegin('createChatForDocument', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_createChatForDocument();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_createChatForDocument () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_createChatForDocument_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'createChatForDocument failed: unknown result';
  }

  getDocumentExtShareList (token, documentId, accessPolicy, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getDocumentExtShareList(token, documentId, accessPolicy, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getDocumentExtShareList (token, documentId, accessPolicy, filter, callback) {
    const params = {
      token: token,
      documentId: documentId,
      accessPolicy: accessPolicy,
      filter: filter
    };
    const args = new DocumentService_getDocumentExtShareList_args(params);
    try {
      this.output.writeMessageBegin('getDocumentExtShareList', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getDocumentExtShareList();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getDocumentExtShareList () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_getDocumentExtShareList_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getDocumentExtShareList failed: unknown result';
  }

  changeDocumentExtShare (token, documentId, accessPolicy, toAdd, toRemove) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_changeDocumentExtShare(token, documentId, accessPolicy, toAdd, toRemove, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_changeDocumentExtShare (token, documentId, accessPolicy, toAdd, toRemove, callback) {
    const params = {
      token: token,
      documentId: documentId,
      accessPolicy: accessPolicy,
      toAdd: toAdd,
      toRemove: toRemove
    };
    const args = new DocumentService_changeDocumentExtShare_args(params);
    try {
      this.output.writeMessageBegin('changeDocumentExtShare', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_changeDocumentExtShare();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_changeDocumentExtShare () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_changeDocumentExtShare_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'changeDocumentExtShare failed: unknown result';
  }

  changeAttachmentExtStatus (token, statusMap) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_changeAttachmentExtStatus(token, statusMap, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_changeAttachmentExtStatus (token, statusMap, callback) {
    const params = {
      token: token,
      statusMap: statusMap
    };
    const args = new DocumentService_changeAttachmentExtStatus_args(params);
    try {
      this.output.writeMessageBegin('changeAttachmentExtStatus', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_changeAttachmentExtStatus();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_changeAttachmentExtStatus () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_changeAttachmentExtStatus_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'changeAttachmentExtStatus failed: unknown result';
  }

  remindDocumentExecutor (token, cardId, comment, policy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_remindDocumentExecutor(token, cardId, comment, policy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_remindDocumentExecutor (token, cardId, comment, policy, callback) {
    const params = {
      token: token,
      cardId: cardId,
      comment: comment,
      policy: policy
    };
    const args = new DocumentService_remindDocumentExecutor_args(params);
    try {
      this.output.writeMessageBegin('remindDocumentExecutor', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_remindDocumentExecutor();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_remindDocumentExecutor () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_remindDocumentExecutor_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'remindDocumentExecutor failed: unknown result';
  }

  updateReassignResolution (token, cardId, resolution, policy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_updateReassignResolution(token, cardId, resolution, policy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_updateReassignResolution (token, cardId, resolution, policy, callback) {
    const params = {
      token: token,
      cardId: cardId,
      resolution: resolution,
      policy: policy
    };
    const args = new DocumentService_updateReassignResolution_args(params);
    try {
      this.output.writeMessageBegin('updateReassignResolution', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_updateReassignResolution();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_updateReassignResolution () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_updateReassignResolution_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'updateReassignResolution failed: unknown result';
  }

  updateSubStatusComment (token, docCommentId, comment, policy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_updateSubStatusComment(token, docCommentId, comment, policy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_updateSubStatusComment (token, docCommentId, comment, policy, callback) {
    const params = {
      token: token,
      docCommentId: docCommentId,
      comment: comment,
      policy: policy
    };
    const args = new DocumentService_updateSubStatusComment_args(params);
    try {
      this.output.writeMessageBegin('updateSubStatusComment', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_updateSubStatusComment();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_updateSubStatusComment () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_updateSubStatusComment_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'updateSubStatusComment failed: unknown result';
  }

  changeDocumentType (token, docId, startStageId, stages, contentItems, roles, patternVariables, accessPolicy, newRegNumber) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_changeDocumentType(token, docId, startStageId, stages, contentItems, roles, patternVariables, accessPolicy, newRegNumber, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_changeDocumentType (token, docId, startStageId, stages, contentItems, roles, patternVariables, accessPolicy, newRegNumber, callback) {
    const params = {
      token: token,
      docId: docId,
      startStageId: startStageId,
      stages: stages,
      contentItems: contentItems,
      roles: roles,
      patternVariables: patternVariables,
      accessPolicy: accessPolicy,
      newRegNumber: newRegNumber
    };
    const args = new DocumentService_changeDocumentType_args(params);
    try {
      this.output.writeMessageBegin('changeDocumentType', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_changeDocumentType();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_changeDocumentType () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_changeDocumentType_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'changeDocumentType failed: unknown result';
  }

  getDocumentRelationModel (token, docId, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getDocumentRelationModel(token, docId, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getDocumentRelationModel (token, docId, filter, callback) {
    const params = {
      token: token,
      docId: docId,
      filter: filter
    };
    const args = new DocumentService_getDocumentRelationModel_args(params);
    try {
      this.output.writeMessageBegin('getDocumentRelationModel', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getDocumentRelationModel();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getDocumentRelationModel () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_getDocumentRelationModel_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getDocumentRelationModel failed: unknown result';
  }

  getNewConvertedAttachmentVersion (token, prevAttId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getNewConvertedAttachmentVersion(token, prevAttId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getNewConvertedAttachmentVersion (token, prevAttId, callback) {
    const params = {
      token: token,
      prevAttId: prevAttId
    };
    const args = new DocumentService_getNewConvertedAttachmentVersion_args(params);
    try {
      this.output.writeMessageBegin('getNewConvertedAttachmentVersion', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getNewConvertedAttachmentVersion();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getNewConvertedAttachmentVersion () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_getNewConvertedAttachmentVersion_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getNewConvertedAttachmentVersion failed: unknown result';
  }

  exportAsXML (token, documentId, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_exportAsXML(token, documentId, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_exportAsXML (token, documentId, accessPolicy, callback) {
    const params = {
      token: token,
      documentId: documentId,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_exportAsXML_args(params);
    try {
      this.output.writeMessageBegin('exportAsXML', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_exportAsXML();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_exportAsXML () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_exportAsXML_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'exportAsXML failed: unknown result';
  }

  importFromXML (token, xml) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_importFromXML(token, xml, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_importFromXML (token, xml, callback) {
    const params = {
      token: token,
      xml: xml
    };
    const args = new DocumentService_importFromXML_args(params);
    try {
      this.output.writeMessageBegin('importFromXML', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_importFromXML();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_importFromXML () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_importFromXML_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'importFromXML failed: unknown result';
  }

  getDocContentItemsForChangeType (token, documentId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getDocContentItemsForChangeType(token, documentId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getDocContentItemsForChangeType (token, documentId, callback) {
    const params = {
      token: token,
      documentId: documentId
    };
    const args = new DocumentService_getDocContentItemsForChangeType_args(params);
    try {
      this.output.writeMessageBegin('getDocContentItemsForChangeType', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getDocContentItemsForChangeType();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getDocContentItemsForChangeType () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_getDocContentItemsForChangeType_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getDocContentItemsForChangeType failed: unknown result';
  }
};
//
// Autogenerated by Thrift Compiler (0.13.0)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//
if (typeof Int64 === 'undefined' && typeof require === 'function') {
  const Int64 = require('node-int64');
}


HBColumnType = {
  'TEXT' : 0,
  'NUMBER' : 1,
  'USER_CHOICE' : 2
};
ThriftTransportType = {
  'HTTP' : 0,
  'SOCKET' : 1
};
ThriftProtocolType = {
  'JSON' : 0,
  'BIN' : 1
};
HBValue = class {
  constructor(args) {
    this.id = null;
    this.value = null;
    this.user = null;
    this.type = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.value !== undefined && args.value !== null) {
        this.value = Thrift.copyMap(args.value, [null]);
      }
      if (args.user !== undefined && args.user !== null) {
        this.user = new UserOrGroup(args.user);
      }
      if (args.type !== undefined && args.type !== null) {
        this.type = args.type;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.MAP) {
          this.value = {};
          const _rtmp31 = input.readMapBegin();
          const _size0 = _rtmp31.size || 0;
          for (let _i2 = 0; _i2 < _size0; ++_i2) {
            if (_i2 > 0 ) {
              if (input.rstack.length > input.rpos[input.rpos.length -1] + 1) {
                input.rstack.pop();
              }
            }
            let key3 = null;
            let val4 = null;
            key3 = input.readString().value;
            val4 = input.readString().value;
            this.value[key3] = val4;
          }
          input.readMapEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.user = new UserOrGroup();
          this.user.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I32) {
          this.type = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('HBValue');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.value !== null && this.value !== undefined) {
      output.writeFieldBegin('value', Thrift.Type.MAP, 2);
      output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.STRING, Thrift.objectLength(this.value));
      for (let kiter5 in this.value) {
        if (this.value.hasOwnProperty(kiter5)) {
          let viter6 = this.value[kiter5];
          output.writeString(kiter5);
          output.writeString(viter6);
        }
      }
      output.writeMapEnd();
      output.writeFieldEnd();
    }
    if (this.user !== null && this.user !== undefined) {
      output.writeFieldBegin('user', Thrift.Type.STRUCT, 3);
      this.user.write(output);
      output.writeFieldEnd();
    }
    if (this.type !== null && this.type !== undefined) {
      output.writeFieldBegin('type', Thrift.Type.I32, 4);
      output.writeI32(this.type);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
HBRow = class {
  constructor(args) {
    this.id = null;
    this.order = null;
    this.values = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.order !== undefined && args.order !== null) {
        this.order = args.order;
      }
      if (args.values !== undefined && args.values !== null) {
        this.values = Thrift.copyMap(args.values, [HBValue]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I64) {
          this.order = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.MAP) {
          this.values = {};
          const _rtmp38 = input.readMapBegin();
          const _size7 = _rtmp38.size || 0;
          for (let _i9 = 0; _i9 < _size7; ++_i9) {
            if (_i9 > 0 ) {
              if (input.rstack.length > input.rpos[input.rpos.length -1] + 1) {
                input.rstack.pop();
              }
            }
            let key10 = null;
            let val11 = null;
            key10 = input.readString().value;
            val11 = new HBValue();
            val11.read(input);
            this.values[key10] = val11;
          }
          input.readMapEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('HBRow');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.order !== null && this.order !== undefined) {
      output.writeFieldBegin('order', Thrift.Type.I64, 2);
      output.writeI64(this.order);
      output.writeFieldEnd();
    }
    if (this.values !== null && this.values !== undefined) {
      output.writeFieldBegin('values', Thrift.Type.MAP, 3);
      output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.STRUCT, Thrift.objectLength(this.values));
      for (let kiter12 in this.values) {
        if (this.values.hasOwnProperty(kiter12)) {
          let viter13 = this.values[kiter12];
          output.writeString(kiter12);
          viter13.write(output);
        }
      }
      output.writeMapEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
HBColumn = class {
  constructor(args) {
    this.id = null;
    this.oName = null;
    this.requiredColumn = null;
    this.seqNum = null;
    this.searchable = null;
    this.columnType = null;
    this.orgId = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.oName !== undefined && args.oName !== null) {
        this.oName = args.oName;
      }
      if (args.requiredColumn !== undefined && args.requiredColumn !== null) {
        this.requiredColumn = args.requiredColumn;
      }
      if (args.seqNum !== undefined && args.seqNum !== null) {
        this.seqNum = args.seqNum;
      }
      if (args.searchable !== undefined && args.searchable !== null) {
        this.searchable = args.searchable;
      }
      if (args.columnType !== undefined && args.columnType !== null) {
        this.columnType = args.columnType;
      }
      if (args.orgId !== undefined && args.orgId !== null) {
        this.orgId = args.orgId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.oName = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.BOOL) {
          this.requiredColumn = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I32) {
          this.seqNum = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.BOOL) {
          this.searchable = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.I32) {
          this.columnType = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.STRING) {
          this.orgId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('HBColumn');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.oName !== null && this.oName !== undefined) {
      output.writeFieldBegin('oName', Thrift.Type.STRING, 2);
      output.writeString(this.oName);
      output.writeFieldEnd();
    }
    if (this.requiredColumn !== null && this.requiredColumn !== undefined) {
      output.writeFieldBegin('requiredColumn', Thrift.Type.BOOL, 3);
      output.writeBool(this.requiredColumn);
      output.writeFieldEnd();
    }
    if (this.seqNum !== null && this.seqNum !== undefined) {
      output.writeFieldBegin('seqNum', Thrift.Type.I32, 4);
      output.writeI32(this.seqNum);
      output.writeFieldEnd();
    }
    if (this.searchable !== null && this.searchable !== undefined) {
      output.writeFieldBegin('searchable', Thrift.Type.BOOL, 5);
      output.writeBool(this.searchable);
      output.writeFieldEnd();
    }
    if (this.columnType !== null && this.columnType !== undefined) {
      output.writeFieldBegin('columnType', Thrift.Type.I32, 6);
      output.writeI32(this.columnType);
      output.writeFieldEnd();
    }
    if (this.orgId !== null && this.orgId !== undefined) {
      output.writeFieldBegin('orgId', Thrift.Type.STRING, 7);
      output.writeString(this.orgId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
//
// Autogenerated by Thrift Compiler (0.13.0)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//
if (typeof Int64 === 'undefined' && typeof require === 'function') {
  const Int64 = require('node-int64');
}


ExecutionType = {
  'ANY_IMMEDIATELY' : 0,
  'ANY_WAIT_FOR_EXECUTORS' : 1,
  'ALL_EXECUTORS' : 2,
  'MOST_SET_DECISION' : 3
};
DocPatternStageRequirement = {
  'OPTIONAL' : 0,
  'REQUIRED' : 1,
  'PROHIBITED' : 2
};
AttachmentAction = {
  'PUBLISH_DRAFT' : 0,
  'IGNORE_DRAFT' : 1,
  'DELETE_DRAFT' : 2,
  'FIXATE_DRAFT' : 3
};
CloseWindowType = {
  'CLOSE' : 0,
  'NOT_CLOSE' : 1,
  'NOT_CLOSE_UPDATE' : 2
};
DocumentAccessPolicyType = {
  'ACCESS' : 0,
  'REGISTRY' : 1,
  'BY_ROLE' : 2,
  'EXTERNAL' : 3
};
DocumentIconType = {
  'ICON_DRAFT' : 0,
  'ICON_COMPLETE_CANCEL' : 1,
  'ICON_COMPLETE_EDITED' : 2,
  'ICON_COMPLETE' : 3,
  'ICON_IN_WORK_NO_MY_CANCEL' : 4,
  'ICON_IN_WORK_NO_MY_EDITED' : 5,
  'ICON_IN_WORK_NO_MY' : 6,
  'ICON_IN_WORK_EDITED' : 7,
  'ICON_IN_WORK_CANCELED' : 8,
  'ICON_IN_WORK' : 9,
  'ICON_IN_WORK_WARNING_EDITED' : 10,
  'ICON_IN_WORK_WARNING_CANCELED' : 11,
  'ICON_IN_WORK_WARNING' : 12,
  'ICON_IN_WORK_ERROR_EDITED' : 13,
  'ICON_IN_WORK_ERROR_CANCELED' : 14,
  'ICON_IN_WORK_ERROR' : 15,
  'ICON_ARCHIVE' : 16,
  'ICON_ERROR' : 17
};
PatternType = {
  'DOCUMENT' : 0,
  'DISCUSSION_FLOW' : 1,
  'DISCUSSION_QUESTION' : 2,
  'DISCUSSION_PROTOCOL' : 3
};
ContentItemShowType = {
  'SHORT' : 0,
  'FULL' : 1,
  'ALL' : 2
};
ContentItemShowPlace = {
  'INFO' : 0,
  'TAB' : 1,
  'CONTENT' : 2
};
ContentTableViewMode = {
  'TABLE' : 0,
  'BAND' : 1
};
ContentTableSelectMode = {
  'NONE' : 0,
  'SELECT' : 1,
  'MULTISELECT' : 2
};
ContentItemType = {
  'TEXT_FIELD' : 0,
  'COMBO_BOX' : 1,
  'USER_CHOICE' : 2,
  'CALENDAR' : 3,
  'TABLE' : 4,
  'SEPARATOR' : 5,
  'MULTILINE_TEXT_FIELD' : 6,
  'MARK' : 7,
  'CHECKBOX' : 8,
  'SWITCH_ITEM' : 9,
  'HTTP_LINK' : 10,
  'CALENDAR_RANGE' : 11,
  'CONTAINER' : 12,
  'HAND_BOOK' : 13,
  'ORG_STRUCTURE' : 14,
  'ATTACHMENT' : 15
};
VisibilityOfBookmarks = {
  'SHOW' : 0,
  'NOT_SHOW' : 1,
  'EDITING' : 2
};
DocPatternStageStatus = {
  'CREATED' : 0,
  'IN_PROGRESS' : 1,
  'CLOSED' : 2,
  'ARCHIVE' : 3
};
DocPatternStageSubStatus = {
  'DRAFT' : 0,
  'PROJECT' : 1,
  'CONFIRM' : 2,
  'SIGN' : 3,
  'IN_WORK' : 4,
  'IN_EXECUTION' : 5,
  'CLOSED' : 6,
  'ACTING' : 7,
  'CANCELED' : 8,
  'ARCHIVE' : 9,
  'REGISTRATION' : 10,
  'ON_REVISION' : 11,
  'EDITED' : 12
};
DocPatternStageExecPriority = {
  'PARALLEL' : 0,
  'SERIES' : 1
};
DocPatternStageActionType = {
  'VIEW' : 0,
  'CONFIRM' : 1,
  'SIGN' : 2,
  'PERFORM' : 3
};
DispatchState = {
  'INBOX' : 0,
  'OUTBOX' : 1
};
StageParamType = {
  'STRING' : 0,
  'PATTERN' : 1,
  'REPORT' : 2,
  'COMBOBOX' : 3,
  'CHECKBOX' : 4,
  'SCRIPT' : 5,
  'DATETIME' : 6,
  'JIRATIME' : 7,
  'PATTERN_TO_USER' : 8
};
DocumentExecutionOwnerType = {
  'AUTHOR' : 0,
  'RESPONSIBLE' : 1,
  'EXECUTOR' : 2,
  'VIEWER' : 3,
  'SPECTATOR' : 4,
  'SYSTEM' : 5,
  'ADDITIONAL_CONFIRMER' : 6,
  'PERIODICAL_DISABLE' : 7
};
CommentType = {
  'DECISION' : 0,
  'COMMENT' : 1,
  'LINK' : 2,
  'CHANGE_SUB_STATUS' : 3
};
ExecutionReassignType = {
  'ANY' : 0,
  'CONTROL' : 1,
  'ALL' : 2,
  'ALL_EQUAL' : 3,
  'GROUP' : 4,
  'GROUP_ONE_ENOUGH' : 5
};
DocumentExecutionStatus = {
  'OPEN' : 0,
  'CLOSED' : 1,
  'CLOSED_ADDITIONAL' : 2,
  'FORCED_CLOSURE' : 3,
  'AUTO_CLOSED' : 4,
  'REVOKED' : 5,
  'REMOVED' : 6,
  'NONE' : 7,
  'DISABLED' : 8,
  'SOFT_REMOVED' : 9
};
FilterReassign = {
  'REASSIGN_TO_ME' : 0,
  'MY_REASSIGN' : 1,
  'CONTROL' : 2,
  'ALL_MY_DOCUMENTS' : 3,
  'MY_DOCUMENTS_IN_WORK' : 4,
  'DRAFTS' : 5,
  'MY_COMPLETED_DOCUMENTS' : 6,
  'MY_RESPONSIBLE' : 7,
  'COMPLETED_DOCUMENTS' : 8,
  'UNCOMPLETED_DOCUMENTS' : 9
};
AttachmentType = {
  'ORIGINAL' : 0,
  'PDF' : 1,
  'PNG' : 2,
  'PDF_UNSECURED' : 3
};
AttachmentAccessMode = {
  'NOPREVIEW' : 0,
  'READONLY' : 1,
  'REVIEW' : 2,
  'EDIT' : 3
};
AttachmentExtStatus = {
  'PRIMARY' : 0,
  'SECONDARY' : 1,
  'CARD' : 2,
  'CONTENT' : 3
};
SignInSystem = {
  'NONE' : 0,
  'ALMEX' : 1,
  'EXTERNAL' : 2,
  'BOTH' : 3
};
DocRelationType = {
  'PARENT' : 0,
  'CHILD' : 1,
  'OTHER' : 2
};
DocumentExecutionTypeLink = {
  'ALL' : 0,
  'PARENT' : 1,
  'CHILD' : 2
};
ChangeType = {
  'ADD' : 0,
  'REPLACE' : 1,
  'REMOVE' : 2
};
HistoryLevel = {
  'INFO' : 0,
  'WARNING' : 1,
  'ERROR' : 2
};
TodayTaskType = {
  'ALL' : 0,
  'OPEN' : 1,
  'CLOSED' : 2,
  'EVENT' : 3,
  'MEETING' : 4
};
DocumentExecutionStatisticType = {
  'EXPIRED' : 0,
  'DEADLINE_AFTER_DAY' : 1,
  'NOT_SOON_DEADLINE' : 2
};
AggregationRequiredType = {
  'DOCUMENT' : 0,
  'DOC_COMMENT' : 1,
  'DOC_RELATION' : 2,
  'CONTENT_TAB' : 3,
  'SC' : 4,
  'DEADLINE_HISTORY' : 5,
  'ATTACHMENT' : 6,
  'REPORT_TEMPLATE' : 7,
  'DOC_PERMISSION' : 8,
  'REGISTRY_RULE' : 9,
  'REGISTRY_USERS' : 10,
  'REGISTRY_ACCOUNTS' : 11,
  'MATCHING_USER_GROUP' : 12,
  'CONTENT_HOLDER' : 13
};
AttachmentProcessingType = {
  'NONE' : 0,
  'DELETE' : 1,
  'PROCESS' : 2
};
AccessRule = class {
  constructor(args) {
    this.forAuthor = null;
    this.forResponsible = null;
    this.forExecutors = null;
    this.forUserOrGroup = null;
    this.forRole = null;
    this.allowList = null;
    this.allowRole = null;
    this.forAllDocView = null;
    if (args) {
      if (args.forAuthor !== undefined && args.forAuthor !== null) {
        this.forAuthor = args.forAuthor;
      }
      if (args.forResponsible !== undefined && args.forResponsible !== null) {
        this.forResponsible = args.forResponsible;
      }
      if (args.forExecutors !== undefined && args.forExecutors !== null) {
        this.forExecutors = args.forExecutors;
      }
      if (args.forUserOrGroup !== undefined && args.forUserOrGroup !== null) {
        this.forUserOrGroup = args.forUserOrGroup;
      }
      if (args.forRole !== undefined && args.forRole !== null) {
        this.forRole = args.forRole;
      }
      if (args.allowList !== undefined && args.allowList !== null) {
        this.allowList = Thrift.copyList(args.allowList, [UserOrGroup]);
      }
      if (args.allowRole !== undefined && args.allowRole !== null) {
        this.allowRole = Thrift.copyList(args.allowRole, [null]);
      }
      if (args.forAllDocView !== undefined && args.forAllDocView !== null) {
        this.forAllDocView = args.forAllDocView;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.BOOL) {
          this.forAuthor = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.BOOL) {
          this.forResponsible = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.BOOL) {
          this.forExecutors = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.BOOL) {
          this.forUserOrGroup = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.BOOL) {
          this.forRole = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.LIST) {
          this.allowList = [];
          const _rtmp31 = input.readListBegin();
          const _size0 = _rtmp31.size || 0;
          for (let _i2 = 0; _i2 < _size0; ++_i2) {
            let elem3 = null;
            elem3 = new UserOrGroup();
            elem3.read(input);
            this.allowList.push(elem3);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.SET) {
          this.allowRole = [];
          const _rtmp35 = input.readSetBegin();
          const _size4 = _rtmp35.size || 0;
          for (let _i6 = 0; _i6 < _size4; ++_i6) {
            let elem7 = null;
            elem7 = input.readString().value;
            this.allowRole.push(elem7);
          }
          input.readSetEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.BOOL) {
          this.forAllDocView = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AccessRule');
    if (this.forAuthor !== null && this.forAuthor !== undefined) {
      output.writeFieldBegin('forAuthor', Thrift.Type.BOOL, 1);
      output.writeBool(this.forAuthor);
      output.writeFieldEnd();
    }
    if (this.forResponsible !== null && this.forResponsible !== undefined) {
      output.writeFieldBegin('forResponsible', Thrift.Type.BOOL, 2);
      output.writeBool(this.forResponsible);
      output.writeFieldEnd();
    }
    if (this.forExecutors !== null && this.forExecutors !== undefined) {
      output.writeFieldBegin('forExecutors', Thrift.Type.BOOL, 3);
      output.writeBool(this.forExecutors);
      output.writeFieldEnd();
    }
    if (this.forUserOrGroup !== null && this.forUserOrGroup !== undefined) {
      output.writeFieldBegin('forUserOrGroup', Thrift.Type.BOOL, 4);
      output.writeBool(this.forUserOrGroup);
      output.writeFieldEnd();
    }
    if (this.forRole !== null && this.forRole !== undefined) {
      output.writeFieldBegin('forRole', Thrift.Type.BOOL, 5);
      output.writeBool(this.forRole);
      output.writeFieldEnd();
    }
    if (this.allowList !== null && this.allowList !== undefined) {
      output.writeFieldBegin('allowList', Thrift.Type.LIST, 6);
      output.writeListBegin(Thrift.Type.STRUCT, this.allowList.length);
      for (let iter8 in this.allowList) {
        if (this.allowList.hasOwnProperty(iter8)) {
          iter8 = this.allowList[iter8];
          iter8.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.allowRole !== null && this.allowRole !== undefined) {
      output.writeFieldBegin('allowRole', Thrift.Type.SET, 7);
      output.writeSetBegin(Thrift.Type.STRING, this.allowRole.length);
      for (let iter9 in this.allowRole) {
        if (this.allowRole.hasOwnProperty(iter9)) {
          iter9 = this.allowRole[iter9];
          output.writeString(iter9);
        }
      }
      output.writeSetEnd();
      output.writeFieldEnd();
    }
    if (this.forAllDocView !== null && this.forAllDocView !== undefined) {
      output.writeFieldBegin('forAllDocView', Thrift.Type.BOOL, 8);
      output.writeBool(this.forAllDocView);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternStagesLink = class {
  constructor(args) {
    this.id = null;
    this.parentStageId = null;
    this.childStageId = null;
    this.nameDocPatStageLink = null;
    this.descriptionDocPatStageLink = null;
    this.decision = null;
    this.graphicalParams = null;
    this.execType = null;
    this.movePriority = null;
    this.informUsers = null;
    this.accessRule = null;
    this.allowForCurUser = null;
    this.useByDefault = null;
    this.resolution = null;
    this.signature = null;
    this.autoExecute = null;
    this.jiraPeriod = null;
    this.comment = null;
    this.allowRepeatDecision = null;
    this.attachmentAction = null;
    this.orderLink = null;
    this.preFunctionId = null;
    this.closeWindowType = null;
    this.updateWindowInterval = null;
    this.attachmentForceConver = null;
    this.contentHolder = null;
    this.attachmentRequirement = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.parentStageId !== undefined && args.parentStageId !== null) {
        this.parentStageId = args.parentStageId;
      }
      if (args.childStageId !== undefined && args.childStageId !== null) {
        this.childStageId = args.childStageId;
      }
      if (args.nameDocPatStageLink !== undefined && args.nameDocPatStageLink !== null) {
        this.nameDocPatStageLink = args.nameDocPatStageLink;
      }
      if (args.descriptionDocPatStageLink !== undefined && args.descriptionDocPatStageLink !== null) {
        this.descriptionDocPatStageLink = args.descriptionDocPatStageLink;
      }
      if (args.decision !== undefined && args.decision !== null) {
        this.decision = args.decision;
      }
      if (args.graphicalParams !== undefined && args.graphicalParams !== null) {
        this.graphicalParams = args.graphicalParams;
      }
      if (args.execType !== undefined && args.execType !== null) {
        this.execType = args.execType;
      }
      if (args.movePriority !== undefined && args.movePriority !== null) {
        this.movePriority = args.movePriority;
      }
      if (args.informUsers !== undefined && args.informUsers !== null) {
        this.informUsers = Thrift.copyList(args.informUsers, [UserOrGroup]);
      }
      if (args.accessRule !== undefined && args.accessRule !== null) {
        this.accessRule = new AccessRule(args.accessRule);
      }
      if (args.allowForCurUser !== undefined && args.allowForCurUser !== null) {
        this.allowForCurUser = args.allowForCurUser;
      }
      if (args.useByDefault !== undefined && args.useByDefault !== null) {
        this.useByDefault = args.useByDefault;
      }
      if (args.resolution !== undefined && args.resolution !== null) {
        this.resolution = args.resolution;
      }
      if (args.signature !== undefined && args.signature !== null) {
        this.signature = args.signature;
      }
      if (args.autoExecute !== undefined && args.autoExecute !== null) {
        this.autoExecute = args.autoExecute;
      }
      if (args.jiraPeriod !== undefined && args.jiraPeriod !== null) {
        this.jiraPeriod = args.jiraPeriod;
      }
      if (args.comment !== undefined && args.comment !== null) {
        this.comment = args.comment;
      }
      if (args.allowRepeatDecision !== undefined && args.allowRepeatDecision !== null) {
        this.allowRepeatDecision = args.allowRepeatDecision;
      }
      if (args.attachmentAction !== undefined && args.attachmentAction !== null) {
        this.attachmentAction = args.attachmentAction;
      }
      if (args.orderLink !== undefined && args.orderLink !== null) {
        this.orderLink = args.orderLink;
      }
      if (args.preFunctionId !== undefined && args.preFunctionId !== null) {
        this.preFunctionId = new CompositeId(args.preFunctionId);
      }
      if (args.closeWindowType !== undefined && args.closeWindowType !== null) {
        this.closeWindowType = args.closeWindowType;
      }
      if (args.updateWindowInterval !== undefined && args.updateWindowInterval !== null) {
        this.updateWindowInterval = args.updateWindowInterval;
      }
      if (args.attachmentForceConver !== undefined && args.attachmentForceConver !== null) {
        this.attachmentForceConver = args.attachmentForceConver;
      }
      if (args.contentHolder !== undefined && args.contentHolder !== null) {
        this.contentHolder = new ContentHolder(args.contentHolder);
      }
      if (args.attachmentRequirement !== undefined && args.attachmentRequirement !== null) {
        this.attachmentRequirement = args.attachmentRequirement;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.parentStageId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.childStageId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.nameDocPatStageLink = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRING) {
          this.descriptionDocPatStageLink = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.STRING) {
          this.decision = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.STRING) {
          this.graphicalParams = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.I32) {
          this.execType = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 9:
        if (ftype == Thrift.Type.I32) {
          this.movePriority = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 10:
        if (ftype == Thrift.Type.LIST) {
          this.informUsers = [];
          const _rtmp311 = input.readListBegin();
          const _size10 = _rtmp311.size || 0;
          for (let _i12 = 0; _i12 < _size10; ++_i12) {
            let elem13 = null;
            elem13 = new UserOrGroup();
            elem13.read(input);
            this.informUsers.push(elem13);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 11:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessRule = new AccessRule();
          this.accessRule.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 12:
        if (ftype == Thrift.Type.BOOL) {
          this.allowForCurUser = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 13:
        if (ftype == Thrift.Type.BOOL) {
          this.useByDefault = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 14:
        if (ftype == Thrift.Type.I32) {
          this.resolution = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 15:
        if (ftype == Thrift.Type.I32) {
          this.signature = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 16:
        if (ftype == Thrift.Type.BOOL) {
          this.autoExecute = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 17:
        if (ftype == Thrift.Type.STRING) {
          this.jiraPeriod = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 18:
        if (ftype == Thrift.Type.STRING) {
          this.comment = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 19:
        if (ftype == Thrift.Type.BOOL) {
          this.allowRepeatDecision = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 20:
        if (ftype == Thrift.Type.I32) {
          this.attachmentAction = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 21:
        if (ftype == Thrift.Type.I32) {
          this.orderLink = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 22:
        if (ftype == Thrift.Type.STRUCT) {
          this.preFunctionId = new CompositeId();
          this.preFunctionId.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 23:
        if (ftype == Thrift.Type.I32) {
          this.closeWindowType = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 24:
        if (ftype == Thrift.Type.I32) {
          this.updateWindowInterval = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 25:
        if (ftype == Thrift.Type.BOOL) {
          this.attachmentForceConver = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 26:
        if (ftype == Thrift.Type.STRUCT) {
          this.contentHolder = new ContentHolder();
          this.contentHolder.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 27:
        if (ftype == Thrift.Type.I32) {
          this.attachmentRequirement = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternStagesLink');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.parentStageId !== null && this.parentStageId !== undefined) {
      output.writeFieldBegin('parentStageId', Thrift.Type.STRING, 2);
      output.writeString(this.parentStageId);
      output.writeFieldEnd();
    }
    if (this.childStageId !== null && this.childStageId !== undefined) {
      output.writeFieldBegin('childStageId', Thrift.Type.STRING, 3);
      output.writeString(this.childStageId);
      output.writeFieldEnd();
    }
    if (this.nameDocPatStageLink !== null && this.nameDocPatStageLink !== undefined) {
      output.writeFieldBegin('nameDocPatStageLink', Thrift.Type.STRING, 4);
      output.writeString(this.nameDocPatStageLink);
      output.writeFieldEnd();
    }
    if (this.descriptionDocPatStageLink !== null && this.descriptionDocPatStageLink !== undefined) {
      output.writeFieldBegin('descriptionDocPatStageLink', Thrift.Type.STRING, 5);
      output.writeString(this.descriptionDocPatStageLink);
      output.writeFieldEnd();
    }
    if (this.decision !== null && this.decision !== undefined) {
      output.writeFieldBegin('decision', Thrift.Type.STRING, 6);
      output.writeString(this.decision);
      output.writeFieldEnd();
    }
    if (this.graphicalParams !== null && this.graphicalParams !== undefined) {
      output.writeFieldBegin('graphicalParams', Thrift.Type.STRING, 7);
      output.writeString(this.graphicalParams);
      output.writeFieldEnd();
    }
    if (this.execType !== null && this.execType !== undefined) {
      output.writeFieldBegin('execType', Thrift.Type.I32, 8);
      output.writeI32(this.execType);
      output.writeFieldEnd();
    }
    if (this.movePriority !== null && this.movePriority !== undefined) {
      output.writeFieldBegin('movePriority', Thrift.Type.I32, 9);
      output.writeI32(this.movePriority);
      output.writeFieldEnd();
    }
    if (this.informUsers !== null && this.informUsers !== undefined) {
      output.writeFieldBegin('informUsers', Thrift.Type.LIST, 10);
      output.writeListBegin(Thrift.Type.STRUCT, this.informUsers.length);
      for (let iter14 in this.informUsers) {
        if (this.informUsers.hasOwnProperty(iter14)) {
          iter14 = this.informUsers[iter14];
          iter14.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.accessRule !== null && this.accessRule !== undefined) {
      output.writeFieldBegin('accessRule', Thrift.Type.STRUCT, 11);
      this.accessRule.write(output);
      output.writeFieldEnd();
    }
    if (this.allowForCurUser !== null && this.allowForCurUser !== undefined) {
      output.writeFieldBegin('allowForCurUser', Thrift.Type.BOOL, 12);
      output.writeBool(this.allowForCurUser);
      output.writeFieldEnd();
    }
    if (this.useByDefault !== null && this.useByDefault !== undefined) {
      output.writeFieldBegin('useByDefault', Thrift.Type.BOOL, 13);
      output.writeBool(this.useByDefault);
      output.writeFieldEnd();
    }
    if (this.resolution !== null && this.resolution !== undefined) {
      output.writeFieldBegin('resolution', Thrift.Type.I32, 14);
      output.writeI32(this.resolution);
      output.writeFieldEnd();
    }
    if (this.signature !== null && this.signature !== undefined) {
      output.writeFieldBegin('signature', Thrift.Type.I32, 15);
      output.writeI32(this.signature);
      output.writeFieldEnd();
    }
    if (this.autoExecute !== null && this.autoExecute !== undefined) {
      output.writeFieldBegin('autoExecute', Thrift.Type.BOOL, 16);
      output.writeBool(this.autoExecute);
      output.writeFieldEnd();
    }
    if (this.jiraPeriod !== null && this.jiraPeriod !== undefined) {
      output.writeFieldBegin('jiraPeriod', Thrift.Type.STRING, 17);
      output.writeString(this.jiraPeriod);
      output.writeFieldEnd();
    }
    if (this.comment !== null && this.comment !== undefined) {
      output.writeFieldBegin('comment', Thrift.Type.STRING, 18);
      output.writeString(this.comment);
      output.writeFieldEnd();
    }
    if (this.allowRepeatDecision !== null && this.allowRepeatDecision !== undefined) {
      output.writeFieldBegin('allowRepeatDecision', Thrift.Type.BOOL, 19);
      output.writeBool(this.allowRepeatDecision);
      output.writeFieldEnd();
    }
    if (this.attachmentAction !== null && this.attachmentAction !== undefined) {
      output.writeFieldBegin('attachmentAction', Thrift.Type.I32, 20);
      output.writeI32(this.attachmentAction);
      output.writeFieldEnd();
    }
    if (this.orderLink !== null && this.orderLink !== undefined) {
      output.writeFieldBegin('orderLink', Thrift.Type.I32, 21);
      output.writeI32(this.orderLink);
      output.writeFieldEnd();
    }
    if (this.preFunctionId !== null && this.preFunctionId !== undefined) {
      output.writeFieldBegin('preFunctionId', Thrift.Type.STRUCT, 22);
      this.preFunctionId.write(output);
      output.writeFieldEnd();
    }
    if (this.closeWindowType !== null && this.closeWindowType !== undefined) {
      output.writeFieldBegin('closeWindowType', Thrift.Type.I32, 23);
      output.writeI32(this.closeWindowType);
      output.writeFieldEnd();
    }
    if (this.updateWindowInterval !== null && this.updateWindowInterval !== undefined) {
      output.writeFieldBegin('updateWindowInterval', Thrift.Type.I32, 24);
      output.writeI32(this.updateWindowInterval);
      output.writeFieldEnd();
    }
    if (this.attachmentForceConver !== null && this.attachmentForceConver !== undefined) {
      output.writeFieldBegin('attachmentForceConver', Thrift.Type.BOOL, 25);
      output.writeBool(this.attachmentForceConver);
      output.writeFieldEnd();
    }
    if (this.contentHolder !== null && this.contentHolder !== undefined) {
      output.writeFieldBegin('contentHolder', Thrift.Type.STRUCT, 26);
      this.contentHolder.write(output);
      output.writeFieldEnd();
    }
    if (this.attachmentRequirement !== null && this.attachmentRequirement !== undefined) {
      output.writeFieldBegin('attachmentRequirement', Thrift.Type.I32, 27);
      output.writeI32(this.attachmentRequirement);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
StageLinkAction = class {
  constructor(args) {
    this.type = null;
    this.userOrGroupId = null;
    this.execId = null;
    this.additionConfirmation = null;
    this.cancelDecision = null;
    this.link = null;
    this.transfer = null;
    if (args) {
      if (args.type !== undefined && args.type !== null) {
        this.type = args.type;
      }
      if (args.userOrGroupId !== undefined && args.userOrGroupId !== null) {
        this.userOrGroupId = args.userOrGroupId;
      }
      if (args.execId !== undefined && args.execId !== null) {
        this.execId = args.execId;
      }
      if (args.additionConfirmation !== undefined && args.additionConfirmation !== null) {
        this.additionConfirmation = args.additionConfirmation;
      }
      if (args.cancelDecision !== undefined && args.cancelDecision !== null) {
        this.cancelDecision = args.cancelDecision;
      }
      if (args.link !== undefined && args.link !== null) {
        this.link = new DocumentPatternStagesLink(args.link);
      }
      if (args.transfer !== undefined && args.transfer !== null) {
        this.transfer = args.transfer;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I32) {
          this.type = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.userOrGroupId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.execId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.BOOL) {
          this.additionConfirmation = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.BOOL) {
          this.cancelDecision = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.STRUCT) {
          this.link = new DocumentPatternStagesLink();
          this.link.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.BOOL) {
          this.transfer = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('StageLinkAction');
    if (this.type !== null && this.type !== undefined) {
      output.writeFieldBegin('type', Thrift.Type.I32, 1);
      output.writeI32(this.type);
      output.writeFieldEnd();
    }
    if (this.userOrGroupId !== null && this.userOrGroupId !== undefined) {
      output.writeFieldBegin('userOrGroupId', Thrift.Type.STRING, 2);
      output.writeString(this.userOrGroupId);
      output.writeFieldEnd();
    }
    if (this.execId !== null && this.execId !== undefined) {
      output.writeFieldBegin('execId', Thrift.Type.STRING, 3);
      output.writeString(this.execId);
      output.writeFieldEnd();
    }
    if (this.additionConfirmation !== null && this.additionConfirmation !== undefined) {
      output.writeFieldBegin('additionConfirmation', Thrift.Type.BOOL, 4);
      output.writeBool(this.additionConfirmation);
      output.writeFieldEnd();
    }
    if (this.cancelDecision !== null && this.cancelDecision !== undefined) {
      output.writeFieldBegin('cancelDecision', Thrift.Type.BOOL, 5);
      output.writeBool(this.cancelDecision);
      output.writeFieldEnd();
    }
    if (this.link !== null && this.link !== undefined) {
      output.writeFieldBegin('link', Thrift.Type.STRUCT, 6);
      this.link.write(output);
      output.writeFieldEnd();
    }
    if (this.transfer !== null && this.transfer !== undefined) {
      output.writeFieldBegin('transfer', Thrift.Type.BOOL, 7);
      output.writeBool(this.transfer);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocPermissions = class {
  constructor(args) {
    this.actions = null;
    this.onlineEdit = null;
    this.onlineComment = null;
    this.editDoc = null;
    this.attachmentAdd = null;
    this.attachmentDelete = null;
    this.changeContent = null;
    this.addExecutors = null;
    this.allowAdditionalConf = null;
    this.allowReassign = null;
    this.generateNumber = null;
    this.shareDocument = null;
    this.shareDocumentRevoke = null;
    this.updateResponsible = null;
    this.updateSC = null;
    this.allowRepeatReassign = null;
    this.exList = null;
    this.attachmentSign = null;
    if (args) {
      if (args.actions !== undefined && args.actions !== null) {
        this.actions = Thrift.copyList(args.actions, [StageLinkAction]);
      }
      if (args.onlineEdit !== undefined && args.onlineEdit !== null) {
        this.onlineEdit = args.onlineEdit;
      }
      if (args.onlineComment !== undefined && args.onlineComment !== null) {
        this.onlineComment = args.onlineComment;
      }
      if (args.editDoc !== undefined && args.editDoc !== null) {
        this.editDoc = args.editDoc;
      }
      if (args.attachmentAdd !== undefined && args.attachmentAdd !== null) {
        this.attachmentAdd = args.attachmentAdd;
      }
      if (args.attachmentDelete !== undefined && args.attachmentDelete !== null) {
        this.attachmentDelete = args.attachmentDelete;
      }
      if (args.changeContent !== undefined && args.changeContent !== null) {
        this.changeContent = args.changeContent;
      }
      if (args.addExecutors !== undefined && args.addExecutors !== null) {
        this.addExecutors = args.addExecutors;
      }
      if (args.allowAdditionalConf !== undefined && args.allowAdditionalConf !== null) {
        this.allowAdditionalConf = args.allowAdditionalConf;
      }
      if (args.allowReassign !== undefined && args.allowReassign !== null) {
        this.allowReassign = args.allowReassign;
      }
      if (args.generateNumber !== undefined && args.generateNumber !== null) {
        this.generateNumber = args.generateNumber;
      }
      if (args.shareDocument !== undefined && args.shareDocument !== null) {
        this.shareDocument = args.shareDocument;
      }
      if (args.shareDocumentRevoke !== undefined && args.shareDocumentRevoke !== null) {
        this.shareDocumentRevoke = args.shareDocumentRevoke;
      }
      if (args.updateResponsible !== undefined && args.updateResponsible !== null) {
        this.updateResponsible = args.updateResponsible;
      }
      if (args.updateSC !== undefined && args.updateSC !== null) {
        this.updateSC = args.updateSC;
      }
      if (args.allowRepeatReassign !== undefined && args.allowRepeatReassign !== null) {
        this.allowRepeatReassign = args.allowRepeatReassign;
      }
      if (args.exList !== undefined && args.exList !== null) {
        this.exList = Thrift.copyList(args.exList, [null]);
      }
      if (args.attachmentSign !== undefined && args.attachmentSign !== null) {
        this.attachmentSign = args.attachmentSign;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.LIST) {
          this.actions = [];
          const _rtmp316 = input.readListBegin();
          const _size15 = _rtmp316.size || 0;
          for (let _i17 = 0; _i17 < _size15; ++_i17) {
            let elem18 = null;
            elem18 = new StageLinkAction();
            elem18.read(input);
            this.actions.push(elem18);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.BOOL) {
          this.onlineEdit = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.BOOL) {
          this.onlineComment = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.BOOL) {
          this.editDoc = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.BOOL) {
          this.attachmentAdd = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.BOOL) {
          this.attachmentDelete = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.BOOL) {
          this.changeContent = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.BOOL) {
          this.addExecutors = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 9:
        if (ftype == Thrift.Type.BOOL) {
          this.allowAdditionalConf = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 10:
        if (ftype == Thrift.Type.BOOL) {
          this.allowReassign = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 11:
        if (ftype == Thrift.Type.BOOL) {
          this.generateNumber = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 12:
        if (ftype == Thrift.Type.BOOL) {
          this.shareDocument = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 13:
        if (ftype == Thrift.Type.BOOL) {
          this.shareDocumentRevoke = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 14:
        if (ftype == Thrift.Type.BOOL) {
          this.updateResponsible = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 15:
        if (ftype == Thrift.Type.BOOL) {
          this.updateSC = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 16:
        if (ftype == Thrift.Type.BOOL) {
          this.allowRepeatReassign = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 17:
        if (ftype == Thrift.Type.LIST) {
          this.exList = [];
          const _rtmp320 = input.readListBegin();
          const _size19 = _rtmp320.size || 0;
          for (let _i21 = 0; _i21 < _size19; ++_i21) {
            let elem22 = null;
            elem22 = new PreconditionException();
            elem22.read(input);
            this.exList.push(elem22);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 18:
        if (ftype == Thrift.Type.BOOL) {
          this.attachmentSign = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocPermissions');
    if (this.actions !== null && this.actions !== undefined) {
      output.writeFieldBegin('actions', Thrift.Type.LIST, 1);
      output.writeListBegin(Thrift.Type.STRUCT, this.actions.length);
      for (let iter23 in this.actions) {
        if (this.actions.hasOwnProperty(iter23)) {
          iter23 = this.actions[iter23];
          iter23.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.onlineEdit !== null && this.onlineEdit !== undefined) {
      output.writeFieldBegin('onlineEdit', Thrift.Type.BOOL, 2);
      output.writeBool(this.onlineEdit);
      output.writeFieldEnd();
    }
    if (this.onlineComment !== null && this.onlineComment !== undefined) {
      output.writeFieldBegin('onlineComment', Thrift.Type.BOOL, 3);
      output.writeBool(this.onlineComment);
      output.writeFieldEnd();
    }
    if (this.editDoc !== null && this.editDoc !== undefined) {
      output.writeFieldBegin('editDoc', Thrift.Type.BOOL, 4);
      output.writeBool(this.editDoc);
      output.writeFieldEnd();
    }
    if (this.attachmentAdd !== null && this.attachmentAdd !== undefined) {
      output.writeFieldBegin('attachmentAdd', Thrift.Type.BOOL, 5);
      output.writeBool(this.attachmentAdd);
      output.writeFieldEnd();
    }
    if (this.attachmentDelete !== null && this.attachmentDelete !== undefined) {
      output.writeFieldBegin('attachmentDelete', Thrift.Type.BOOL, 6);
      output.writeBool(this.attachmentDelete);
      output.writeFieldEnd();
    }
    if (this.changeContent !== null && this.changeContent !== undefined) {
      output.writeFieldBegin('changeContent', Thrift.Type.BOOL, 7);
      output.writeBool(this.changeContent);
      output.writeFieldEnd();
    }
    if (this.addExecutors !== null && this.addExecutors !== undefined) {
      output.writeFieldBegin('addExecutors', Thrift.Type.BOOL, 8);
      output.writeBool(this.addExecutors);
      output.writeFieldEnd();
    }
    if (this.allowAdditionalConf !== null && this.allowAdditionalConf !== undefined) {
      output.writeFieldBegin('allowAdditionalConf', Thrift.Type.BOOL, 9);
      output.writeBool(this.allowAdditionalConf);
      output.writeFieldEnd();
    }
    if (this.allowReassign !== null && this.allowReassign !== undefined) {
      output.writeFieldBegin('allowReassign', Thrift.Type.BOOL, 10);
      output.writeBool(this.allowReassign);
      output.writeFieldEnd();
    }
    if (this.generateNumber !== null && this.generateNumber !== undefined) {
      output.writeFieldBegin('generateNumber', Thrift.Type.BOOL, 11);
      output.writeBool(this.generateNumber);
      output.writeFieldEnd();
    }
    if (this.shareDocument !== null && this.shareDocument !== undefined) {
      output.writeFieldBegin('shareDocument', Thrift.Type.BOOL, 12);
      output.writeBool(this.shareDocument);
      output.writeFieldEnd();
    }
    if (this.shareDocumentRevoke !== null && this.shareDocumentRevoke !== undefined) {
      output.writeFieldBegin('shareDocumentRevoke', Thrift.Type.BOOL, 13);
      output.writeBool(this.shareDocumentRevoke);
      output.writeFieldEnd();
    }
    if (this.updateResponsible !== null && this.updateResponsible !== undefined) {
      output.writeFieldBegin('updateResponsible', Thrift.Type.BOOL, 14);
      output.writeBool(this.updateResponsible);
      output.writeFieldEnd();
    }
    if (this.updateSC !== null && this.updateSC !== undefined) {
      output.writeFieldBegin('updateSC', Thrift.Type.BOOL, 15);
      output.writeBool(this.updateSC);
      output.writeFieldEnd();
    }
    if (this.allowRepeatReassign !== null && this.allowRepeatReassign !== undefined) {
      output.writeFieldBegin('allowRepeatReassign', Thrift.Type.BOOL, 16);
      output.writeBool(this.allowRepeatReassign);
      output.writeFieldEnd();
    }
    if (this.exList !== null && this.exList !== undefined) {
      output.writeFieldBegin('exList', Thrift.Type.LIST, 17);
      output.writeListBegin(Thrift.Type.STRUCT, this.exList.length);
      for (let iter24 in this.exList) {
        if (this.exList.hasOwnProperty(iter24)) {
          iter24 = this.exList[iter24];
          iter24.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.attachmentSign !== null && this.attachmentSign !== undefined) {
      output.writeFieldBegin('attachmentSign', Thrift.Type.BOOL, 18);
      output.writeBool(this.attachmentSign);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentAccessPolicy = class {
  constructor(args) {
    this.type = null;
    this.policyId = null;
    if (args) {
      if (args.type !== undefined && args.type !== null) {
        this.type = args.type;
      }
      if (args.policyId !== undefined && args.policyId !== null) {
        this.policyId = args.policyId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I32) {
          this.type = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.policyId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentAccessPolicy');
    if (this.type !== null && this.type !== undefined) {
      output.writeFieldBegin('type', Thrift.Type.I32, 1);
      output.writeI32(this.type);
      output.writeFieldEnd();
    }
    if (this.policyId !== null && this.policyId !== undefined) {
      output.writeFieldBegin('policyId', Thrift.Type.STRING, 2);
      output.writeString(this.policyId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternGroup = class {
  constructor(args) {
    this.id = null;
    this.nameDocPatGroup = null;
    this.descriptionDocPatGroup = null;
    this.category = null;
    this.enableWorkWithSC = null;
    this.order = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.nameDocPatGroup !== undefined && args.nameDocPatGroup !== null) {
        this.nameDocPatGroup = args.nameDocPatGroup;
      }
      if (args.descriptionDocPatGroup !== undefined && args.descriptionDocPatGroup !== null) {
        this.descriptionDocPatGroup = args.descriptionDocPatGroup;
      }
      if (args.category !== undefined && args.category !== null) {
        this.category = args.category;
      }
      if (args.enableWorkWithSC !== undefined && args.enableWorkWithSC !== null) {
        this.enableWorkWithSC = args.enableWorkWithSC;
      }
      if (args.order !== undefined && args.order !== null) {
        this.order = args.order;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.nameDocPatGroup = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.descriptionDocPatGroup = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.category = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.BOOL) {
          this.enableWorkWithSC = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.I32) {
          this.order = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternGroup');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.nameDocPatGroup !== null && this.nameDocPatGroup !== undefined) {
      output.writeFieldBegin('nameDocPatGroup', Thrift.Type.STRING, 2);
      output.writeString(this.nameDocPatGroup);
      output.writeFieldEnd();
    }
    if (this.descriptionDocPatGroup !== null && this.descriptionDocPatGroup !== undefined) {
      output.writeFieldBegin('descriptionDocPatGroup', Thrift.Type.STRING, 3);
      output.writeString(this.descriptionDocPatGroup);
      output.writeFieldEnd();
    }
    if (this.category !== null && this.category !== undefined) {
      output.writeFieldBegin('category', Thrift.Type.STRING, 4);
      output.writeString(this.category);
      output.writeFieldEnd();
    }
    if (this.enableWorkWithSC !== null && this.enableWorkWithSC !== undefined) {
      output.writeFieldBegin('enableWorkWithSC', Thrift.Type.BOOL, 5);
      output.writeBool(this.enableWorkWithSC);
      output.writeFieldEnd();
    }
    if (this.order !== null && this.order !== undefined) {
      output.writeFieldBegin('order', Thrift.Type.I32, 6);
      output.writeI32(this.order);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ContentItemHBValue = class {
  constructor(args) {
    this.row = null;
    this.column = null;
    this.originalColumn = null;
    if (args) {
      if (args.row !== undefined && args.row !== null) {
        this.row = new HBRow(args.row);
      }
      if (args.column !== undefined && args.column !== null) {
        this.column = new HBColumn(args.column);
      }
      if (args.originalColumn !== undefined && args.originalColumn !== null) {
        this.originalColumn = new HBColumn(args.originalColumn);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.row = new HBRow();
          this.row.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.column = new HBColumn();
          this.column.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.originalColumn = new HBColumn();
          this.originalColumn.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ContentItemHBValue');
    if (this.row !== null && this.row !== undefined) {
      output.writeFieldBegin('row', Thrift.Type.STRUCT, 1);
      this.row.write(output);
      output.writeFieldEnd();
    }
    if (this.column !== null && this.column !== undefined) {
      output.writeFieldBegin('column', Thrift.Type.STRUCT, 2);
      this.column.write(output);
      output.writeFieldEnd();
    }
    if (this.originalColumn !== null && this.originalColumn !== undefined) {
      output.writeFieldBegin('originalColumn', Thrift.Type.STRUCT, 3);
      this.originalColumn.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ContentItemValue = class {
  constructor(args) {
    this.strValue = null;
    this.hbValue = null;
    this.strValue2 = null;
    if (args) {
      if (args.strValue !== undefined && args.strValue !== null) {
        this.strValue = args.strValue;
      }
      if (args.hbValue !== undefined && args.hbValue !== null) {
        this.hbValue = new ContentItemHBValue(args.hbValue);
      }
      if (args.strValue2 !== undefined && args.strValue2 !== null) {
        this.strValue2 = args.strValue2;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.strValue = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.hbValue = new ContentItemHBValue();
          this.hbValue.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.strValue2 = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ContentItemValue');
    if (this.strValue !== null && this.strValue !== undefined) {
      output.writeFieldBegin('strValue', Thrift.Type.STRING, 1);
      output.writeString(this.strValue);
      output.writeFieldEnd();
    }
    if (this.hbValue !== null && this.hbValue !== undefined) {
      output.writeFieldBegin('hbValue', Thrift.Type.STRUCT, 2);
      this.hbValue.write(output);
      output.writeFieldEnd();
    }
    if (this.strValue2 !== null && this.strValue2 !== undefined) {
      output.writeFieldBegin('strValue2', Thrift.Type.STRING, 3);
      output.writeString(this.strValue2);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ContentTableDefinition = class {
  constructor(args) {
    this.id = null;
    this.viewMode = null;
    this.selectMode = null;
    this.height = null;
    this.rowHeight = null;
    this.columnDefenition = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.viewMode !== undefined && args.viewMode !== null) {
        this.viewMode = args.viewMode;
      }
      if (args.selectMode !== undefined && args.selectMode !== null) {
        this.selectMode = args.selectMode;
      }
      if (args.height !== undefined && args.height !== null) {
        this.height = args.height;
      }
      if (args.rowHeight !== undefined && args.rowHeight !== null) {
        this.rowHeight = args.rowHeight;
      }
      if (args.columnDefenition !== undefined && args.columnDefenition !== null) {
        this.columnDefenition = Thrift.copyList(args.columnDefenition, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.viewMode = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I32) {
          this.selectMode = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.height = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRING) {
          this.rowHeight = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.LIST) {
          this.columnDefenition = [];
          const _rtmp326 = input.readListBegin();
          const _size25 = _rtmp326.size || 0;
          for (let _i27 = 0; _i27 < _size25; ++_i27) {
            let elem28 = null;
            elem28 = new ContentItem();
            elem28.read(input);
            this.columnDefenition.push(elem28);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ContentTableDefinition');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.viewMode !== null && this.viewMode !== undefined) {
      output.writeFieldBegin('viewMode', Thrift.Type.I32, 2);
      output.writeI32(this.viewMode);
      output.writeFieldEnd();
    }
    if (this.selectMode !== null && this.selectMode !== undefined) {
      output.writeFieldBegin('selectMode', Thrift.Type.I32, 3);
      output.writeI32(this.selectMode);
      output.writeFieldEnd();
    }
    if (this.height !== null && this.height !== undefined) {
      output.writeFieldBegin('height', Thrift.Type.STRING, 4);
      output.writeString(this.height);
      output.writeFieldEnd();
    }
    if (this.rowHeight !== null && this.rowHeight !== undefined) {
      output.writeFieldBegin('rowHeight', Thrift.Type.STRING, 5);
      output.writeString(this.rowHeight);
      output.writeFieldEnd();
    }
    if (this.columnDefenition !== null && this.columnDefenition !== undefined) {
      output.writeFieldBegin('columnDefenition', Thrift.Type.LIST, 6);
      output.writeListBegin(Thrift.Type.STRUCT, this.columnDefenition.length);
      for (let iter29 in this.columnDefenition) {
        if (this.columnDefenition.hasOwnProperty(iter29)) {
          iter29 = this.columnDefenition[iter29];
          iter29.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ContentItem = class {
  constructor(args) {
    this.id = null;
    this.oName = null;
    this.value = null;
    this.type = null;
    this.search = null;
    this.requared = null;
    this.readOnly = null;
    this.order = null;
    this.descriptionContItem = null;
    this.showType = null;
    this.tabId = null;
    this.key = null;
    this.showPlace = null;
    this.copyValue = null;
    this.handBookId = null;
    this.users = null;
    this.tableDefenition = null;
    this.tableKey = null;
    this.rowNumber = null;
    this.childItems = null;
    this.availableUsers = null;
    this.tMask = null;
    this.listView = null;
    this.visible = null;
    this.visibleScript = null;
    this.readonlyScript = null;
    this.onChangeScript = null;
    this.fields = null;
    this.attributes = null;
    this.tMaskDesc = null;
    this.displayedName = null;
    this.department = null;
    this.attachment = null;
    this.quickFill = null;
    this.onlyActiveUser = null;
    this.maxUserCount = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.oName !== undefined && args.oName !== null) {
        this.oName = args.oName;
      }
      if (args.value !== undefined && args.value !== null) {
        this.value = new ContentItemValue(args.value);
      }
      if (args.type !== undefined && args.type !== null) {
        this.type = args.type;
      }
      if (args.search !== undefined && args.search !== null) {
        this.search = args.search;
      }
      if (args.requared !== undefined && args.requared !== null) {
        this.requared = args.requared;
      }
      if (args.readOnly !== undefined && args.readOnly !== null) {
        this.readOnly = args.readOnly;
      }
      if (args.order !== undefined && args.order !== null) {
        this.order = args.order;
      }
      if (args.descriptionContItem !== undefined && args.descriptionContItem !== null) {
        this.descriptionContItem = args.descriptionContItem;
      }
      if (args.showType !== undefined && args.showType !== null) {
        this.showType = args.showType;
      }
      if (args.tabId !== undefined && args.tabId !== null) {
        this.tabId = args.tabId;
      }
      if (args.key !== undefined && args.key !== null) {
        this.key = args.key;
      }
      if (args.showPlace !== undefined && args.showPlace !== null) {
        this.showPlace = args.showPlace;
      }
      if (args.copyValue !== undefined && args.copyValue !== null) {
        this.copyValue = args.copyValue;
      }
      if (args.handBookId !== undefined && args.handBookId !== null) {
        this.handBookId = args.handBookId;
      }
      if (args.users !== undefined && args.users !== null) {
        this.users = Thrift.copyList(args.users, [UserOrGroup]);
      }
      if (args.tableDefenition !== undefined && args.tableDefenition !== null) {
        this.tableDefenition = new ContentTableDefinition(args.tableDefenition);
      }
      if (args.tableKey !== undefined && args.tableKey !== null) {
        this.tableKey = args.tableKey;
      }
      if (args.rowNumber !== undefined && args.rowNumber !== null) {
        this.rowNumber = args.rowNumber;
      }
      if (args.childItems !== undefined && args.childItems !== null) {
        this.childItems = Thrift.copyList(args.childItems, [null]);
      }
      if (args.availableUsers !== undefined && args.availableUsers !== null) {
        this.availableUsers = Thrift.copyList(args.availableUsers, [UserOrGroup]);
      }
      if (args.tMask !== undefined && args.tMask !== null) {
        this.tMask = args.tMask;
      }
      if (args.listView !== undefined && args.listView !== null) {
        this.listView = args.listView;
      }
      if (args.visible !== undefined && args.visible !== null) {
        this.visible = args.visible;
      }
      if (args.visibleScript !== undefined && args.visibleScript !== null) {
        this.visibleScript = args.visibleScript;
      }
      if (args.readonlyScript !== undefined && args.readonlyScript !== null) {
        this.readonlyScript = args.readonlyScript;
      }
      if (args.onChangeScript !== undefined && args.onChangeScript !== null) {
        this.onChangeScript = args.onChangeScript;
      }
      if (args.fields !== undefined && args.fields !== null) {
        this.fields = Thrift.copyList(args.fields, [null]);
      }
      if (args.attributes !== undefined && args.attributes !== null) {
        this.attributes = args.attributes;
      }
      if (args.tMaskDesc !== undefined && args.tMaskDesc !== null) {
        this.tMaskDesc = args.tMaskDesc;
      }
      if (args.displayedName !== undefined && args.displayedName !== null) {
        this.displayedName = args.displayedName;
      }
      if (args.department !== undefined && args.department !== null) {
        this.department = new Department(args.department);
      }
      if (args.attachment !== undefined && args.attachment !== null) {
        this.attachment = new Attachment(args.attachment);
      }
      if (args.quickFill !== undefined && args.quickFill !== null) {
        this.quickFill = args.quickFill;
      }
      if (args.onlyActiveUser !== undefined && args.onlyActiveUser !== null) {
        this.onlyActiveUser = args.onlyActiveUser;
      }
      if (args.maxUserCount !== undefined && args.maxUserCount !== null) {
        this.maxUserCount = args.maxUserCount;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.oName = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.value = new ContentItemValue();
          this.value.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I32) {
          this.type = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.BOOL) {
          this.search = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.BOOL) {
          this.requared = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.BOOL) {
          this.readOnly = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.I32) {
          this.order = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 9:
        if (ftype == Thrift.Type.STRING) {
          this.descriptionContItem = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 10:
        if (ftype == Thrift.Type.I32) {
          this.showType = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 11:
        if (ftype == Thrift.Type.STRING) {
          this.tabId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 12:
        if (ftype == Thrift.Type.STRING) {
          this.key = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 13:
        if (ftype == Thrift.Type.I32) {
          this.showPlace = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 14:
        if (ftype == Thrift.Type.BOOL) {
          this.copyValue = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 15:
        if (ftype == Thrift.Type.STRING) {
          this.handBookId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 16:
        if (ftype == Thrift.Type.LIST) {
          this.users = [];
          const _rtmp331 = input.readListBegin();
          const _size30 = _rtmp331.size || 0;
          for (let _i32 = 0; _i32 < _size30; ++_i32) {
            let elem33 = null;
            elem33 = new UserOrGroup();
            elem33.read(input);
            this.users.push(elem33);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 17:
        if (ftype == Thrift.Type.STRUCT) {
          this.tableDefenition = new ContentTableDefinition();
          this.tableDefenition.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 18:
        if (ftype == Thrift.Type.STRING) {
          this.tableKey = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 19:
        if (ftype == Thrift.Type.I32) {
          this.rowNumber = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 20:
        if (ftype == Thrift.Type.LIST) {
          this.childItems = [];
          const _rtmp335 = input.readListBegin();
          const _size34 = _rtmp335.size || 0;
          for (let _i36 = 0; _i36 < _size34; ++_i36) {
            let elem37 = null;
            elem37 = new ContentItem();
            elem37.read(input);
            this.childItems.push(elem37);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 21:
        if (ftype == Thrift.Type.LIST) {
          this.availableUsers = [];
          const _rtmp339 = input.readListBegin();
          const _size38 = _rtmp339.size || 0;
          for (let _i40 = 0; _i40 < _size38; ++_i40) {
            let elem41 = null;
            elem41 = new UserOrGroup();
            elem41.read(input);
            this.availableUsers.push(elem41);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 22:
        if (ftype == Thrift.Type.STRING) {
          this.tMask = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 23:
        if (ftype == Thrift.Type.BOOL) {
          this.listView = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 24:
        if (ftype == Thrift.Type.BOOL) {
          this.visible = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 25:
        if (ftype == Thrift.Type.STRING) {
          this.visibleScript = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 26:
        if (ftype == Thrift.Type.STRING) {
          this.readonlyScript = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 27:
        if (ftype == Thrift.Type.STRING) {
          this.onChangeScript = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 28:
        if (ftype == Thrift.Type.LIST) {
          this.fields = [];
          const _rtmp343 = input.readListBegin();
          const _size42 = _rtmp343.size || 0;
          for (let _i44 = 0; _i44 < _size42; ++_i44) {
            let elem45 = null;
            elem45 = input.readString().value;
            this.fields.push(elem45);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 29:
        if (ftype == Thrift.Type.STRING) {
          this.attributes = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 30:
        if (ftype == Thrift.Type.STRING) {
          this.tMaskDesc = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 31:
        if (ftype == Thrift.Type.STRING) {
          this.displayedName = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 32:
        if (ftype == Thrift.Type.STRUCT) {
          this.department = new Department();
          this.department.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 33:
        if (ftype == Thrift.Type.STRUCT) {
          this.attachment = new Attachment();
          this.attachment.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 34:
        if (ftype == Thrift.Type.BOOL) {
          this.quickFill = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 35:
        if (ftype == Thrift.Type.BOOL) {
          this.onlyActiveUser = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 36:
        if (ftype == Thrift.Type.I32) {
          this.maxUserCount = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ContentItem');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.oName !== null && this.oName !== undefined) {
      output.writeFieldBegin('oName', Thrift.Type.STRING, 2);
      output.writeString(this.oName);
      output.writeFieldEnd();
    }
    if (this.value !== null && this.value !== undefined) {
      output.writeFieldBegin('value', Thrift.Type.STRUCT, 3);
      this.value.write(output);
      output.writeFieldEnd();
    }
    if (this.type !== null && this.type !== undefined) {
      output.writeFieldBegin('type', Thrift.Type.I32, 4);
      output.writeI32(this.type);
      output.writeFieldEnd();
    }
    if (this.search !== null && this.search !== undefined) {
      output.writeFieldBegin('search', Thrift.Type.BOOL, 5);
      output.writeBool(this.search);
      output.writeFieldEnd();
    }
    if (this.requared !== null && this.requared !== undefined) {
      output.writeFieldBegin('requared', Thrift.Type.BOOL, 6);
      output.writeBool(this.requared);
      output.writeFieldEnd();
    }
    if (this.readOnly !== null && this.readOnly !== undefined) {
      output.writeFieldBegin('readOnly', Thrift.Type.BOOL, 7);
      output.writeBool(this.readOnly);
      output.writeFieldEnd();
    }
    if (this.order !== null && this.order !== undefined) {
      output.writeFieldBegin('order', Thrift.Type.I32, 8);
      output.writeI32(this.order);
      output.writeFieldEnd();
    }
    if (this.descriptionContItem !== null && this.descriptionContItem !== undefined) {
      output.writeFieldBegin('descriptionContItem', Thrift.Type.STRING, 9);
      output.writeString(this.descriptionContItem);
      output.writeFieldEnd();
    }
    if (this.showType !== null && this.showType !== undefined) {
      output.writeFieldBegin('showType', Thrift.Type.I32, 10);
      output.writeI32(this.showType);
      output.writeFieldEnd();
    }
    if (this.tabId !== null && this.tabId !== undefined) {
      output.writeFieldBegin('tabId', Thrift.Type.STRING, 11);
      output.writeString(this.tabId);
      output.writeFieldEnd();
    }
    if (this.key !== null && this.key !== undefined) {
      output.writeFieldBegin('key', Thrift.Type.STRING, 12);
      output.writeString(this.key);
      output.writeFieldEnd();
    }
    if (this.showPlace !== null && this.showPlace !== undefined) {
      output.writeFieldBegin('showPlace', Thrift.Type.I32, 13);
      output.writeI32(this.showPlace);
      output.writeFieldEnd();
    }
    if (this.copyValue !== null && this.copyValue !== undefined) {
      output.writeFieldBegin('copyValue', Thrift.Type.BOOL, 14);
      output.writeBool(this.copyValue);
      output.writeFieldEnd();
    }
    if (this.handBookId !== null && this.handBookId !== undefined) {
      output.writeFieldBegin('handBookId', Thrift.Type.STRING, 15);
      output.writeString(this.handBookId);
      output.writeFieldEnd();
    }
    if (this.users !== null && this.users !== undefined) {
      output.writeFieldBegin('users', Thrift.Type.LIST, 16);
      output.writeListBegin(Thrift.Type.STRUCT, this.users.length);
      for (let iter46 in this.users) {
        if (this.users.hasOwnProperty(iter46)) {
          iter46 = this.users[iter46];
          iter46.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.tableDefenition !== null && this.tableDefenition !== undefined) {
      output.writeFieldBegin('tableDefenition', Thrift.Type.STRUCT, 17);
      this.tableDefenition.write(output);
      output.writeFieldEnd();
    }
    if (this.tableKey !== null && this.tableKey !== undefined) {
      output.writeFieldBegin('tableKey', Thrift.Type.STRING, 18);
      output.writeString(this.tableKey);
      output.writeFieldEnd();
    }
    if (this.rowNumber !== null && this.rowNumber !== undefined) {
      output.writeFieldBegin('rowNumber', Thrift.Type.I32, 19);
      output.writeI32(this.rowNumber);
      output.writeFieldEnd();
    }
    if (this.childItems !== null && this.childItems !== undefined) {
      output.writeFieldBegin('childItems', Thrift.Type.LIST, 20);
      output.writeListBegin(Thrift.Type.STRUCT, this.childItems.length);
      for (let iter47 in this.childItems) {
        if (this.childItems.hasOwnProperty(iter47)) {
          iter47 = this.childItems[iter47];
          iter47.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.availableUsers !== null && this.availableUsers !== undefined) {
      output.writeFieldBegin('availableUsers', Thrift.Type.LIST, 21);
      output.writeListBegin(Thrift.Type.STRUCT, this.availableUsers.length);
      for (let iter48 in this.availableUsers) {
        if (this.availableUsers.hasOwnProperty(iter48)) {
          iter48 = this.availableUsers[iter48];
          iter48.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.tMask !== null && this.tMask !== undefined) {
      output.writeFieldBegin('tMask', Thrift.Type.STRING, 22);
      output.writeString(this.tMask);
      output.writeFieldEnd();
    }
    if (this.listView !== null && this.listView !== undefined) {
      output.writeFieldBegin('listView', Thrift.Type.BOOL, 23);
      output.writeBool(this.listView);
      output.writeFieldEnd();
    }
    if (this.visible !== null && this.visible !== undefined) {
      output.writeFieldBegin('visible', Thrift.Type.BOOL, 24);
      output.writeBool(this.visible);
      output.writeFieldEnd();
    }
    if (this.visibleScript !== null && this.visibleScript !== undefined) {
      output.writeFieldBegin('visibleScript', Thrift.Type.STRING, 25);
      output.writeString(this.visibleScript);
      output.writeFieldEnd();
    }
    if (this.readonlyScript !== null && this.readonlyScript !== undefined) {
      output.writeFieldBegin('readonlyScript', Thrift.Type.STRING, 26);
      output.writeString(this.readonlyScript);
      output.writeFieldEnd();
    }
    if (this.onChangeScript !== null && this.onChangeScript !== undefined) {
      output.writeFieldBegin('onChangeScript', Thrift.Type.STRING, 27);
      output.writeString(this.onChangeScript);
      output.writeFieldEnd();
    }
    if (this.fields !== null && this.fields !== undefined) {
      output.writeFieldBegin('fields', Thrift.Type.LIST, 28);
      output.writeListBegin(Thrift.Type.STRING, this.fields.length);
      for (let iter49 in this.fields) {
        if (this.fields.hasOwnProperty(iter49)) {
          iter49 = this.fields[iter49];
          output.writeString(iter49);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.attributes !== null && this.attributes !== undefined) {
      output.writeFieldBegin('attributes', Thrift.Type.STRING, 29);
      output.writeString(this.attributes);
      output.writeFieldEnd();
    }
    if (this.tMaskDesc !== null && this.tMaskDesc !== undefined) {
      output.writeFieldBegin('tMaskDesc', Thrift.Type.STRING, 30);
      output.writeString(this.tMaskDesc);
      output.writeFieldEnd();
    }
    if (this.displayedName !== null && this.displayedName !== undefined) {
      output.writeFieldBegin('displayedName', Thrift.Type.STRING, 31);
      output.writeString(this.displayedName);
      output.writeFieldEnd();
    }
    if (this.department !== null && this.department !== undefined) {
      output.writeFieldBegin('department', Thrift.Type.STRUCT, 32);
      this.department.write(output);
      output.writeFieldEnd();
    }
    if (this.attachment !== null && this.attachment !== undefined) {
      output.writeFieldBegin('attachment', Thrift.Type.STRUCT, 33);
      this.attachment.write(output);
      output.writeFieldEnd();
    }
    if (this.quickFill !== null && this.quickFill !== undefined) {
      output.writeFieldBegin('quickFill', Thrift.Type.BOOL, 34);
      output.writeBool(this.quickFill);
      output.writeFieldEnd();
    }
    if (this.onlyActiveUser !== null && this.onlyActiveUser !== undefined) {
      output.writeFieldBegin('onlyActiveUser', Thrift.Type.BOOL, 35);
      output.writeBool(this.onlyActiveUser);
      output.writeFieldEnd();
    }
    if (this.maxUserCount !== null && this.maxUserCount !== undefined) {
      output.writeFieldBegin('maxUserCount', Thrift.Type.I32, 36);
      output.writeI32(this.maxUserCount);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
SimpleDocumentPatternOrGroup = class {
  constructor(args) {
    this.id = null;
    this.oName = null;
    this.oDescription = null;
    this.ids = null;
    this.order = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.oName !== undefined && args.oName !== null) {
        this.oName = args.oName;
      }
      if (args.oDescription !== undefined && args.oDescription !== null) {
        this.oDescription = args.oDescription;
      }
      if (args.ids !== undefined && args.ids !== null) {
        this.ids = Thrift.copyList(args.ids, [null]);
      }
      if (args.order !== undefined && args.order !== null) {
        this.order = args.order;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.oName = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.oDescription = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.LIST) {
          this.ids = [];
          const _rtmp351 = input.readListBegin();
          const _size50 = _rtmp351.size || 0;
          for (let _i52 = 0; _i52 < _size50; ++_i52) {
            let elem53 = null;
            elem53 = input.readString().value;
            this.ids.push(elem53);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.I32) {
          this.order = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('SimpleDocumentPatternOrGroup');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.oName !== null && this.oName !== undefined) {
      output.writeFieldBegin('oName', Thrift.Type.STRING, 2);
      output.writeString(this.oName);
      output.writeFieldEnd();
    }
    if (this.oDescription !== null && this.oDescription !== undefined) {
      output.writeFieldBegin('oDescription', Thrift.Type.STRING, 3);
      output.writeString(this.oDescription);
      output.writeFieldEnd();
    }
    if (this.ids !== null && this.ids !== undefined) {
      output.writeFieldBegin('ids', Thrift.Type.LIST, 4);
      output.writeListBegin(Thrift.Type.STRING, this.ids.length);
      for (let iter54 in this.ids) {
        if (this.ids.hasOwnProperty(iter54)) {
          iter54 = this.ids[iter54];
          output.writeString(iter54);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.order !== null && this.order !== undefined) {
      output.writeFieldBegin('order', Thrift.Type.I32, 5);
      output.writeI32(this.order);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
NomenclatureNumber = class {
  constructor(args) {
    this.id = null;
    this.oName = null;
    this.numberPattern = null;
    this.currentSequenceValue = null;
    this.accountId = null;
    this.account = null;
    this.nomenclatureGroup = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.oName !== undefined && args.oName !== null) {
        this.oName = args.oName;
      }
      if (args.numberPattern !== undefined && args.numberPattern !== null) {
        this.numberPattern = args.numberPattern;
      }
      if (args.currentSequenceValue !== undefined && args.currentSequenceValue !== null) {
        this.currentSequenceValue = args.currentSequenceValue;
      }
      if (args.accountId !== undefined && args.accountId !== null) {
        this.accountId = args.accountId;
      }
      if (args.account !== undefined && args.account !== null) {
        this.account = new Account(args.account);
      }
      if (args.nomenclatureGroup !== undefined && args.nomenclatureGroup !== null) {
        this.nomenclatureGroup = new NomenclatureGroup(args.nomenclatureGroup);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.oName = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.numberPattern = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I64) {
          this.currentSequenceValue = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRING) {
          this.accountId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.STRUCT) {
          this.account = new Account();
          this.account.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.STRUCT) {
          this.nomenclatureGroup = new NomenclatureGroup();
          this.nomenclatureGroup.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('NomenclatureNumber');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.oName !== null && this.oName !== undefined) {
      output.writeFieldBegin('oName', Thrift.Type.STRING, 2);
      output.writeString(this.oName);
      output.writeFieldEnd();
    }
    if (this.numberPattern !== null && this.numberPattern !== undefined) {
      output.writeFieldBegin('numberPattern', Thrift.Type.STRING, 3);
      output.writeString(this.numberPattern);
      output.writeFieldEnd();
    }
    if (this.currentSequenceValue !== null && this.currentSequenceValue !== undefined) {
      output.writeFieldBegin('currentSequenceValue', Thrift.Type.I64, 4);
      output.writeI64(this.currentSequenceValue);
      output.writeFieldEnd();
    }
    if (this.accountId !== null && this.accountId !== undefined) {
      output.writeFieldBegin('accountId', Thrift.Type.STRING, 5);
      output.writeString(this.accountId);
      output.writeFieldEnd();
    }
    if (this.account !== null && this.account !== undefined) {
      output.writeFieldBegin('account', Thrift.Type.STRUCT, 6);
      this.account.write(output);
      output.writeFieldEnd();
    }
    if (this.nomenclatureGroup !== null && this.nomenclatureGroup !== undefined) {
      output.writeFieldBegin('nomenclatureGroup', Thrift.Type.STRUCT, 7);
      this.nomenclatureGroup.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
NomenclatureGroup = class {
  constructor(args) {
    this.id = null;
    this.oName = null;
    this.code = null;
    this.storageTerm = null;
    this.articleNumber = null;
    this.remark = null;
    this.nomenclatureNumbers = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.oName !== undefined && args.oName !== null) {
        this.oName = args.oName;
      }
      if (args.code !== undefined && args.code !== null) {
        this.code = args.code;
      }
      if (args.storageTerm !== undefined && args.storageTerm !== null) {
        this.storageTerm = args.storageTerm;
      }
      if (args.articleNumber !== undefined && args.articleNumber !== null) {
        this.articleNumber = args.articleNumber;
      }
      if (args.remark !== undefined && args.remark !== null) {
        this.remark = args.remark;
      }
      if (args.nomenclatureNumbers !== undefined && args.nomenclatureNumbers !== null) {
        this.nomenclatureNumbers = Thrift.copyList(args.nomenclatureNumbers, [NomenclatureNumber]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.oName = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.code = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.storageTerm = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRING) {
          this.articleNumber = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.STRING) {
          this.remark = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.LIST) {
          this.nomenclatureNumbers = [];
          const _rtmp356 = input.readListBegin();
          const _size55 = _rtmp356.size || 0;
          for (let _i57 = 0; _i57 < _size55; ++_i57) {
            let elem58 = null;
            elem58 = new NomenclatureNumber();
            elem58.read(input);
            this.nomenclatureNumbers.push(elem58);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('NomenclatureGroup');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.oName !== null && this.oName !== undefined) {
      output.writeFieldBegin('oName', Thrift.Type.STRING, 2);
      output.writeString(this.oName);
      output.writeFieldEnd();
    }
    if (this.code !== null && this.code !== undefined) {
      output.writeFieldBegin('code', Thrift.Type.STRING, 3);
      output.writeString(this.code);
      output.writeFieldEnd();
    }
    if (this.storageTerm !== null && this.storageTerm !== undefined) {
      output.writeFieldBegin('storageTerm', Thrift.Type.STRING, 4);
      output.writeString(this.storageTerm);
      output.writeFieldEnd();
    }
    if (this.articleNumber !== null && this.articleNumber !== undefined) {
      output.writeFieldBegin('articleNumber', Thrift.Type.STRING, 5);
      output.writeString(this.articleNumber);
      output.writeFieldEnd();
    }
    if (this.remark !== null && this.remark !== undefined) {
      output.writeFieldBegin('remark', Thrift.Type.STRING, 6);
      output.writeString(this.remark);
      output.writeFieldEnd();
    }
    if (this.nomenclatureNumbers !== null && this.nomenclatureNumbers !== undefined) {
      output.writeFieldBegin('nomenclatureNumbers', Thrift.Type.LIST, 7);
      output.writeListBegin(Thrift.Type.STRUCT, this.nomenclatureNumbers.length);
      for (let iter59 in this.nomenclatureNumbers) {
        if (this.nomenclatureNumbers.hasOwnProperty(iter59)) {
          iter59 = this.nomenclatureNumbers[iter59];
          iter59.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPattern = class {
  constructor(args) {
    this.id = null;
    this.nameDocPattern = null;
    this.descriptionDocPattern = null;
    this.creatorId = null;
    this.modifierId = null;
    this.createDate = null;
    this.modifiedDate = null;
    this.deleteDate = null;
    this.content = null;
    this.isValidState = null;
    this.nomenclatureNumber = null;
    this.documentPatternGroup = null;
    this.scMask = null;
    this.controlDate = null;
    this.useSC = null;
    this.useDocNumber = null;
    this.needGeneratePdf = null;
    this.order = null;
    this.startDocNumber = null;
    this.currentDocNumber = null;
    this.account = null;
    this.hideAuto = null;
    this.hideExt = null;
    this.meetingPattern = null;
    this.patternType = null;
    this.autoGenerateDocName = null;
    this.docNamePattern = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.nameDocPattern !== undefined && args.nameDocPattern !== null) {
        this.nameDocPattern = args.nameDocPattern;
      }
      if (args.descriptionDocPattern !== undefined && args.descriptionDocPattern !== null) {
        this.descriptionDocPattern = args.descriptionDocPattern;
      }
      if (args.creatorId !== undefined && args.creatorId !== null) {
        this.creatorId = args.creatorId;
      }
      if (args.modifierId !== undefined && args.modifierId !== null) {
        this.modifierId = args.modifierId;
      }
      if (args.createDate !== undefined && args.createDate !== null) {
        this.createDate = args.createDate;
      }
      if (args.modifiedDate !== undefined && args.modifiedDate !== null) {
        this.modifiedDate = args.modifiedDate;
      }
      if (args.deleteDate !== undefined && args.deleteDate !== null) {
        this.deleteDate = args.deleteDate;
      }
      if (args.content !== undefined && args.content !== null) {
        this.content = Thrift.copyList(args.content, [ContentItem]);
      }
      if (args.isValidState !== undefined && args.isValidState !== null) {
        this.isValidState = args.isValidState;
      }
      if (args.nomenclatureNumber !== undefined && args.nomenclatureNumber !== null) {
        this.nomenclatureNumber = new NomenclatureNumber(args.nomenclatureNumber);
      }
      if (args.documentPatternGroup !== undefined && args.documentPatternGroup !== null) {
        this.documentPatternGroup = new DocumentPatternGroup(args.documentPatternGroup);
      }
      if (args.scMask !== undefined && args.scMask !== null) {
        this.scMask = args.scMask;
      }
      if (args.controlDate !== undefined && args.controlDate !== null) {
        this.controlDate = args.controlDate;
      }
      if (args.useSC !== undefined && args.useSC !== null) {
        this.useSC = args.useSC;
      }
      if (args.useDocNumber !== undefined && args.useDocNumber !== null) {
        this.useDocNumber = args.useDocNumber;
      }
      if (args.needGeneratePdf !== undefined && args.needGeneratePdf !== null) {
        this.needGeneratePdf = args.needGeneratePdf;
      }
      if (args.order !== undefined && args.order !== null) {
        this.order = args.order;
      }
      if (args.startDocNumber !== undefined && args.startDocNumber !== null) {
        this.startDocNumber = args.startDocNumber;
      }
      if (args.currentDocNumber !== undefined && args.currentDocNumber !== null) {
        this.currentDocNumber = args.currentDocNumber;
      }
      if (args.account !== undefined && args.account !== null) {
        this.account = new Account(args.account);
      }
      if (args.hideAuto !== undefined && args.hideAuto !== null) {
        this.hideAuto = args.hideAuto;
      }
      if (args.hideExt !== undefined && args.hideExt !== null) {
        this.hideExt = args.hideExt;
      }
      if (args.meetingPattern !== undefined && args.meetingPattern !== null) {
        this.meetingPattern = new DocumentPattern(args.meetingPattern);
      }
      if (args.patternType !== undefined && args.patternType !== null) {
        this.patternType = args.patternType;
      }
      if (args.autoGenerateDocName !== undefined && args.autoGenerateDocName !== null) {
        this.autoGenerateDocName = args.autoGenerateDocName;
      }
      if (args.docNamePattern !== undefined && args.docNamePattern !== null) {
        this.docNamePattern = args.docNamePattern;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.nameDocPattern = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.descriptionDocPattern = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.creatorId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRING) {
          this.modifierId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.I64) {
          this.createDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.I64) {
          this.modifiedDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.I64) {
          this.deleteDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 9:
        if (ftype == Thrift.Type.LIST) {
          this.content = [];
          const _rtmp361 = input.readListBegin();
          const _size60 = _rtmp361.size || 0;
          for (let _i62 = 0; _i62 < _size60; ++_i62) {
            let elem63 = null;
            elem63 = new ContentItem();
            elem63.read(input);
            this.content.push(elem63);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 10:
        if (ftype == Thrift.Type.BOOL) {
          this.isValidState = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 11:
        if (ftype == Thrift.Type.STRUCT) {
          this.nomenclatureNumber = new NomenclatureNumber();
          this.nomenclatureNumber.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 12:
        if (ftype == Thrift.Type.STRUCT) {
          this.documentPatternGroup = new DocumentPatternGroup();
          this.documentPatternGroup.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 13:
        if (ftype == Thrift.Type.STRING) {
          this.scMask = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 14:
        if (ftype == Thrift.Type.STRING) {
          this.controlDate = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 15:
        if (ftype == Thrift.Type.BOOL) {
          this.useSC = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 16:
        if (ftype == Thrift.Type.BOOL) {
          this.useDocNumber = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 17:
        if (ftype == Thrift.Type.BOOL) {
          this.needGeneratePdf = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 18:
        if (ftype == Thrift.Type.I32) {
          this.order = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 19:
        if (ftype == Thrift.Type.I64) {
          this.startDocNumber = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 20:
        if (ftype == Thrift.Type.I64) {
          this.currentDocNumber = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 21:
        if (ftype == Thrift.Type.STRUCT) {
          this.account = new Account();
          this.account.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 22:
        if (ftype == Thrift.Type.BOOL) {
          this.hideAuto = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 23:
        if (ftype == Thrift.Type.BOOL) {
          this.hideExt = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 24:
        if (ftype == Thrift.Type.STRUCT) {
          this.meetingPattern = new DocumentPattern();
          this.meetingPattern.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 25:
        if (ftype == Thrift.Type.I32) {
          this.patternType = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 26:
        if (ftype == Thrift.Type.BOOL) {
          this.autoGenerateDocName = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 27:
        if (ftype == Thrift.Type.STRING) {
          this.docNamePattern = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPattern');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.nameDocPattern !== null && this.nameDocPattern !== undefined) {
      output.writeFieldBegin('nameDocPattern', Thrift.Type.STRING, 2);
      output.writeString(this.nameDocPattern);
      output.writeFieldEnd();
    }
    if (this.descriptionDocPattern !== null && this.descriptionDocPattern !== undefined) {
      output.writeFieldBegin('descriptionDocPattern', Thrift.Type.STRING, 3);
      output.writeString(this.descriptionDocPattern);
      output.writeFieldEnd();
    }
    if (this.creatorId !== null && this.creatorId !== undefined) {
      output.writeFieldBegin('creatorId', Thrift.Type.STRING, 4);
      output.writeString(this.creatorId);
      output.writeFieldEnd();
    }
    if (this.modifierId !== null && this.modifierId !== undefined) {
      output.writeFieldBegin('modifierId', Thrift.Type.STRING, 5);
      output.writeString(this.modifierId);
      output.writeFieldEnd();
    }
    if (this.createDate !== null && this.createDate !== undefined) {
      output.writeFieldBegin('createDate', Thrift.Type.I64, 6);
      output.writeI64(this.createDate);
      output.writeFieldEnd();
    }
    if (this.modifiedDate !== null && this.modifiedDate !== undefined) {
      output.writeFieldBegin('modifiedDate', Thrift.Type.I64, 7);
      output.writeI64(this.modifiedDate);
      output.writeFieldEnd();
    }
    if (this.deleteDate !== null && this.deleteDate !== undefined) {
      output.writeFieldBegin('deleteDate', Thrift.Type.I64, 8);
      output.writeI64(this.deleteDate);
      output.writeFieldEnd();
    }
    if (this.content !== null && this.content !== undefined) {
      output.writeFieldBegin('content', Thrift.Type.LIST, 9);
      output.writeListBegin(Thrift.Type.STRUCT, this.content.length);
      for (let iter64 in this.content) {
        if (this.content.hasOwnProperty(iter64)) {
          iter64 = this.content[iter64];
          iter64.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.isValidState !== null && this.isValidState !== undefined) {
      output.writeFieldBegin('isValidState', Thrift.Type.BOOL, 10);
      output.writeBool(this.isValidState);
      output.writeFieldEnd();
    }
    if (this.nomenclatureNumber !== null && this.nomenclatureNumber !== undefined) {
      output.writeFieldBegin('nomenclatureNumber', Thrift.Type.STRUCT, 11);
      this.nomenclatureNumber.write(output);
      output.writeFieldEnd();
    }
    if (this.documentPatternGroup !== null && this.documentPatternGroup !== undefined) {
      output.writeFieldBegin('documentPatternGroup', Thrift.Type.STRUCT, 12);
      this.documentPatternGroup.write(output);
      output.writeFieldEnd();
    }
    if (this.scMask !== null && this.scMask !== undefined) {
      output.writeFieldBegin('scMask', Thrift.Type.STRING, 13);
      output.writeString(this.scMask);
      output.writeFieldEnd();
    }
    if (this.controlDate !== null && this.controlDate !== undefined) {
      output.writeFieldBegin('controlDate', Thrift.Type.STRING, 14);
      output.writeString(this.controlDate);
      output.writeFieldEnd();
    }
    if (this.useSC !== null && this.useSC !== undefined) {
      output.writeFieldBegin('useSC', Thrift.Type.BOOL, 15);
      output.writeBool(this.useSC);
      output.writeFieldEnd();
    }
    if (this.useDocNumber !== null && this.useDocNumber !== undefined) {
      output.writeFieldBegin('useDocNumber', Thrift.Type.BOOL, 16);
      output.writeBool(this.useDocNumber);
      output.writeFieldEnd();
    }
    if (this.needGeneratePdf !== null && this.needGeneratePdf !== undefined) {
      output.writeFieldBegin('needGeneratePdf', Thrift.Type.BOOL, 17);
      output.writeBool(this.needGeneratePdf);
      output.writeFieldEnd();
    }
    if (this.order !== null && this.order !== undefined) {
      output.writeFieldBegin('order', Thrift.Type.I32, 18);
      output.writeI32(this.order);
      output.writeFieldEnd();
    }
    if (this.startDocNumber !== null && this.startDocNumber !== undefined) {
      output.writeFieldBegin('startDocNumber', Thrift.Type.I64, 19);
      output.writeI64(this.startDocNumber);
      output.writeFieldEnd();
    }
    if (this.currentDocNumber !== null && this.currentDocNumber !== undefined) {
      output.writeFieldBegin('currentDocNumber', Thrift.Type.I64, 20);
      output.writeI64(this.currentDocNumber);
      output.writeFieldEnd();
    }
    if (this.account !== null && this.account !== undefined) {
      output.writeFieldBegin('account', Thrift.Type.STRUCT, 21);
      this.account.write(output);
      output.writeFieldEnd();
    }
    if (this.hideAuto !== null && this.hideAuto !== undefined) {
      output.writeFieldBegin('hideAuto', Thrift.Type.BOOL, 22);
      output.writeBool(this.hideAuto);
      output.writeFieldEnd();
    }
    if (this.hideExt !== null && this.hideExt !== undefined) {
      output.writeFieldBegin('hideExt', Thrift.Type.BOOL, 23);
      output.writeBool(this.hideExt);
      output.writeFieldEnd();
    }
    if (this.meetingPattern !== null && this.meetingPattern !== undefined) {
      output.writeFieldBegin('meetingPattern', Thrift.Type.STRUCT, 24);
      this.meetingPattern.write(output);
      output.writeFieldEnd();
    }
    if (this.patternType !== null && this.patternType !== undefined) {
      output.writeFieldBegin('patternType', Thrift.Type.I32, 25);
      output.writeI32(this.patternType);
      output.writeFieldEnd();
    }
    if (this.autoGenerateDocName !== null && this.autoGenerateDocName !== undefined) {
      output.writeFieldBegin('autoGenerateDocName', Thrift.Type.BOOL, 26);
      output.writeBool(this.autoGenerateDocName);
      output.writeFieldEnd();
    }
    if (this.docNamePattern !== null && this.docNamePattern !== undefined) {
      output.writeFieldBegin('docNamePattern', Thrift.Type.STRING, 27);
      output.writeString(this.docNamePattern);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
FreezeDocumentPattern = class {
  constructor(args) {
    this.id = null;
    this.nameDocPattern = null;
    this.descriptionDocPattern = null;
    this.creatorId = null;
    this.modifierId = null;
    this.createDate = null;
    this.modifiedDate = null;
    this.deleteDate = null;
    this.isValidState = null;
    this.docNumberPattern = null;
    this.documentPatternGroup = null;
    this.scMask = null;
    this.controlDate = null;
    this.useSC = null;
    this.useDocNumber = null;
    this.needGeneratePdf = null;
    this.startDocNumber = null;
    this.currentDocNumber = null;
    this.account = null;
    this.originalPatternId = null;
    this.docId = null;
    this.hideAuto = null;
    this.hideExt = null;
    this.meetingPattern = null;
    this.meeting = null;
    this.patternType = null;
    this.autoGenerateDocName = null;
    this.docNamePattern = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.nameDocPattern !== undefined && args.nameDocPattern !== null) {
        this.nameDocPattern = args.nameDocPattern;
      }
      if (args.descriptionDocPattern !== undefined && args.descriptionDocPattern !== null) {
        this.descriptionDocPattern = args.descriptionDocPattern;
      }
      if (args.creatorId !== undefined && args.creatorId !== null) {
        this.creatorId = args.creatorId;
      }
      if (args.modifierId !== undefined && args.modifierId !== null) {
        this.modifierId = args.modifierId;
      }
      if (args.createDate !== undefined && args.createDate !== null) {
        this.createDate = args.createDate;
      }
      if (args.modifiedDate !== undefined && args.modifiedDate !== null) {
        this.modifiedDate = args.modifiedDate;
      }
      if (args.deleteDate !== undefined && args.deleteDate !== null) {
        this.deleteDate = args.deleteDate;
      }
      if (args.isValidState !== undefined && args.isValidState !== null) {
        this.isValidState = args.isValidState;
      }
      if (args.docNumberPattern !== undefined && args.docNumberPattern !== null) {
        this.docNumberPattern = args.docNumberPattern;
      }
      if (args.documentPatternGroup !== undefined && args.documentPatternGroup !== null) {
        this.documentPatternGroup = new DocumentPatternGroup(args.documentPatternGroup);
      }
      if (args.scMask !== undefined && args.scMask !== null) {
        this.scMask = args.scMask;
      }
      if (args.controlDate !== undefined && args.controlDate !== null) {
        this.controlDate = args.controlDate;
      }
      if (args.useSC !== undefined && args.useSC !== null) {
        this.useSC = args.useSC;
      }
      if (args.useDocNumber !== undefined && args.useDocNumber !== null) {
        this.useDocNumber = args.useDocNumber;
      }
      if (args.needGeneratePdf !== undefined && args.needGeneratePdf !== null) {
        this.needGeneratePdf = args.needGeneratePdf;
      }
      if (args.startDocNumber !== undefined && args.startDocNumber !== null) {
        this.startDocNumber = args.startDocNumber;
      }
      if (args.currentDocNumber !== undefined && args.currentDocNumber !== null) {
        this.currentDocNumber = args.currentDocNumber;
      }
      if (args.account !== undefined && args.account !== null) {
        this.account = new Account(args.account);
      }
      if (args.originalPatternId !== undefined && args.originalPatternId !== null) {
        this.originalPatternId = args.originalPatternId;
      }
      if (args.docId !== undefined && args.docId !== null) {
        this.docId = args.docId;
      }
      if (args.hideAuto !== undefined && args.hideAuto !== null) {
        this.hideAuto = args.hideAuto;
      }
      if (args.hideExt !== undefined && args.hideExt !== null) {
        this.hideExt = args.hideExt;
      }
      if (args.meetingPattern !== undefined && args.meetingPattern !== null) {
        this.meetingPattern = new DocumentPattern(args.meetingPattern);
      }
      if (args.meeting !== undefined && args.meeting !== null) {
        this.meeting = new Meeting(args.meeting);
      }
      if (args.patternType !== undefined && args.patternType !== null) {
        this.patternType = args.patternType;
      }
      if (args.autoGenerateDocName !== undefined && args.autoGenerateDocName !== null) {
        this.autoGenerateDocName = args.autoGenerateDocName;
      }
      if (args.docNamePattern !== undefined && args.docNamePattern !== null) {
        this.docNamePattern = args.docNamePattern;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.nameDocPattern = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.descriptionDocPattern = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.creatorId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRING) {
          this.modifierId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.I64) {
          this.createDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.I64) {
          this.modifiedDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.I64) {
          this.deleteDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 9:
        if (ftype == Thrift.Type.BOOL) {
          this.isValidState = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 10:
        if (ftype == Thrift.Type.STRING) {
          this.docNumberPattern = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 11:
        if (ftype == Thrift.Type.STRUCT) {
          this.documentPatternGroup = new DocumentPatternGroup();
          this.documentPatternGroup.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 12:
        if (ftype == Thrift.Type.STRING) {
          this.scMask = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 13:
        if (ftype == Thrift.Type.STRING) {
          this.controlDate = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 14:
        if (ftype == Thrift.Type.BOOL) {
          this.useSC = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 15:
        if (ftype == Thrift.Type.BOOL) {
          this.useDocNumber = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 16:
        if (ftype == Thrift.Type.BOOL) {
          this.needGeneratePdf = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 17:
        if (ftype == Thrift.Type.I64) {
          this.startDocNumber = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 18:
        if (ftype == Thrift.Type.I64) {
          this.currentDocNumber = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 19:
        if (ftype == Thrift.Type.STRUCT) {
          this.account = new Account();
          this.account.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 20:
        if (ftype == Thrift.Type.STRING) {
          this.originalPatternId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 21:
        if (ftype == Thrift.Type.STRING) {
          this.docId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 22:
        if (ftype == Thrift.Type.BOOL) {
          this.hideAuto = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 23:
        if (ftype == Thrift.Type.BOOL) {
          this.hideExt = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 24:
        if (ftype == Thrift.Type.STRUCT) {
          this.meetingPattern = new DocumentPattern();
          this.meetingPattern.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 25:
        if (ftype == Thrift.Type.STRUCT) {
          this.meeting = new Meeting();
          this.meeting.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 26:
        if (ftype == Thrift.Type.I32) {
          this.patternType = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 32:
        if (ftype == Thrift.Type.BOOL) {
          this.autoGenerateDocName = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 33:
        if (ftype == Thrift.Type.STRING) {
          this.docNamePattern = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('FreezeDocumentPattern');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.nameDocPattern !== null && this.nameDocPattern !== undefined) {
      output.writeFieldBegin('nameDocPattern', Thrift.Type.STRING, 2);
      output.writeString(this.nameDocPattern);
      output.writeFieldEnd();
    }
    if (this.descriptionDocPattern !== null && this.descriptionDocPattern !== undefined) {
      output.writeFieldBegin('descriptionDocPattern', Thrift.Type.STRING, 3);
      output.writeString(this.descriptionDocPattern);
      output.writeFieldEnd();
    }
    if (this.creatorId !== null && this.creatorId !== undefined) {
      output.writeFieldBegin('creatorId', Thrift.Type.STRING, 4);
      output.writeString(this.creatorId);
      output.writeFieldEnd();
    }
    if (this.modifierId !== null && this.modifierId !== undefined) {
      output.writeFieldBegin('modifierId', Thrift.Type.STRING, 5);
      output.writeString(this.modifierId);
      output.writeFieldEnd();
    }
    if (this.createDate !== null && this.createDate !== undefined) {
      output.writeFieldBegin('createDate', Thrift.Type.I64, 6);
      output.writeI64(this.createDate);
      output.writeFieldEnd();
    }
    if (this.modifiedDate !== null && this.modifiedDate !== undefined) {
      output.writeFieldBegin('modifiedDate', Thrift.Type.I64, 7);
      output.writeI64(this.modifiedDate);
      output.writeFieldEnd();
    }
    if (this.deleteDate !== null && this.deleteDate !== undefined) {
      output.writeFieldBegin('deleteDate', Thrift.Type.I64, 8);
      output.writeI64(this.deleteDate);
      output.writeFieldEnd();
    }
    if (this.isValidState !== null && this.isValidState !== undefined) {
      output.writeFieldBegin('isValidState', Thrift.Type.BOOL, 9);
      output.writeBool(this.isValidState);
      output.writeFieldEnd();
    }
    if (this.docNumberPattern !== null && this.docNumberPattern !== undefined) {
      output.writeFieldBegin('docNumberPattern', Thrift.Type.STRING, 10);
      output.writeString(this.docNumberPattern);
      output.writeFieldEnd();
    }
    if (this.documentPatternGroup !== null && this.documentPatternGroup !== undefined) {
      output.writeFieldBegin('documentPatternGroup', Thrift.Type.STRUCT, 11);
      this.documentPatternGroup.write(output);
      output.writeFieldEnd();
    }
    if (this.scMask !== null && this.scMask !== undefined) {
      output.writeFieldBegin('scMask', Thrift.Type.STRING, 12);
      output.writeString(this.scMask);
      output.writeFieldEnd();
    }
    if (this.controlDate !== null && this.controlDate !== undefined) {
      output.writeFieldBegin('controlDate', Thrift.Type.STRING, 13);
      output.writeString(this.controlDate);
      output.writeFieldEnd();
    }
    if (this.useSC !== null && this.useSC !== undefined) {
      output.writeFieldBegin('useSC', Thrift.Type.BOOL, 14);
      output.writeBool(this.useSC);
      output.writeFieldEnd();
    }
    if (this.useDocNumber !== null && this.useDocNumber !== undefined) {
      output.writeFieldBegin('useDocNumber', Thrift.Type.BOOL, 15);
      output.writeBool(this.useDocNumber);
      output.writeFieldEnd();
    }
    if (this.needGeneratePdf !== null && this.needGeneratePdf !== undefined) {
      output.writeFieldBegin('needGeneratePdf', Thrift.Type.BOOL, 16);
      output.writeBool(this.needGeneratePdf);
      output.writeFieldEnd();
    }
    if (this.startDocNumber !== null && this.startDocNumber !== undefined) {
      output.writeFieldBegin('startDocNumber', Thrift.Type.I64, 17);
      output.writeI64(this.startDocNumber);
      output.writeFieldEnd();
    }
    if (this.currentDocNumber !== null && this.currentDocNumber !== undefined) {
      output.writeFieldBegin('currentDocNumber', Thrift.Type.I64, 18);
      output.writeI64(this.currentDocNumber);
      output.writeFieldEnd();
    }
    if (this.account !== null && this.account !== undefined) {
      output.writeFieldBegin('account', Thrift.Type.STRUCT, 19);
      this.account.write(output);
      output.writeFieldEnd();
    }
    if (this.originalPatternId !== null && this.originalPatternId !== undefined) {
      output.writeFieldBegin('originalPatternId', Thrift.Type.STRING, 20);
      output.writeString(this.originalPatternId);
      output.writeFieldEnd();
    }
    if (this.docId !== null && this.docId !== undefined) {
      output.writeFieldBegin('docId', Thrift.Type.STRING, 21);
      output.writeString(this.docId);
      output.writeFieldEnd();
    }
    if (this.hideAuto !== null && this.hideAuto !== undefined) {
      output.writeFieldBegin('hideAuto', Thrift.Type.BOOL, 22);
      output.writeBool(this.hideAuto);
      output.writeFieldEnd();
    }
    if (this.hideExt !== null && this.hideExt !== undefined) {
      output.writeFieldBegin('hideExt', Thrift.Type.BOOL, 23);
      output.writeBool(this.hideExt);
      output.writeFieldEnd();
    }
    if (this.meetingPattern !== null && this.meetingPattern !== undefined) {
      output.writeFieldBegin('meetingPattern', Thrift.Type.STRUCT, 24);
      this.meetingPattern.write(output);
      output.writeFieldEnd();
    }
    if (this.meeting !== null && this.meeting !== undefined) {
      output.writeFieldBegin('meeting', Thrift.Type.STRUCT, 25);
      this.meeting.write(output);
      output.writeFieldEnd();
    }
    if (this.patternType !== null && this.patternType !== undefined) {
      output.writeFieldBegin('patternType', Thrift.Type.I32, 26);
      output.writeI32(this.patternType);
      output.writeFieldEnd();
    }
    if (this.autoGenerateDocName !== null && this.autoGenerateDocName !== undefined) {
      output.writeFieldBegin('autoGenerateDocName', Thrift.Type.BOOL, 32);
      output.writeBool(this.autoGenerateDocName);
      output.writeFieldEnd();
    }
    if (this.docNamePattern !== null && this.docNamePattern !== undefined) {
      output.writeFieldBegin('docNamePattern', Thrift.Type.STRING, 33);
      output.writeString(this.docNamePattern);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
PatternToUser = class {
  constructor(args) {
    this.docPattern = null;
    this.userOrgroup = null;
    if (args) {
      if (args.docPattern !== undefined && args.docPattern !== null) {
        this.docPattern = new DocumentPattern(args.docPattern);
      }
      if (args.userOrgroup !== undefined && args.userOrgroup !== null) {
        this.userOrgroup = new UserOrGroup(args.userOrgroup);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.docPattern = new DocumentPattern();
          this.docPattern.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.userOrgroup = new UserOrGroup();
          this.userOrgroup.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('PatternToUser');
    if (this.docPattern !== null && this.docPattern !== undefined) {
      output.writeFieldBegin('docPattern', Thrift.Type.STRUCT, 1);
      this.docPattern.write(output);
      output.writeFieldEnd();
    }
    if (this.userOrgroup !== null && this.userOrgroup !== undefined) {
      output.writeFieldBegin('userOrgroup', Thrift.Type.STRUCT, 2);
      this.userOrgroup.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
StageParam = class {
  constructor(args) {
    this.key = null;
    this.value = null;
    this.type = null;
    this.oName = null;
    this.multi = null;
    this.inValues = null;
    this.scriptId = null;
    this.req = null;
    this.displayName = null;
    this.subProcessAuthors = null;
    if (args) {
      if (args.key !== undefined && args.key !== null) {
        this.key = args.key;
      }
      if (args.value !== undefined && args.value !== null) {
        this.value = Thrift.copyList(args.value, [null]);
      }
      if (args.type !== undefined && args.type !== null) {
        this.type = args.type;
      }
      if (args.oName !== undefined && args.oName !== null) {
        this.oName = Thrift.copyList(args.oName, [null]);
      }
      if (args.multi !== undefined && args.multi !== null) {
        this.multi = args.multi;
      }
      if (args.inValues !== undefined && args.inValues !== null) {
        this.inValues = Thrift.copyList(args.inValues, [null]);
      }
      if (args.scriptId !== undefined && args.scriptId !== null) {
        this.scriptId = new CompositeId(args.scriptId);
      }
      if (args.req !== undefined && args.req !== null) {
        this.req = args.req;
      }
      if (args.displayName !== undefined && args.displayName !== null) {
        this.displayName = args.displayName;
      }
      if (args.subProcessAuthors !== undefined && args.subProcessAuthors !== null) {
        this.subProcessAuthors = Thrift.copyList(args.subProcessAuthors, [PatternToUser]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.key = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.LIST) {
          this.value = [];
          const _rtmp366 = input.readListBegin();
          const _size65 = _rtmp366.size || 0;
          for (let _i67 = 0; _i67 < _size65; ++_i67) {
            let elem68 = null;
            elem68 = input.readString().value;
            this.value.push(elem68);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I32) {
          this.type = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.LIST) {
          this.oName = [];
          const _rtmp370 = input.readListBegin();
          const _size69 = _rtmp370.size || 0;
          for (let _i71 = 0; _i71 < _size69; ++_i71) {
            let elem72 = null;
            elem72 = input.readString().value;
            this.oName.push(elem72);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.BOOL) {
          this.multi = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.LIST) {
          this.inValues = [];
          const _rtmp374 = input.readListBegin();
          const _size73 = _rtmp374.size || 0;
          for (let _i75 = 0; _i75 < _size73; ++_i75) {
            let elem76 = null;
            elem76 = input.readString().value;
            this.inValues.push(elem76);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.STRUCT) {
          this.scriptId = new CompositeId();
          this.scriptId.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.BOOL) {
          this.req = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 9:
        if (ftype == Thrift.Type.STRING) {
          this.displayName = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 10:
        if (ftype == Thrift.Type.LIST) {
          this.subProcessAuthors = [];
          const _rtmp378 = input.readListBegin();
          const _size77 = _rtmp378.size || 0;
          for (let _i79 = 0; _i79 < _size77; ++_i79) {
            let elem80 = null;
            elem80 = new PatternToUser();
            elem80.read(input);
            this.subProcessAuthors.push(elem80);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('StageParam');
    if (this.key !== null && this.key !== undefined) {
      output.writeFieldBegin('key', Thrift.Type.STRING, 1);
      output.writeString(this.key);
      output.writeFieldEnd();
    }
    if (this.value !== null && this.value !== undefined) {
      output.writeFieldBegin('value', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.STRING, this.value.length);
      for (let iter81 in this.value) {
        if (this.value.hasOwnProperty(iter81)) {
          iter81 = this.value[iter81];
          output.writeString(iter81);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.type !== null && this.type !== undefined) {
      output.writeFieldBegin('type', Thrift.Type.I32, 3);
      output.writeI32(this.type);
      output.writeFieldEnd();
    }
    if (this.oName !== null && this.oName !== undefined) {
      output.writeFieldBegin('oName', Thrift.Type.LIST, 4);
      output.writeListBegin(Thrift.Type.STRING, this.oName.length);
      for (let iter82 in this.oName) {
        if (this.oName.hasOwnProperty(iter82)) {
          iter82 = this.oName[iter82];
          output.writeString(iter82);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.multi !== null && this.multi !== undefined) {
      output.writeFieldBegin('multi', Thrift.Type.BOOL, 5);
      output.writeBool(this.multi);
      output.writeFieldEnd();
    }
    if (this.inValues !== null && this.inValues !== undefined) {
      output.writeFieldBegin('inValues', Thrift.Type.LIST, 6);
      output.writeListBegin(Thrift.Type.STRING, this.inValues.length);
      for (let iter83 in this.inValues) {
        if (this.inValues.hasOwnProperty(iter83)) {
          iter83 = this.inValues[iter83];
          output.writeString(iter83);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.scriptId !== null && this.scriptId !== undefined) {
      output.writeFieldBegin('scriptId', Thrift.Type.STRUCT, 7);
      this.scriptId.write(output);
      output.writeFieldEnd();
    }
    if (this.req !== null && this.req !== undefined) {
      output.writeFieldBegin('req', Thrift.Type.BOOL, 8);
      output.writeBool(this.req);
      output.writeFieldEnd();
    }
    if (this.displayName !== null && this.displayName !== undefined) {
      output.writeFieldBegin('displayName', Thrift.Type.STRING, 9);
      output.writeString(this.displayName);
      output.writeFieldEnd();
    }
    if (this.subProcessAuthors !== null && this.subProcessAuthors !== undefined) {
      output.writeFieldBegin('subProcessAuthors', Thrift.Type.LIST, 10);
      output.writeListBegin(Thrift.Type.STRUCT, this.subProcessAuthors.length);
      for (let iter84 in this.subProcessAuthors) {
        if (this.subProcessAuthors.hasOwnProperty(iter84)) {
          iter84 = this.subProcessAuthors[iter84];
          iter84.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentPatternStage = class {
  constructor(args) {
    this.id = null;
    this.documentPatternId = null;
    this.nameDocPatStage = null;
    this.descriptionDocPatStage = null;
    this.status = null;
    this.subStatus = null;
    this.actionType = null;
    this.stageReq = null;
    this.deadLine = null;
    this.graphicalParams = null;
    this.availablePatternStageId = null;
    this.movedByDecision = null;
    this.registerDocument = null;
    this.execPriority = null;
    this.dispatchState = null;
    this.hide = null;
    this.userOrGroups = null;
    this.allowAdditionalConf = null;
    this.runPerriodicall = null;
    this.startPeriod = null;
    this.nextStartPeriod = null;
    this.periodicJiraEndDate = null;
    this.periodicEndDate = null;
    this.onlineEditRule = null;
    this.onlineCommentRule = null;
    this.changeOnDraft = null;
    this.changeOnEdit = null;
    this.changeOnSetDecision = null;
    this.editDocRule = null;
    this.attachmentAddRule = null;
    this.attachmentDeleteRule = null;
    this.changeContentRule = null;
    this.canEdit = null;
    this.maxSigner = null;
    this.stageParams = null;
    this.availableDecisions = null;
    this.fmEditKey = null;
    this.fmEditPersonal = null;
    this.fmEditClose = null;
    this.fmViewKey = null;
    this.fmViewPersonal = null;
    this.fmViewClose = null;
    this.preFunctionId = null;
    this.postFunctionId = null;
    this.showDocDetails = null;
    this.showChat = null;
    this.showHistory = null;
    this.showAttachments = null;
    this.notifMoveOnEnabled = null;
    this.notifMoveOnChanel = null;
    this.notifPeriodicalEnabled = null;
    this.notifPeriodicalJira = null;
    this.notifPeriodicalChanel = null;
    this.notifCheckDeadlineEnabled = null;
    this.notifCheckDeadlineJira = null;
    this.notifCheckDeadlineChanel = null;
    this.notifCardExpiredEnabled = null;
    this.notifCardExpiredChanel = null;
    this.orderNum = null;
    this.cardActivityPeriod = null;
    this.stageContentHolders = null;
    this.signAttachmentRule = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.documentPatternId !== undefined && args.documentPatternId !== null) {
        this.documentPatternId = args.documentPatternId;
      }
      if (args.nameDocPatStage !== undefined && args.nameDocPatStage !== null) {
        this.nameDocPatStage = args.nameDocPatStage;
      }
      if (args.descriptionDocPatStage !== undefined && args.descriptionDocPatStage !== null) {
        this.descriptionDocPatStage = args.descriptionDocPatStage;
      }
      if (args.status !== undefined && args.status !== null) {
        this.status = args.status;
      }
      if (args.subStatus !== undefined && args.subStatus !== null) {
        this.subStatus = args.subStatus;
      }
      if (args.actionType !== undefined && args.actionType !== null) {
        this.actionType = args.actionType;
      }
      if (args.stageReq !== undefined && args.stageReq !== null) {
        this.stageReq = args.stageReq;
      }
      if (args.deadLine !== undefined && args.deadLine !== null) {
        this.deadLine = args.deadLine;
      }
      if (args.graphicalParams !== undefined && args.graphicalParams !== null) {
        this.graphicalParams = args.graphicalParams;
      }
      if (args.availablePatternStageId !== undefined && args.availablePatternStageId !== null) {
        this.availablePatternStageId = args.availablePatternStageId;
      }
      if (args.movedByDecision !== undefined && args.movedByDecision !== null) {
        this.movedByDecision = args.movedByDecision;
      }
      if (args.registerDocument !== undefined && args.registerDocument !== null) {
        this.registerDocument = args.registerDocument;
      }
      if (args.execPriority !== undefined && args.execPriority !== null) {
        this.execPriority = args.execPriority;
      }
      if (args.dispatchState !== undefined && args.dispatchState !== null) {
        this.dispatchState = args.dispatchState;
      }
      if (args.hide !== undefined && args.hide !== null) {
        this.hide = args.hide;
      }
      if (args.userOrGroups !== undefined && args.userOrGroups !== null) {
        this.userOrGroups = Thrift.copyList(args.userOrGroups, [UserOrGroup]);
      }
      if (args.allowAdditionalConf !== undefined && args.allowAdditionalConf !== null) {
        this.allowAdditionalConf = args.allowAdditionalConf;
      }
      if (args.runPerriodicall !== undefined && args.runPerriodicall !== null) {
        this.runPerriodicall = args.runPerriodicall;
      }
      if (args.startPeriod !== undefined && args.startPeriod !== null) {
        this.startPeriod = args.startPeriod;
      }
      if (args.nextStartPeriod !== undefined && args.nextStartPeriod !== null) {
        this.nextStartPeriod = args.nextStartPeriod;
      }
      if (args.periodicJiraEndDate !== undefined && args.periodicJiraEndDate !== null) {
        this.periodicJiraEndDate = args.periodicJiraEndDate;
      }
      if (args.periodicEndDate !== undefined && args.periodicEndDate !== null) {
        this.periodicEndDate = args.periodicEndDate;
      }
      if (args.onlineEditRule !== undefined && args.onlineEditRule !== null) {
        this.onlineEditRule = new AccessRule(args.onlineEditRule);
      }
      if (args.onlineCommentRule !== undefined && args.onlineCommentRule !== null) {
        this.onlineCommentRule = new AccessRule(args.onlineCommentRule);
      }
      if (args.changeOnDraft !== undefined && args.changeOnDraft !== null) {
        this.changeOnDraft = args.changeOnDraft;
      }
      if (args.changeOnEdit !== undefined && args.changeOnEdit !== null) {
        this.changeOnEdit = new AccessRule(args.changeOnEdit);
      }
      if (args.changeOnSetDecision !== undefined && args.changeOnSetDecision !== null) {
        this.changeOnSetDecision = new AccessRule(args.changeOnSetDecision);
      }
      if (args.editDocRule !== undefined && args.editDocRule !== null) {
        this.editDocRule = new AccessRule(args.editDocRule);
      }
      if (args.attachmentAddRule !== undefined && args.attachmentAddRule !== null) {
        this.attachmentAddRule = new AccessRule(args.attachmentAddRule);
      }
      if (args.attachmentDeleteRule !== undefined && args.attachmentDeleteRule !== null) {
        this.attachmentDeleteRule = new AccessRule(args.attachmentDeleteRule);
      }
      if (args.changeContentRule !== undefined && args.changeContentRule !== null) {
        this.changeContentRule = new AccessRule(args.changeContentRule);
      }
      if (args.canEdit !== undefined && args.canEdit !== null) {
        this.canEdit = args.canEdit;
      }
      if (args.maxSigner !== undefined && args.maxSigner !== null) {
        this.maxSigner = args.maxSigner;
      }
      if (args.stageParams !== undefined && args.stageParams !== null) {
        this.stageParams = Thrift.copyList(args.stageParams, [StageParam]);
      }
      if (args.availableDecisions !== undefined && args.availableDecisions !== null) {
        this.availableDecisions = Thrift.copyList(args.availableDecisions, [null]);
      }
      if (args.fmEditKey !== undefined && args.fmEditKey !== null) {
        this.fmEditKey = args.fmEditKey;
      }
      if (args.fmEditPersonal !== undefined && args.fmEditPersonal !== null) {
        this.fmEditPersonal = args.fmEditPersonal;
      }
      if (args.fmEditClose !== undefined && args.fmEditClose !== null) {
        this.fmEditClose = args.fmEditClose;
      }
      if (args.fmViewKey !== undefined && args.fmViewKey !== null) {
        this.fmViewKey = args.fmViewKey;
      }
      if (args.fmViewPersonal !== undefined && args.fmViewPersonal !== null) {
        this.fmViewPersonal = args.fmViewPersonal;
      }
      if (args.fmViewClose !== undefined && args.fmViewClose !== null) {
        this.fmViewClose = args.fmViewClose;
      }
      if (args.preFunctionId !== undefined && args.preFunctionId !== null) {
        this.preFunctionId = new CompositeId(args.preFunctionId);
      }
      if (args.postFunctionId !== undefined && args.postFunctionId !== null) {
        this.postFunctionId = new CompositeId(args.postFunctionId);
      }
      if (args.showDocDetails !== undefined && args.showDocDetails !== null) {
        this.showDocDetails = args.showDocDetails;
      }
      if (args.showChat !== undefined && args.showChat !== null) {
        this.showChat = args.showChat;
      }
      if (args.showHistory !== undefined && args.showHistory !== null) {
        this.showHistory = args.showHistory;
      }
      if (args.showAttachments !== undefined && args.showAttachments !== null) {
        this.showAttachments = args.showAttachments;
      }
      if (args.notifMoveOnEnabled !== undefined && args.notifMoveOnEnabled !== null) {
        this.notifMoveOnEnabled = args.notifMoveOnEnabled;
      }
      if (args.notifMoveOnChanel !== undefined && args.notifMoveOnChanel !== null) {
        this.notifMoveOnChanel = args.notifMoveOnChanel;
      }
      if (args.notifPeriodicalEnabled !== undefined && args.notifPeriodicalEnabled !== null) {
        this.notifPeriodicalEnabled = args.notifPeriodicalEnabled;
      }
      if (args.notifPeriodicalJira !== undefined && args.notifPeriodicalJira !== null) {
        this.notifPeriodicalJira = args.notifPeriodicalJira;
      }
      if (args.notifPeriodicalChanel !== undefined && args.notifPeriodicalChanel !== null) {
        this.notifPeriodicalChanel = args.notifPeriodicalChanel;
      }
      if (args.notifCheckDeadlineEnabled !== undefined && args.notifCheckDeadlineEnabled !== null) {
        this.notifCheckDeadlineEnabled = args.notifCheckDeadlineEnabled;
      }
      if (args.notifCheckDeadlineJira !== undefined && args.notifCheckDeadlineJira !== null) {
        this.notifCheckDeadlineJira = args.notifCheckDeadlineJira;
      }
      if (args.notifCheckDeadlineChanel !== undefined && args.notifCheckDeadlineChanel !== null) {
        this.notifCheckDeadlineChanel = args.notifCheckDeadlineChanel;
      }
      if (args.notifCardExpiredEnabled !== undefined && args.notifCardExpiredEnabled !== null) {
        this.notifCardExpiredEnabled = args.notifCardExpiredEnabled;
      }
      if (args.notifCardExpiredChanel !== undefined && args.notifCardExpiredChanel !== null) {
        this.notifCardExpiredChanel = args.notifCardExpiredChanel;
      }
      if (args.orderNum !== undefined && args.orderNum !== null) {
        this.orderNum = args.orderNum;
      }
      if (args.cardActivityPeriod !== undefined && args.cardActivityPeriod !== null) {
        this.cardActivityPeriod = args.cardActivityPeriod;
      }
      if (args.stageContentHolders !== undefined && args.stageContentHolders !== null) {
        this.stageContentHolders = Thrift.copyList(args.stageContentHolders, [null]);
      }
      if (args.signAttachmentRule !== undefined && args.signAttachmentRule !== null) {
        this.signAttachmentRule = new AccessRule(args.signAttachmentRule);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentPatternId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.nameDocPatStage = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.descriptionDocPatStage = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.I32) {
          this.status = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.I32) {
          this.subStatus = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.I32) {
          this.actionType = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.BOOL) {
          this.stageReq = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 9:
        if (ftype == Thrift.Type.STRING) {
          this.deadLine = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 10:
        if (ftype == Thrift.Type.STRING) {
          this.graphicalParams = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 11:
        if (ftype == Thrift.Type.STRING) {
          this.availablePatternStageId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 12:
        if (ftype == Thrift.Type.STRING) {
          this.movedByDecision = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 13:
        if (ftype == Thrift.Type.BOOL) {
          this.registerDocument = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 14:
        if (ftype == Thrift.Type.I32) {
          this.execPriority = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 15:
        if (ftype == Thrift.Type.I32) {
          this.dispatchState = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 16:
        if (ftype == Thrift.Type.BOOL) {
          this.hide = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 17:
        if (ftype == Thrift.Type.LIST) {
          this.userOrGroups = [];
          const _rtmp386 = input.readListBegin();
          const _size85 = _rtmp386.size || 0;
          for (let _i87 = 0; _i87 < _size85; ++_i87) {
            let elem88 = null;
            elem88 = new UserOrGroup();
            elem88.read(input);
            this.userOrGroups.push(elem88);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 18:
        if (ftype == Thrift.Type.BOOL) {
          this.allowAdditionalConf = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 19:
        if (ftype == Thrift.Type.BOOL) {
          this.runPerriodicall = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 20:
        if (ftype == Thrift.Type.I64) {
          this.startPeriod = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 21:
        if (ftype == Thrift.Type.STRING) {
          this.nextStartPeriod = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 22:
        if (ftype == Thrift.Type.STRING) {
          this.periodicJiraEndDate = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 23:
        if (ftype == Thrift.Type.I64) {
          this.periodicEndDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 24:
        if (ftype == Thrift.Type.STRUCT) {
          this.onlineEditRule = new AccessRule();
          this.onlineEditRule.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 25:
        if (ftype == Thrift.Type.STRUCT) {
          this.onlineCommentRule = new AccessRule();
          this.onlineCommentRule.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 26:
        if (ftype == Thrift.Type.BOOL) {
          this.changeOnDraft = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 27:
        if (ftype == Thrift.Type.STRUCT) {
          this.changeOnEdit = new AccessRule();
          this.changeOnEdit.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 28:
        if (ftype == Thrift.Type.STRUCT) {
          this.changeOnSetDecision = new AccessRule();
          this.changeOnSetDecision.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 29:
        if (ftype == Thrift.Type.STRUCT) {
          this.editDocRule = new AccessRule();
          this.editDocRule.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 30:
        if (ftype == Thrift.Type.STRUCT) {
          this.attachmentAddRule = new AccessRule();
          this.attachmentAddRule.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 31:
        if (ftype == Thrift.Type.STRUCT) {
          this.attachmentDeleteRule = new AccessRule();
          this.attachmentDeleteRule.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 32:
        if (ftype == Thrift.Type.STRUCT) {
          this.changeContentRule = new AccessRule();
          this.changeContentRule.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 33:
        if (ftype == Thrift.Type.BOOL) {
          this.canEdit = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 34:
        if (ftype == Thrift.Type.I32) {
          this.maxSigner = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 35:
        if (ftype == Thrift.Type.LIST) {
          this.stageParams = [];
          const _rtmp390 = input.readListBegin();
          const _size89 = _rtmp390.size || 0;
          for (let _i91 = 0; _i91 < _size89; ++_i91) {
            let elem92 = null;
            elem92 = new StageParam();
            elem92.read(input);
            this.stageParams.push(elem92);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 36:
        if (ftype == Thrift.Type.SET) {
          this.availableDecisions = [];
          const _rtmp394 = input.readSetBegin();
          const _size93 = _rtmp394.size || 0;
          for (let _i95 = 0; _i95 < _size93; ++_i95) {
            let elem96 = null;
            elem96 = input.readString().value;
            this.availableDecisions.push(elem96);
          }
          input.readSetEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 37:
        if (ftype == Thrift.Type.STRING) {
          this.fmEditKey = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 38:
        if (ftype == Thrift.Type.BOOL) {
          this.fmEditPersonal = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 39:
        if (ftype == Thrift.Type.BOOL) {
          this.fmEditClose = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 40:
        if (ftype == Thrift.Type.STRING) {
          this.fmViewKey = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 41:
        if (ftype == Thrift.Type.BOOL) {
          this.fmViewPersonal = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 42:
        if (ftype == Thrift.Type.BOOL) {
          this.fmViewClose = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 43:
        if (ftype == Thrift.Type.STRUCT) {
          this.preFunctionId = new CompositeId();
          this.preFunctionId.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 44:
        if (ftype == Thrift.Type.STRUCT) {
          this.postFunctionId = new CompositeId();
          this.postFunctionId.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 45:
        if (ftype == Thrift.Type.I32) {
          this.showDocDetails = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 46:
        if (ftype == Thrift.Type.I32) {
          this.showChat = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 47:
        if (ftype == Thrift.Type.I32) {
          this.showHistory = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 48:
        if (ftype == Thrift.Type.I32) {
          this.showAttachments = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 49:
        if (ftype == Thrift.Type.BOOL) {
          this.notifMoveOnEnabled = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 50:
        if (ftype == Thrift.Type.STRING) {
          this.notifMoveOnChanel = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 51:
        if (ftype == Thrift.Type.BOOL) {
          this.notifPeriodicalEnabled = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 52:
        if (ftype == Thrift.Type.STRING) {
          this.notifPeriodicalJira = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 53:
        if (ftype == Thrift.Type.STRING) {
          this.notifPeriodicalChanel = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 54:
        if (ftype == Thrift.Type.BOOL) {
          this.notifCheckDeadlineEnabled = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 55:
        if (ftype == Thrift.Type.STRING) {
          this.notifCheckDeadlineJira = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 56:
        if (ftype == Thrift.Type.STRING) {
          this.notifCheckDeadlineChanel = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 57:
        if (ftype == Thrift.Type.BOOL) {
          this.notifCardExpiredEnabled = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 58:
        if (ftype == Thrift.Type.STRING) {
          this.notifCardExpiredChanel = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 59:
        if (ftype == Thrift.Type.I32) {
          this.orderNum = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 60:
        if (ftype == Thrift.Type.STRING) {
          this.cardActivityPeriod = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 61:
        if (ftype == Thrift.Type.LIST) {
          this.stageContentHolders = [];
          const _rtmp398 = input.readListBegin();
          const _size97 = _rtmp398.size || 0;
          for (let _i99 = 0; _i99 < _size97; ++_i99) {
            let elem100 = null;
            elem100 = new ContentHolderShowPlace();
            elem100.read(input);
            this.stageContentHolders.push(elem100);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 62:
        if (ftype == Thrift.Type.STRUCT) {
          this.signAttachmentRule = new AccessRule();
          this.signAttachmentRule.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentPatternStage');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.documentPatternId !== null && this.documentPatternId !== undefined) {
      output.writeFieldBegin('documentPatternId', Thrift.Type.STRING, 2);
      output.writeString(this.documentPatternId);
      output.writeFieldEnd();
    }
    if (this.nameDocPatStage !== null && this.nameDocPatStage !== undefined) {
      output.writeFieldBegin('nameDocPatStage', Thrift.Type.STRING, 3);
      output.writeString(this.nameDocPatStage);
      output.writeFieldEnd();
    }
    if (this.descriptionDocPatStage !== null && this.descriptionDocPatStage !== undefined) {
      output.writeFieldBegin('descriptionDocPatStage', Thrift.Type.STRING, 4);
      output.writeString(this.descriptionDocPatStage);
      output.writeFieldEnd();
    }
    if (this.status !== null && this.status !== undefined) {
      output.writeFieldBegin('status', Thrift.Type.I32, 5);
      output.writeI32(this.status);
      output.writeFieldEnd();
    }
    if (this.subStatus !== null && this.subStatus !== undefined) {
      output.writeFieldBegin('subStatus', Thrift.Type.I32, 6);
      output.writeI32(this.subStatus);
      output.writeFieldEnd();
    }
    if (this.actionType !== null && this.actionType !== undefined) {
      output.writeFieldBegin('actionType', Thrift.Type.I32, 7);
      output.writeI32(this.actionType);
      output.writeFieldEnd();
    }
    if (this.stageReq !== null && this.stageReq !== undefined) {
      output.writeFieldBegin('stageReq', Thrift.Type.BOOL, 8);
      output.writeBool(this.stageReq);
      output.writeFieldEnd();
    }
    if (this.deadLine !== null && this.deadLine !== undefined) {
      output.writeFieldBegin('deadLine', Thrift.Type.STRING, 9);
      output.writeString(this.deadLine);
      output.writeFieldEnd();
    }
    if (this.graphicalParams !== null && this.graphicalParams !== undefined) {
      output.writeFieldBegin('graphicalParams', Thrift.Type.STRING, 10);
      output.writeString(this.graphicalParams);
      output.writeFieldEnd();
    }
    if (this.availablePatternStageId !== null && this.availablePatternStageId !== undefined) {
      output.writeFieldBegin('availablePatternStageId', Thrift.Type.STRING, 11);
      output.writeString(this.availablePatternStageId);
      output.writeFieldEnd();
    }
    if (this.movedByDecision !== null && this.movedByDecision !== undefined) {
      output.writeFieldBegin('movedByDecision', Thrift.Type.STRING, 12);
      output.writeString(this.movedByDecision);
      output.writeFieldEnd();
    }
    if (this.registerDocument !== null && this.registerDocument !== undefined) {
      output.writeFieldBegin('registerDocument', Thrift.Type.BOOL, 13);
      output.writeBool(this.registerDocument);
      output.writeFieldEnd();
    }
    if (this.execPriority !== null && this.execPriority !== undefined) {
      output.writeFieldBegin('execPriority', Thrift.Type.I32, 14);
      output.writeI32(this.execPriority);
      output.writeFieldEnd();
    }
    if (this.dispatchState !== null && this.dispatchState !== undefined) {
      output.writeFieldBegin('dispatchState', Thrift.Type.I32, 15);
      output.writeI32(this.dispatchState);
      output.writeFieldEnd();
    }
    if (this.hide !== null && this.hide !== undefined) {
      output.writeFieldBegin('hide', Thrift.Type.BOOL, 16);
      output.writeBool(this.hide);
      output.writeFieldEnd();
    }
    if (this.userOrGroups !== null && this.userOrGroups !== undefined) {
      output.writeFieldBegin('userOrGroups', Thrift.Type.LIST, 17);
      output.writeListBegin(Thrift.Type.STRUCT, this.userOrGroups.length);
      for (let iter101 in this.userOrGroups) {
        if (this.userOrGroups.hasOwnProperty(iter101)) {
          iter101 = this.userOrGroups[iter101];
          iter101.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.allowAdditionalConf !== null && this.allowAdditionalConf !== undefined) {
      output.writeFieldBegin('allowAdditionalConf', Thrift.Type.BOOL, 18);
      output.writeBool(this.allowAdditionalConf);
      output.writeFieldEnd();
    }
    if (this.runPerriodicall !== null && this.runPerriodicall !== undefined) {
      output.writeFieldBegin('runPerriodicall', Thrift.Type.BOOL, 19);
      output.writeBool(this.runPerriodicall);
      output.writeFieldEnd();
    }
    if (this.startPeriod !== null && this.startPeriod !== undefined) {
      output.writeFieldBegin('startPeriod', Thrift.Type.I64, 20);
      output.writeI64(this.startPeriod);
      output.writeFieldEnd();
    }
    if (this.nextStartPeriod !== null && this.nextStartPeriod !== undefined) {
      output.writeFieldBegin('nextStartPeriod', Thrift.Type.STRING, 21);
      output.writeString(this.nextStartPeriod);
      output.writeFieldEnd();
    }
    if (this.periodicJiraEndDate !== null && this.periodicJiraEndDate !== undefined) {
      output.writeFieldBegin('periodicJiraEndDate', Thrift.Type.STRING, 22);
      output.writeString(this.periodicJiraEndDate);
      output.writeFieldEnd();
    }
    if (this.periodicEndDate !== null && this.periodicEndDate !== undefined) {
      output.writeFieldBegin('periodicEndDate', Thrift.Type.I64, 23);
      output.writeI64(this.periodicEndDate);
      output.writeFieldEnd();
    }
    if (this.onlineEditRule !== null && this.onlineEditRule !== undefined) {
      output.writeFieldBegin('onlineEditRule', Thrift.Type.STRUCT, 24);
      this.onlineEditRule.write(output);
      output.writeFieldEnd();
    }
    if (this.onlineCommentRule !== null && this.onlineCommentRule !== undefined) {
      output.writeFieldBegin('onlineCommentRule', Thrift.Type.STRUCT, 25);
      this.onlineCommentRule.write(output);
      output.writeFieldEnd();
    }
    if (this.changeOnDraft !== null && this.changeOnDraft !== undefined) {
      output.writeFieldBegin('changeOnDraft', Thrift.Type.BOOL, 26);
      output.writeBool(this.changeOnDraft);
      output.writeFieldEnd();
    }
    if (this.changeOnEdit !== null && this.changeOnEdit !== undefined) {
      output.writeFieldBegin('changeOnEdit', Thrift.Type.STRUCT, 27);
      this.changeOnEdit.write(output);
      output.writeFieldEnd();
    }
    if (this.changeOnSetDecision !== null && this.changeOnSetDecision !== undefined) {
      output.writeFieldBegin('changeOnSetDecision', Thrift.Type.STRUCT, 28);
      this.changeOnSetDecision.write(output);
      output.writeFieldEnd();
    }
    if (this.editDocRule !== null && this.editDocRule !== undefined) {
      output.writeFieldBegin('editDocRule', Thrift.Type.STRUCT, 29);
      this.editDocRule.write(output);
      output.writeFieldEnd();
    }
    if (this.attachmentAddRule !== null && this.attachmentAddRule !== undefined) {
      output.writeFieldBegin('attachmentAddRule', Thrift.Type.STRUCT, 30);
      this.attachmentAddRule.write(output);
      output.writeFieldEnd();
    }
    if (this.attachmentDeleteRule !== null && this.attachmentDeleteRule !== undefined) {
      output.writeFieldBegin('attachmentDeleteRule', Thrift.Type.STRUCT, 31);
      this.attachmentDeleteRule.write(output);
      output.writeFieldEnd();
    }
    if (this.changeContentRule !== null && this.changeContentRule !== undefined) {
      output.writeFieldBegin('changeContentRule', Thrift.Type.STRUCT, 32);
      this.changeContentRule.write(output);
      output.writeFieldEnd();
    }
    if (this.canEdit !== null && this.canEdit !== undefined) {
      output.writeFieldBegin('canEdit', Thrift.Type.BOOL, 33);
      output.writeBool(this.canEdit);
      output.writeFieldEnd();
    }
    if (this.maxSigner !== null && this.maxSigner !== undefined) {
      output.writeFieldBegin('maxSigner', Thrift.Type.I32, 34);
      output.writeI32(this.maxSigner);
      output.writeFieldEnd();
    }
    if (this.stageParams !== null && this.stageParams !== undefined) {
      output.writeFieldBegin('stageParams', Thrift.Type.LIST, 35);
      output.writeListBegin(Thrift.Type.STRUCT, this.stageParams.length);
      for (let iter102 in this.stageParams) {
        if (this.stageParams.hasOwnProperty(iter102)) {
          iter102 = this.stageParams[iter102];
          iter102.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.availableDecisions !== null && this.availableDecisions !== undefined) {
      output.writeFieldBegin('availableDecisions', Thrift.Type.SET, 36);
      output.writeSetBegin(Thrift.Type.STRING, this.availableDecisions.length);
      for (let iter103 in this.availableDecisions) {
        if (this.availableDecisions.hasOwnProperty(iter103)) {
          iter103 = this.availableDecisions[iter103];
          output.writeString(iter103);
        }
      }
      output.writeSetEnd();
      output.writeFieldEnd();
    }
    if (this.fmEditKey !== null && this.fmEditKey !== undefined) {
      output.writeFieldBegin('fmEditKey', Thrift.Type.STRING, 37);
      output.writeString(this.fmEditKey);
      output.writeFieldEnd();
    }
    if (this.fmEditPersonal !== null && this.fmEditPersonal !== undefined) {
      output.writeFieldBegin('fmEditPersonal', Thrift.Type.BOOL, 38);
      output.writeBool(this.fmEditPersonal);
      output.writeFieldEnd();
    }
    if (this.fmEditClose !== null && this.fmEditClose !== undefined) {
      output.writeFieldBegin('fmEditClose', Thrift.Type.BOOL, 39);
      output.writeBool(this.fmEditClose);
      output.writeFieldEnd();
    }
    if (this.fmViewKey !== null && this.fmViewKey !== undefined) {
      output.writeFieldBegin('fmViewKey', Thrift.Type.STRING, 40);
      output.writeString(this.fmViewKey);
      output.writeFieldEnd();
    }
    if (this.fmViewPersonal !== null && this.fmViewPersonal !== undefined) {
      output.writeFieldBegin('fmViewPersonal', Thrift.Type.BOOL, 41);
      output.writeBool(this.fmViewPersonal);
      output.writeFieldEnd();
    }
    if (this.fmViewClose !== null && this.fmViewClose !== undefined) {
      output.writeFieldBegin('fmViewClose', Thrift.Type.BOOL, 42);
      output.writeBool(this.fmViewClose);
      output.writeFieldEnd();
    }
    if (this.preFunctionId !== null && this.preFunctionId !== undefined) {
      output.writeFieldBegin('preFunctionId', Thrift.Type.STRUCT, 43);
      this.preFunctionId.write(output);
      output.writeFieldEnd();
    }
    if (this.postFunctionId !== null && this.postFunctionId !== undefined) {
      output.writeFieldBegin('postFunctionId', Thrift.Type.STRUCT, 44);
      this.postFunctionId.write(output);
      output.writeFieldEnd();
    }
    if (this.showDocDetails !== null && this.showDocDetails !== undefined) {
      output.writeFieldBegin('showDocDetails', Thrift.Type.I32, 45);
      output.writeI32(this.showDocDetails);
      output.writeFieldEnd();
    }
    if (this.showChat !== null && this.showChat !== undefined) {
      output.writeFieldBegin('showChat', Thrift.Type.I32, 46);
      output.writeI32(this.showChat);
      output.writeFieldEnd();
    }
    if (this.showHistory !== null && this.showHistory !== undefined) {
      output.writeFieldBegin('showHistory', Thrift.Type.I32, 47);
      output.writeI32(this.showHistory);
      output.writeFieldEnd();
    }
    if (this.showAttachments !== null && this.showAttachments !== undefined) {
      output.writeFieldBegin('showAttachments', Thrift.Type.I32, 48);
      output.writeI32(this.showAttachments);
      output.writeFieldEnd();
    }
    if (this.notifMoveOnEnabled !== null && this.notifMoveOnEnabled !== undefined) {
      output.writeFieldBegin('notifMoveOnEnabled', Thrift.Type.BOOL, 49);
      output.writeBool(this.notifMoveOnEnabled);
      output.writeFieldEnd();
    }
    if (this.notifMoveOnChanel !== null && this.notifMoveOnChanel !== undefined) {
      output.writeFieldBegin('notifMoveOnChanel', Thrift.Type.STRING, 50);
      output.writeString(this.notifMoveOnChanel);
      output.writeFieldEnd();
    }
    if (this.notifPeriodicalEnabled !== null && this.notifPeriodicalEnabled !== undefined) {
      output.writeFieldBegin('notifPeriodicalEnabled', Thrift.Type.BOOL, 51);
      output.writeBool(this.notifPeriodicalEnabled);
      output.writeFieldEnd();
    }
    if (this.notifPeriodicalJira !== null && this.notifPeriodicalJira !== undefined) {
      output.writeFieldBegin('notifPeriodicalJira', Thrift.Type.STRING, 52);
      output.writeString(this.notifPeriodicalJira);
      output.writeFieldEnd();
    }
    if (this.notifPeriodicalChanel !== null && this.notifPeriodicalChanel !== undefined) {
      output.writeFieldBegin('notifPeriodicalChanel', Thrift.Type.STRING, 53);
      output.writeString(this.notifPeriodicalChanel);
      output.writeFieldEnd();
    }
    if (this.notifCheckDeadlineEnabled !== null && this.notifCheckDeadlineEnabled !== undefined) {
      output.writeFieldBegin('notifCheckDeadlineEnabled', Thrift.Type.BOOL, 54);
      output.writeBool(this.notifCheckDeadlineEnabled);
      output.writeFieldEnd();
    }
    if (this.notifCheckDeadlineJira !== null && this.notifCheckDeadlineJira !== undefined) {
      output.writeFieldBegin('notifCheckDeadlineJira', Thrift.Type.STRING, 55);
      output.writeString(this.notifCheckDeadlineJira);
      output.writeFieldEnd();
    }
    if (this.notifCheckDeadlineChanel !== null && this.notifCheckDeadlineChanel !== undefined) {
      output.writeFieldBegin('notifCheckDeadlineChanel', Thrift.Type.STRING, 56);
      output.writeString(this.notifCheckDeadlineChanel);
      output.writeFieldEnd();
    }
    if (this.notifCardExpiredEnabled !== null && this.notifCardExpiredEnabled !== undefined) {
      output.writeFieldBegin('notifCardExpiredEnabled', Thrift.Type.BOOL, 57);
      output.writeBool(this.notifCardExpiredEnabled);
      output.writeFieldEnd();
    }
    if (this.notifCardExpiredChanel !== null && this.notifCardExpiredChanel !== undefined) {
      output.writeFieldBegin('notifCardExpiredChanel', Thrift.Type.STRING, 58);
      output.writeString(this.notifCardExpiredChanel);
      output.writeFieldEnd();
    }
    if (this.orderNum !== null && this.orderNum !== undefined) {
      output.writeFieldBegin('orderNum', Thrift.Type.I32, 59);
      output.writeI32(this.orderNum);
      output.writeFieldEnd();
    }
    if (this.cardActivityPeriod !== null && this.cardActivityPeriod !== undefined) {
      output.writeFieldBegin('cardActivityPeriod', Thrift.Type.STRING, 60);
      output.writeString(this.cardActivityPeriod);
      output.writeFieldEnd();
    }
    if (this.stageContentHolders !== null && this.stageContentHolders !== undefined) {
      output.writeFieldBegin('stageContentHolders', Thrift.Type.LIST, 61);
      output.writeListBegin(Thrift.Type.STRUCT, this.stageContentHolders.length);
      for (let iter104 in this.stageContentHolders) {
        if (this.stageContentHolders.hasOwnProperty(iter104)) {
          iter104 = this.stageContentHolders[iter104];
          iter104.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.signAttachmentRule !== null && this.signAttachmentRule !== undefined) {
      output.writeFieldBegin('signAttachmentRule', Thrift.Type.STRUCT, 62);
      this.signAttachmentRule.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DesicionInfo = class {
  constructor(args) {
    this.freezeStage = null;
    this.holderShowPlace = null;
    if (args) {
      if (args.freezeStage !== undefined && args.freezeStage !== null) {
        this.freezeStage = new DocumentPatternStage(args.freezeStage);
      }
      if (args.holderShowPlace !== undefined && args.holderShowPlace !== null) {
        this.holderShowPlace = Thrift.copyList(args.holderShowPlace, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.freezeStage = new DocumentPatternStage();
          this.freezeStage.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.LIST) {
          this.holderShowPlace = [];
          const _rtmp3106 = input.readListBegin();
          const _size105 = _rtmp3106.size || 0;
          for (let _i107 = 0; _i107 < _size105; ++_i107) {
            let elem108 = null;
            elem108 = new ContentHolderShowPlace();
            elem108.read(input);
            this.holderShowPlace.push(elem108);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DesicionInfo');
    if (this.freezeStage !== null && this.freezeStage !== undefined) {
      output.writeFieldBegin('freezeStage', Thrift.Type.STRUCT, 1);
      this.freezeStage.write(output);
      output.writeFieldEnd();
    }
    if (this.holderShowPlace !== null && this.holderShowPlace !== undefined) {
      output.writeFieldBegin('holderShowPlace', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.STRUCT, this.holderShowPlace.length);
      for (let iter109 in this.holderShowPlace) {
        if (this.holderShowPlace.hasOwnProperty(iter109)) {
          iter109 = this.holderShowPlace[iter109];
          iter109.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentComment = class {
  constructor(args) {
    this.id = null;
    this.creatorId = null;
    this.creator = null;
    this.createDate = null;
    this.comment = null;
    this.documentId = null;
    this.executionId = null;
    this.theNewCommentId = null;
    this.oldCommentId = null;
    this.parentId = null;
    this.docSubStatusHistId = null;
    this.commentType = null;
    this.rootCreateDate = null;
    this.rootCreatorId = null;
    this.rootCreator = null;
    this.originalUser = null;
    this.modifierUser = null;
    this.modifiedDate = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.creatorId !== undefined && args.creatorId !== null) {
        this.creatorId = args.creatorId;
      }
      if (args.creator !== undefined && args.creator !== null) {
        this.creator = new UserOrGroup(args.creator);
      }
      if (args.createDate !== undefined && args.createDate !== null) {
        this.createDate = args.createDate;
      }
      if (args.comment !== undefined && args.comment !== null) {
        this.comment = args.comment;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.executionId !== undefined && args.executionId !== null) {
        this.executionId = args.executionId;
      }
      if (args.theNewCommentId !== undefined && args.theNewCommentId !== null) {
        this.theNewCommentId = args.theNewCommentId;
      }
      if (args.oldCommentId !== undefined && args.oldCommentId !== null) {
        this.oldCommentId = args.oldCommentId;
      }
      if (args.parentId !== undefined && args.parentId !== null) {
        this.parentId = args.parentId;
      }
      if (args.docSubStatusHistId !== undefined && args.docSubStatusHistId !== null) {
        this.docSubStatusHistId = args.docSubStatusHistId;
      }
      if (args.commentType !== undefined && args.commentType !== null) {
        this.commentType = args.commentType;
      }
      if (args.rootCreateDate !== undefined && args.rootCreateDate !== null) {
        this.rootCreateDate = args.rootCreateDate;
      }
      if (args.rootCreatorId !== undefined && args.rootCreatorId !== null) {
        this.rootCreatorId = args.rootCreatorId;
      }
      if (args.rootCreator !== undefined && args.rootCreator !== null) {
        this.rootCreator = new UserOrGroup(args.rootCreator);
      }
      if (args.originalUser !== undefined && args.originalUser !== null) {
        this.originalUser = new UserOrGroup(args.originalUser);
      }
      if (args.modifierUser !== undefined && args.modifierUser !== null) {
        this.modifierUser = new UserOrGroup(args.modifierUser);
      }
      if (args.modifiedDate !== undefined && args.modifiedDate !== null) {
        this.modifiedDate = args.modifiedDate;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.creatorId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.creator = new UserOrGroup();
          this.creator.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I64) {
          this.createDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRING) {
          this.comment = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.STRING) {
          this.executionId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.STRING) {
          this.theNewCommentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 9:
        if (ftype == Thrift.Type.STRING) {
          this.oldCommentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 10:
        if (ftype == Thrift.Type.STRING) {
          this.parentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 11:
        if (ftype == Thrift.Type.STRING) {
          this.docSubStatusHistId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 12:
        if (ftype == Thrift.Type.I32) {
          this.commentType = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 13:
        if (ftype == Thrift.Type.I64) {
          this.rootCreateDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 14:
        if (ftype == Thrift.Type.STRING) {
          this.rootCreatorId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 15:
        if (ftype == Thrift.Type.STRUCT) {
          this.rootCreator = new UserOrGroup();
          this.rootCreator.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 16:
        if (ftype == Thrift.Type.STRUCT) {
          this.originalUser = new UserOrGroup();
          this.originalUser.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 17:
        if (ftype == Thrift.Type.STRUCT) {
          this.modifierUser = new UserOrGroup();
          this.modifierUser.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 18:
        if (ftype == Thrift.Type.I64) {
          this.modifiedDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentComment');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.creatorId !== null && this.creatorId !== undefined) {
      output.writeFieldBegin('creatorId', Thrift.Type.STRING, 2);
      output.writeString(this.creatorId);
      output.writeFieldEnd();
    }
    if (this.creator !== null && this.creator !== undefined) {
      output.writeFieldBegin('creator', Thrift.Type.STRUCT, 3);
      this.creator.write(output);
      output.writeFieldEnd();
    }
    if (this.createDate !== null && this.createDate !== undefined) {
      output.writeFieldBegin('createDate', Thrift.Type.I64, 4);
      output.writeI64(this.createDate);
      output.writeFieldEnd();
    }
    if (this.comment !== null && this.comment !== undefined) {
      output.writeFieldBegin('comment', Thrift.Type.STRING, 5);
      output.writeString(this.comment);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 6);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.executionId !== null && this.executionId !== undefined) {
      output.writeFieldBegin('executionId', Thrift.Type.STRING, 7);
      output.writeString(this.executionId);
      output.writeFieldEnd();
    }
    if (this.theNewCommentId !== null && this.theNewCommentId !== undefined) {
      output.writeFieldBegin('theNewCommentId', Thrift.Type.STRING, 8);
      output.writeString(this.theNewCommentId);
      output.writeFieldEnd();
    }
    if (this.oldCommentId !== null && this.oldCommentId !== undefined) {
      output.writeFieldBegin('oldCommentId', Thrift.Type.STRING, 9);
      output.writeString(this.oldCommentId);
      output.writeFieldEnd();
    }
    if (this.parentId !== null && this.parentId !== undefined) {
      output.writeFieldBegin('parentId', Thrift.Type.STRING, 10);
      output.writeString(this.parentId);
      output.writeFieldEnd();
    }
    if (this.docSubStatusHistId !== null && this.docSubStatusHistId !== undefined) {
      output.writeFieldBegin('docSubStatusHistId', Thrift.Type.STRING, 11);
      output.writeString(this.docSubStatusHistId);
      output.writeFieldEnd();
    }
    if (this.commentType !== null && this.commentType !== undefined) {
      output.writeFieldBegin('commentType', Thrift.Type.I32, 12);
      output.writeI32(this.commentType);
      output.writeFieldEnd();
    }
    if (this.rootCreateDate !== null && this.rootCreateDate !== undefined) {
      output.writeFieldBegin('rootCreateDate', Thrift.Type.I64, 13);
      output.writeI64(this.rootCreateDate);
      output.writeFieldEnd();
    }
    if (this.rootCreatorId !== null && this.rootCreatorId !== undefined) {
      output.writeFieldBegin('rootCreatorId', Thrift.Type.STRING, 14);
      output.writeString(this.rootCreatorId);
      output.writeFieldEnd();
    }
    if (this.rootCreator !== null && this.rootCreator !== undefined) {
      output.writeFieldBegin('rootCreator', Thrift.Type.STRUCT, 15);
      this.rootCreator.write(output);
      output.writeFieldEnd();
    }
    if (this.originalUser !== null && this.originalUser !== undefined) {
      output.writeFieldBegin('originalUser', Thrift.Type.STRUCT, 16);
      this.originalUser.write(output);
      output.writeFieldEnd();
    }
    if (this.modifierUser !== null && this.modifierUser !== undefined) {
      output.writeFieldBegin('modifierUser', Thrift.Type.STRUCT, 17);
      this.modifierUser.write(output);
      output.writeFieldEnd();
    }
    if (this.modifiedDate !== null && this.modifiedDate !== undefined) {
      output.writeFieldBegin('modifiedDate', Thrift.Type.I64, 18);
      output.writeI64(this.modifiedDate);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentExecutionDelegateInfo = class {
  constructor(args) {
    this.id = null;
    this.createDate = null;
    this.documentExecutionId = null;
    this.internalActionIteration = null;
    this.originalUserId = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.createDate !== undefined && args.createDate !== null) {
        this.createDate = args.createDate;
      }
      if (args.documentExecutionId !== undefined && args.documentExecutionId !== null) {
        this.documentExecutionId = args.documentExecutionId;
      }
      if (args.internalActionIteration !== undefined && args.internalActionIteration !== null) {
        this.internalActionIteration = args.internalActionIteration;
      }
      if (args.originalUserId !== undefined && args.originalUserId !== null) {
        this.originalUserId = args.originalUserId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I64) {
          this.createDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.documentExecutionId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I32) {
          this.internalActionIteration = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRING) {
          this.originalUserId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentExecutionDelegateInfo');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.createDate !== null && this.createDate !== undefined) {
      output.writeFieldBegin('createDate', Thrift.Type.I64, 2);
      output.writeI64(this.createDate);
      output.writeFieldEnd();
    }
    if (this.documentExecutionId !== null && this.documentExecutionId !== undefined) {
      output.writeFieldBegin('documentExecutionId', Thrift.Type.STRING, 3);
      output.writeString(this.documentExecutionId);
      output.writeFieldEnd();
    }
    if (this.internalActionIteration !== null && this.internalActionIteration !== undefined) {
      output.writeFieldBegin('internalActionIteration', Thrift.Type.I32, 4);
      output.writeI32(this.internalActionIteration);
      output.writeFieldEnd();
    }
    if (this.originalUserId !== null && this.originalUserId !== undefined) {
      output.writeFieldBegin('originalUserId', Thrift.Type.STRING, 5);
      output.writeString(this.originalUserId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentExecution = class {
  constructor(args) {
    this.id = null;
    this.createDate = null;
    this.deleteDate = null;
    this.parentId = null;
    this.path = null;
    this.documentId = null;
    this.stageId = null;
    this.iteration = null;
    this.userOGroup = null;
    this.reassignType = null;
    this.deadlineDateTime = null;
    this.executionDateTime = null;
    this.reassignedDateTime = null;
    this.actionType = null;
    this.informedAboutDeadline = null;
    this.ownerType = null;
    this.decision = null;
    this.countAttachment = null;
    this.digitalSignId = null;
    this.closedBy = null;
    this.taskComment = null;
    this.originalUser = null;
    this.comments = null;
    this.internalCreateIteration = null;
    this.internalActionIteration = null;
    this.periodical = null;
    this.startPeriod = null;
    this.nextStartPeriod = null;
    this.periodicJiraEndDate = null;
    this.periodicEndDate = null;
    this.delegateInfo = null;
    this.status = null;
    this.handoverUser = null;
    this.taskCommentUpdateDate = null;
    this.taskCommentUpdateBy = null;
    this.reassignDigitalSignId = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.createDate !== undefined && args.createDate !== null) {
        this.createDate = args.createDate;
      }
      if (args.deleteDate !== undefined && args.deleteDate !== null) {
        this.deleteDate = args.deleteDate;
      }
      if (args.parentId !== undefined && args.parentId !== null) {
        this.parentId = args.parentId;
      }
      if (args.path !== undefined && args.path !== null) {
        this.path = args.path;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.stageId !== undefined && args.stageId !== null) {
        this.stageId = args.stageId;
      }
      if (args.iteration !== undefined && args.iteration !== null) {
        this.iteration = args.iteration;
      }
      if (args.userOGroup !== undefined && args.userOGroup !== null) {
        this.userOGroup = new UserOrGroup(args.userOGroup);
      }
      if (args.reassignType !== undefined && args.reassignType !== null) {
        this.reassignType = args.reassignType;
      }
      if (args.deadlineDateTime !== undefined && args.deadlineDateTime !== null) {
        this.deadlineDateTime = args.deadlineDateTime;
      }
      if (args.executionDateTime !== undefined && args.executionDateTime !== null) {
        this.executionDateTime = args.executionDateTime;
      }
      if (args.reassignedDateTime !== undefined && args.reassignedDateTime !== null) {
        this.reassignedDateTime = args.reassignedDateTime;
      }
      if (args.actionType !== undefined && args.actionType !== null) {
        this.actionType = args.actionType;
      }
      if (args.informedAboutDeadline !== undefined && args.informedAboutDeadline !== null) {
        this.informedAboutDeadline = args.informedAboutDeadline;
      }
      if (args.ownerType !== undefined && args.ownerType !== null) {
        this.ownerType = args.ownerType;
      }
      if (args.decision !== undefined && args.decision !== null) {
        this.decision = args.decision;
      }
      if (args.countAttachment !== undefined && args.countAttachment !== null) {
        this.countAttachment = args.countAttachment;
      }
      if (args.digitalSignId !== undefined && args.digitalSignId !== null) {
        this.digitalSignId = args.digitalSignId;
      }
      if (args.closedBy !== undefined && args.closedBy !== null) {
        this.closedBy = args.closedBy;
      }
      if (args.taskComment !== undefined && args.taskComment !== null) {
        this.taskComment = args.taskComment;
      }
      if (args.originalUser !== undefined && args.originalUser !== null) {
        this.originalUser = new UserOrGroup(args.originalUser);
      }
      if (args.comments !== undefined && args.comments !== null) {
        this.comments = Thrift.copyList(args.comments, [DocumentComment]);
      }
      if (args.internalCreateIteration !== undefined && args.internalCreateIteration !== null) {
        this.internalCreateIteration = args.internalCreateIteration;
      }
      if (args.internalActionIteration !== undefined && args.internalActionIteration !== null) {
        this.internalActionIteration = args.internalActionIteration;
      }
      if (args.periodical !== undefined && args.periodical !== null) {
        this.periodical = args.periodical;
      }
      if (args.startPeriod !== undefined && args.startPeriod !== null) {
        this.startPeriod = args.startPeriod;
      }
      if (args.nextStartPeriod !== undefined && args.nextStartPeriod !== null) {
        this.nextStartPeriod = args.nextStartPeriod;
      }
      if (args.periodicJiraEndDate !== undefined && args.periodicJiraEndDate !== null) {
        this.periodicJiraEndDate = args.periodicJiraEndDate;
      }
      if (args.periodicEndDate !== undefined && args.periodicEndDate !== null) {
        this.periodicEndDate = args.periodicEndDate;
      }
      if (args.delegateInfo !== undefined && args.delegateInfo !== null) {
        this.delegateInfo = Thrift.copyList(args.delegateInfo, [DocumentExecutionDelegateInfo]);
      }
      if (args.status !== undefined && args.status !== null) {
        this.status = args.status;
      }
      if (args.handoverUser !== undefined && args.handoverUser !== null) {
        this.handoverUser = new UserOrGroup(args.handoverUser);
      }
      if (args.taskCommentUpdateDate !== undefined && args.taskCommentUpdateDate !== null) {
        this.taskCommentUpdateDate = args.taskCommentUpdateDate;
      }
      if (args.taskCommentUpdateBy !== undefined && args.taskCommentUpdateBy !== null) {
        this.taskCommentUpdateBy = args.taskCommentUpdateBy;
      }
      if (args.reassignDigitalSignId !== undefined && args.reassignDigitalSignId !== null) {
        this.reassignDigitalSignId = args.reassignDigitalSignId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I64) {
          this.createDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I64) {
          this.deleteDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.parentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRING) {
          this.path = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.STRING) {
          this.stageId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.I32) {
          this.iteration = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 9:
        if (ftype == Thrift.Type.STRUCT) {
          this.userOGroup = new UserOrGroup();
          this.userOGroup.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 10:
        if (ftype == Thrift.Type.I32) {
          this.reassignType = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 11:
        if (ftype == Thrift.Type.I64) {
          this.deadlineDateTime = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 12:
        if (ftype == Thrift.Type.I64) {
          this.executionDateTime = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 13:
        if (ftype == Thrift.Type.I64) {
          this.reassignedDateTime = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 14:
        if (ftype == Thrift.Type.I32) {
          this.actionType = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 15:
        if (ftype == Thrift.Type.BOOL) {
          this.informedAboutDeadline = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 16:
        if (ftype == Thrift.Type.I32) {
          this.ownerType = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 17:
        if (ftype == Thrift.Type.STRING) {
          this.decision = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 18:
        if (ftype == Thrift.Type.I32) {
          this.countAttachment = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 19:
        if (ftype == Thrift.Type.STRING) {
          this.digitalSignId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 20:
        if (ftype == Thrift.Type.STRING) {
          this.closedBy = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 21:
        if (ftype == Thrift.Type.STRING) {
          this.taskComment = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 22:
        if (ftype == Thrift.Type.STRUCT) {
          this.originalUser = new UserOrGroup();
          this.originalUser.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 23:
        if (ftype == Thrift.Type.LIST) {
          this.comments = [];
          const _rtmp3111 = input.readListBegin();
          const _size110 = _rtmp3111.size || 0;
          for (let _i112 = 0; _i112 < _size110; ++_i112) {
            let elem113 = null;
            elem113 = new DocumentComment();
            elem113.read(input);
            this.comments.push(elem113);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 24:
        if (ftype == Thrift.Type.I32) {
          this.internalCreateIteration = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 25:
        if (ftype == Thrift.Type.I32) {
          this.internalActionIteration = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 26:
        if (ftype == Thrift.Type.BOOL) {
          this.periodical = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 27:
        if (ftype == Thrift.Type.I64) {
          this.startPeriod = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 28:
        if (ftype == Thrift.Type.STRING) {
          this.nextStartPeriod = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 29:
        if (ftype == Thrift.Type.STRING) {
          this.periodicJiraEndDate = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 30:
        if (ftype == Thrift.Type.I64) {
          this.periodicEndDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 31:
        if (ftype == Thrift.Type.LIST) {
          this.delegateInfo = [];
          const _rtmp3115 = input.readListBegin();
          const _size114 = _rtmp3115.size || 0;
          for (let _i116 = 0; _i116 < _size114; ++_i116) {
            let elem117 = null;
            elem117 = new DocumentExecutionDelegateInfo();
            elem117.read(input);
            this.delegateInfo.push(elem117);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 32:
        if (ftype == Thrift.Type.I32) {
          this.status = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 33:
        if (ftype == Thrift.Type.STRUCT) {
          this.handoverUser = new UserOrGroup();
          this.handoverUser.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 34:
        if (ftype == Thrift.Type.I64) {
          this.taskCommentUpdateDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 35:
        if (ftype == Thrift.Type.STRING) {
          this.taskCommentUpdateBy = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 36:
        if (ftype == Thrift.Type.STRING) {
          this.reassignDigitalSignId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentExecution');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.createDate !== null && this.createDate !== undefined) {
      output.writeFieldBegin('createDate', Thrift.Type.I64, 2);
      output.writeI64(this.createDate);
      output.writeFieldEnd();
    }
    if (this.deleteDate !== null && this.deleteDate !== undefined) {
      output.writeFieldBegin('deleteDate', Thrift.Type.I64, 3);
      output.writeI64(this.deleteDate);
      output.writeFieldEnd();
    }
    if (this.parentId !== null && this.parentId !== undefined) {
      output.writeFieldBegin('parentId', Thrift.Type.STRING, 4);
      output.writeString(this.parentId);
      output.writeFieldEnd();
    }
    if (this.path !== null && this.path !== undefined) {
      output.writeFieldBegin('path', Thrift.Type.STRING, 5);
      output.writeString(this.path);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 6);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.stageId !== null && this.stageId !== undefined) {
      output.writeFieldBegin('stageId', Thrift.Type.STRING, 7);
      output.writeString(this.stageId);
      output.writeFieldEnd();
    }
    if (this.iteration !== null && this.iteration !== undefined) {
      output.writeFieldBegin('iteration', Thrift.Type.I32, 8);
      output.writeI32(this.iteration);
      output.writeFieldEnd();
    }
    if (this.userOGroup !== null && this.userOGroup !== undefined) {
      output.writeFieldBegin('userOGroup', Thrift.Type.STRUCT, 9);
      this.userOGroup.write(output);
      output.writeFieldEnd();
    }
    if (this.reassignType !== null && this.reassignType !== undefined) {
      output.writeFieldBegin('reassignType', Thrift.Type.I32, 10);
      output.writeI32(this.reassignType);
      output.writeFieldEnd();
    }
    if (this.deadlineDateTime !== null && this.deadlineDateTime !== undefined) {
      output.writeFieldBegin('deadlineDateTime', Thrift.Type.I64, 11);
      output.writeI64(this.deadlineDateTime);
      output.writeFieldEnd();
    }
    if (this.executionDateTime !== null && this.executionDateTime !== undefined) {
      output.writeFieldBegin('executionDateTime', Thrift.Type.I64, 12);
      output.writeI64(this.executionDateTime);
      output.writeFieldEnd();
    }
    if (this.reassignedDateTime !== null && this.reassignedDateTime !== undefined) {
      output.writeFieldBegin('reassignedDateTime', Thrift.Type.I64, 13);
      output.writeI64(this.reassignedDateTime);
      output.writeFieldEnd();
    }
    if (this.actionType !== null && this.actionType !== undefined) {
      output.writeFieldBegin('actionType', Thrift.Type.I32, 14);
      output.writeI32(this.actionType);
      output.writeFieldEnd();
    }
    if (this.informedAboutDeadline !== null && this.informedAboutDeadline !== undefined) {
      output.writeFieldBegin('informedAboutDeadline', Thrift.Type.BOOL, 15);
      output.writeBool(this.informedAboutDeadline);
      output.writeFieldEnd();
    }
    if (this.ownerType !== null && this.ownerType !== undefined) {
      output.writeFieldBegin('ownerType', Thrift.Type.I32, 16);
      output.writeI32(this.ownerType);
      output.writeFieldEnd();
    }
    if (this.decision !== null && this.decision !== undefined) {
      output.writeFieldBegin('decision', Thrift.Type.STRING, 17);
      output.writeString(this.decision);
      output.writeFieldEnd();
    }
    if (this.countAttachment !== null && this.countAttachment !== undefined) {
      output.writeFieldBegin('countAttachment', Thrift.Type.I32, 18);
      output.writeI32(this.countAttachment);
      output.writeFieldEnd();
    }
    if (this.digitalSignId !== null && this.digitalSignId !== undefined) {
      output.writeFieldBegin('digitalSignId', Thrift.Type.STRING, 19);
      output.writeString(this.digitalSignId);
      output.writeFieldEnd();
    }
    if (this.closedBy !== null && this.closedBy !== undefined) {
      output.writeFieldBegin('closedBy', Thrift.Type.STRING, 20);
      output.writeString(this.closedBy);
      output.writeFieldEnd();
    }
    if (this.taskComment !== null && this.taskComment !== undefined) {
      output.writeFieldBegin('taskComment', Thrift.Type.STRING, 21);
      output.writeString(this.taskComment);
      output.writeFieldEnd();
    }
    if (this.originalUser !== null && this.originalUser !== undefined) {
      output.writeFieldBegin('originalUser', Thrift.Type.STRUCT, 22);
      this.originalUser.write(output);
      output.writeFieldEnd();
    }
    if (this.comments !== null && this.comments !== undefined) {
      output.writeFieldBegin('comments', Thrift.Type.LIST, 23);
      output.writeListBegin(Thrift.Type.STRUCT, this.comments.length);
      for (let iter118 in this.comments) {
        if (this.comments.hasOwnProperty(iter118)) {
          iter118 = this.comments[iter118];
          iter118.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.internalCreateIteration !== null && this.internalCreateIteration !== undefined) {
      output.writeFieldBegin('internalCreateIteration', Thrift.Type.I32, 24);
      output.writeI32(this.internalCreateIteration);
      output.writeFieldEnd();
    }
    if (this.internalActionIteration !== null && this.internalActionIteration !== undefined) {
      output.writeFieldBegin('internalActionIteration', Thrift.Type.I32, 25);
      output.writeI32(this.internalActionIteration);
      output.writeFieldEnd();
    }
    if (this.periodical !== null && this.periodical !== undefined) {
      output.writeFieldBegin('periodical', Thrift.Type.BOOL, 26);
      output.writeBool(this.periodical);
      output.writeFieldEnd();
    }
    if (this.startPeriod !== null && this.startPeriod !== undefined) {
      output.writeFieldBegin('startPeriod', Thrift.Type.I64, 27);
      output.writeI64(this.startPeriod);
      output.writeFieldEnd();
    }
    if (this.nextStartPeriod !== null && this.nextStartPeriod !== undefined) {
      output.writeFieldBegin('nextStartPeriod', Thrift.Type.STRING, 28);
      output.writeString(this.nextStartPeriod);
      output.writeFieldEnd();
    }
    if (this.periodicJiraEndDate !== null && this.periodicJiraEndDate !== undefined) {
      output.writeFieldBegin('periodicJiraEndDate', Thrift.Type.STRING, 29);
      output.writeString(this.periodicJiraEndDate);
      output.writeFieldEnd();
    }
    if (this.periodicEndDate !== null && this.periodicEndDate !== undefined) {
      output.writeFieldBegin('periodicEndDate', Thrift.Type.I64, 30);
      output.writeI64(this.periodicEndDate);
      output.writeFieldEnd();
    }
    if (this.delegateInfo !== null && this.delegateInfo !== undefined) {
      output.writeFieldBegin('delegateInfo', Thrift.Type.LIST, 31);
      output.writeListBegin(Thrift.Type.STRUCT, this.delegateInfo.length);
      for (let iter119 in this.delegateInfo) {
        if (this.delegateInfo.hasOwnProperty(iter119)) {
          iter119 = this.delegateInfo[iter119];
          iter119.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.status !== null && this.status !== undefined) {
      output.writeFieldBegin('status', Thrift.Type.I32, 32);
      output.writeI32(this.status);
      output.writeFieldEnd();
    }
    if (this.handoverUser !== null && this.handoverUser !== undefined) {
      output.writeFieldBegin('handoverUser', Thrift.Type.STRUCT, 33);
      this.handoverUser.write(output);
      output.writeFieldEnd();
    }
    if (this.taskCommentUpdateDate !== null && this.taskCommentUpdateDate !== undefined) {
      output.writeFieldBegin('taskCommentUpdateDate', Thrift.Type.I64, 34);
      output.writeI64(this.taskCommentUpdateDate);
      output.writeFieldEnd();
    }
    if (this.taskCommentUpdateBy !== null && this.taskCommentUpdateBy !== undefined) {
      output.writeFieldBegin('taskCommentUpdateBy', Thrift.Type.STRING, 35);
      output.writeString(this.taskCommentUpdateBy);
      output.writeFieldEnd();
    }
    if (this.reassignDigitalSignId !== null && this.reassignDigitalSignId !== undefined) {
      output.writeFieldBegin('reassignDigitalSignId', Thrift.Type.STRING, 36);
      output.writeString(this.reassignDigitalSignId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentParticipantGroup = class {
  constructor(args) {
    this.userOrGroup = null;
    this.dispatchState = null;
    if (args) {
      if (args.userOrGroup !== undefined && args.userOrGroup !== null) {
        this.userOrGroup = Thrift.copyList(args.userOrGroup, [UserOrGroup]);
      }
      if (args.dispatchState !== undefined && args.dispatchState !== null) {
        this.dispatchState = args.dispatchState;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.LIST) {
          this.userOrGroup = [];
          const _rtmp3121 = input.readListBegin();
          const _size120 = _rtmp3121.size || 0;
          for (let _i122 = 0; _i122 < _size120; ++_i122) {
            let elem123 = null;
            elem123 = new UserOrGroup();
            elem123.read(input);
            this.userOrGroup.push(elem123);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.dispatchState = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentParticipantGroup');
    if (this.userOrGroup !== null && this.userOrGroup !== undefined) {
      output.writeFieldBegin('userOrGroup', Thrift.Type.LIST, 1);
      output.writeListBegin(Thrift.Type.STRUCT, this.userOrGroup.length);
      for (let iter124 in this.userOrGroup) {
        if (this.userOrGroup.hasOwnProperty(iter124)) {
          iter124 = this.userOrGroup[iter124];
          iter124.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.dispatchState !== null && this.dispatchState !== undefined) {
      output.writeFieldBegin('dispatchState', Thrift.Type.I32, 2);
      output.writeI32(this.dispatchState);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
Document = class {
  constructor(args) {
    this.id = null;
    this.createDate = null;
    this.originalPatternId = null;
    this.filledDocumentPattern = null;
    this.stage = null;
    this.documentDeadlineDate = null;
    this.deleteDate = null;
    this.numberDocument = null;
    this.nameDocument = null;
    this.chatId = null;
    this.status = null;
    this.subStatus = null;
    this.hasExternalLink = null;
    this.reassignedDateTime = null;
    this.cardDeadlineDate = null;
    this.actionMap = null;
    this.ownerType = null;
    this.iteration = null;
    this.systemNumber = null;
    this.additionConfirmer = null;
    this.viewed = null;
    this.hasDigitalSign = null;
    this.currentExecutors = null;
    this.otherUsers = null;
    this.scChangeDate = null;
    this.registrationDate = null;
    this.sender = null;
    this.recipient = null;
    this.originalUser = null;
    this.documentParticipantGroup = null;
    this.controlForDocument = null;
    this.controlForExecutor = null;
    this.tags = null;
    this.account = null;
    this.moveError = null;
    this.encripted = null;
    this.icon = null;
    this.reassignDeadline = null;
    this.countCurrentExecutors = null;
    this.countOtherUsers = null;
    this.countResponsibleUsers = null;
    this.responsibleUsers = null;
    this.countConfirmerUsers = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.createDate !== undefined && args.createDate !== null) {
        this.createDate = args.createDate;
      }
      if (args.originalPatternId !== undefined && args.originalPatternId !== null) {
        this.originalPatternId = args.originalPatternId;
      }
      if (args.filledDocumentPattern !== undefined && args.filledDocumentPattern !== null) {
        this.filledDocumentPattern = new FreezeDocumentPattern(args.filledDocumentPattern);
      }
      if (args.stage !== undefined && args.stage !== null) {
        this.stage = new DocumentPatternStage(args.stage);
      }
      if (args.documentDeadlineDate !== undefined && args.documentDeadlineDate !== null) {
        this.documentDeadlineDate = args.documentDeadlineDate;
      }
      if (args.deleteDate !== undefined && args.deleteDate !== null) {
        this.deleteDate = args.deleteDate;
      }
      if (args.numberDocument !== undefined && args.numberDocument !== null) {
        this.numberDocument = args.numberDocument;
      }
      if (args.nameDocument !== undefined && args.nameDocument !== null) {
        this.nameDocument = args.nameDocument;
      }
      if (args.chatId !== undefined && args.chatId !== null) {
        this.chatId = args.chatId;
      }
      if (args.status !== undefined && args.status !== null) {
        this.status = args.status;
      }
      if (args.subStatus !== undefined && args.subStatus !== null) {
        this.subStatus = args.subStatus;
      }
      if (args.hasExternalLink !== undefined && args.hasExternalLink !== null) {
        this.hasExternalLink = args.hasExternalLink;
      }
      if (args.reassignedDateTime !== undefined && args.reassignedDateTime !== null) {
        this.reassignedDateTime = args.reassignedDateTime;
      }
      if (args.cardDeadlineDate !== undefined && args.cardDeadlineDate !== null) {
        this.cardDeadlineDate = args.cardDeadlineDate;
      }
      if (args.actionMap !== undefined && args.actionMap !== null) {
        this.actionMap = Thrift.copyMap(args.actionMap, [null]);
      }
      if (args.ownerType !== undefined && args.ownerType !== null) {
        this.ownerType = args.ownerType;
      }
      if (args.iteration !== undefined && args.iteration !== null) {
        this.iteration = args.iteration;
      }
      if (args.systemNumber !== undefined && args.systemNumber !== null) {
        this.systemNumber = args.systemNumber;
      }
      if (args.additionConfirmer !== undefined && args.additionConfirmer !== null) {
        this.additionConfirmer = args.additionConfirmer;
      }
      if (args.viewed !== undefined && args.viewed !== null) {
        this.viewed = args.viewed;
      }
      if (args.hasDigitalSign !== undefined && args.hasDigitalSign !== null) {
        this.hasDigitalSign = args.hasDigitalSign;
      }
      if (args.currentExecutors !== undefined && args.currentExecutors !== null) {
        this.currentExecutors = Thrift.copyList(args.currentExecutors, [DocumentExecution]);
      }
      if (args.otherUsers !== undefined && args.otherUsers !== null) {
        this.otherUsers = Thrift.copyList(args.otherUsers, [DocumentExecution]);
      }
      if (args.scChangeDate !== undefined && args.scChangeDate !== null) {
        this.scChangeDate = args.scChangeDate;
      }
      if (args.registrationDate !== undefined && args.registrationDate !== null) {
        this.registrationDate = args.registrationDate;
      }
      if (args.sender !== undefined && args.sender !== null) {
        this.sender = args.sender;
      }
      if (args.recipient !== undefined && args.recipient !== null) {
        this.recipient = args.recipient;
      }
      if (args.originalUser !== undefined && args.originalUser !== null) {
        this.originalUser = new UserOrGroup(args.originalUser);
      }
      if (args.documentParticipantGroup !== undefined && args.documentParticipantGroup !== null) {
        this.documentParticipantGroup = Thrift.copyList(args.documentParticipantGroup, [DocumentParticipantGroup]);
      }
      if (args.controlForDocument !== undefined && args.controlForDocument !== null) {
        this.controlForDocument = args.controlForDocument;
      }
      if (args.controlForExecutor !== undefined && args.controlForExecutor !== null) {
        this.controlForExecutor = args.controlForExecutor;
      }
      if (args.tags !== undefined && args.tags !== null) {
        this.tags = Thrift.copyList(args.tags, [null]);
      }
      if (args.account !== undefined && args.account !== null) {
        this.account = new Account(args.account);
      }
      if (args.moveError !== undefined && args.moveError !== null) {
        this.moveError = args.moveError;
      }
      if (args.encripted !== undefined && args.encripted !== null) {
        this.encripted = args.encripted;
      }
      if (args.icon !== undefined && args.icon !== null) {
        this.icon = args.icon;
      }
      if (args.reassignDeadline !== undefined && args.reassignDeadline !== null) {
        this.reassignDeadline = args.reassignDeadline;
      }
      if (args.countCurrentExecutors !== undefined && args.countCurrentExecutors !== null) {
        this.countCurrentExecutors = args.countCurrentExecutors;
      }
      if (args.countOtherUsers !== undefined && args.countOtherUsers !== null) {
        this.countOtherUsers = args.countOtherUsers;
      }
      if (args.countResponsibleUsers !== undefined && args.countResponsibleUsers !== null) {
        this.countResponsibleUsers = args.countResponsibleUsers;
      }
      if (args.responsibleUsers !== undefined && args.responsibleUsers !== null) {
        this.responsibleUsers = Thrift.copyList(args.responsibleUsers, [DocumentExecution]);
      }
      if (args.countConfirmerUsers !== undefined && args.countConfirmerUsers !== null) {
        this.countConfirmerUsers = args.countConfirmerUsers;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I64) {
          this.createDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.originalPatternId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.filledDocumentPattern = new FreezeDocumentPattern();
          this.filledDocumentPattern.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRUCT) {
          this.stage = new DocumentPatternStage();
          this.stage.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.I64) {
          this.documentDeadlineDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.I64) {
          this.deleteDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.STRING) {
          this.numberDocument = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 9:
        if (ftype == Thrift.Type.STRING) {
          this.nameDocument = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 10:
        if (ftype == Thrift.Type.STRING) {
          this.chatId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 11:
        if (ftype == Thrift.Type.I32) {
          this.status = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 12:
        if (ftype == Thrift.Type.I32) {
          this.subStatus = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 13:
        if (ftype == Thrift.Type.BOOL) {
          this.hasExternalLink = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 14:
        if (ftype == Thrift.Type.I64) {
          this.reassignedDateTime = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 15:
        if (ftype == Thrift.Type.I64) {
          this.cardDeadlineDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 16:
        if (ftype == Thrift.Type.MAP) {
          this.actionMap = {};
          const _rtmp3126 = input.readMapBegin();
          const _size125 = _rtmp3126.size || 0;
          for (let _i127 = 0; _i127 < _size125; ++_i127) {
            if (_i127 > 0 ) {
              if (input.rstack.length > input.rpos[input.rpos.length -1] + 1) {
                input.rstack.pop();
              }
            }
            let key128 = null;
            let val129 = null;
            key128 = input.readString().value;
            val129 = input.readI32().value;
            this.actionMap[key128] = val129;
          }
          input.readMapEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 17:
        if (ftype == Thrift.Type.I32) {
          this.ownerType = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 18:
        if (ftype == Thrift.Type.I32) {
          this.iteration = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 19:
        if (ftype == Thrift.Type.STRING) {
          this.systemNumber = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 20:
        if (ftype == Thrift.Type.BOOL) {
          this.additionConfirmer = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 21:
        if (ftype == Thrift.Type.BOOL) {
          this.viewed = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 22:
        if (ftype == Thrift.Type.BOOL) {
          this.hasDigitalSign = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 23:
        if (ftype == Thrift.Type.LIST) {
          this.currentExecutors = [];
          const _rtmp3131 = input.readListBegin();
          const _size130 = _rtmp3131.size || 0;
          for (let _i132 = 0; _i132 < _size130; ++_i132) {
            let elem133 = null;
            elem133 = new DocumentExecution();
            elem133.read(input);
            this.currentExecutors.push(elem133);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 24:
        if (ftype == Thrift.Type.LIST) {
          this.otherUsers = [];
          const _rtmp3135 = input.readListBegin();
          const _size134 = _rtmp3135.size || 0;
          for (let _i136 = 0; _i136 < _size134; ++_i136) {
            let elem137 = null;
            elem137 = new DocumentExecution();
            elem137.read(input);
            this.otherUsers.push(elem137);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 25:
        if (ftype == Thrift.Type.I64) {
          this.scChangeDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 26:
        if (ftype == Thrift.Type.I64) {
          this.registrationDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 27:
        if (ftype == Thrift.Type.BOOL) {
          this.sender = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 28:
        if (ftype == Thrift.Type.BOOL) {
          this.recipient = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 29:
        if (ftype == Thrift.Type.STRUCT) {
          this.originalUser = new UserOrGroup();
          this.originalUser.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 30:
        if (ftype == Thrift.Type.LIST) {
          this.documentParticipantGroup = [];
          const _rtmp3139 = input.readListBegin();
          const _size138 = _rtmp3139.size || 0;
          for (let _i140 = 0; _i140 < _size138; ++_i140) {
            let elem141 = null;
            elem141 = new DocumentParticipantGroup();
            elem141.read(input);
            this.documentParticipantGroup.push(elem141);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 31:
        if (ftype == Thrift.Type.BOOL) {
          this.controlForDocument = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 32:
        if (ftype == Thrift.Type.BOOL) {
          this.controlForExecutor = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 33:
        if (ftype == Thrift.Type.LIST) {
          this.tags = [];
          const _rtmp3143 = input.readListBegin();
          const _size142 = _rtmp3143.size || 0;
          for (let _i144 = 0; _i144 < _size142; ++_i144) {
            let elem145 = null;
            elem145 = input.readString().value;
            this.tags.push(elem145);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 34:
        if (ftype == Thrift.Type.STRUCT) {
          this.account = new Account();
          this.account.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 35:
        if (ftype == Thrift.Type.BOOL) {
          this.moveError = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 36:
        if (ftype == Thrift.Type.BOOL) {
          this.encripted = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 37:
        if (ftype == Thrift.Type.I32) {
          this.icon = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 38:
        if (ftype == Thrift.Type.I64) {
          this.reassignDeadline = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 39:
        if (ftype == Thrift.Type.I32) {
          this.countCurrentExecutors = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 40:
        if (ftype == Thrift.Type.I32) {
          this.countOtherUsers = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 41:
        if (ftype == Thrift.Type.I32) {
          this.countResponsibleUsers = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 42:
        if (ftype == Thrift.Type.LIST) {
          this.responsibleUsers = [];
          const _rtmp3147 = input.readListBegin();
          const _size146 = _rtmp3147.size || 0;
          for (let _i148 = 0; _i148 < _size146; ++_i148) {
            let elem149 = null;
            elem149 = new DocumentExecution();
            elem149.read(input);
            this.responsibleUsers.push(elem149);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 43:
        if (ftype == Thrift.Type.I32) {
          this.countConfirmerUsers = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Document');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.createDate !== null && this.createDate !== undefined) {
      output.writeFieldBegin('createDate', Thrift.Type.I64, 2);
      output.writeI64(this.createDate);
      output.writeFieldEnd();
    }
    if (this.originalPatternId !== null && this.originalPatternId !== undefined) {
      output.writeFieldBegin('originalPatternId', Thrift.Type.STRING, 3);
      output.writeString(this.originalPatternId);
      output.writeFieldEnd();
    }
    if (this.filledDocumentPattern !== null && this.filledDocumentPattern !== undefined) {
      output.writeFieldBegin('filledDocumentPattern', Thrift.Type.STRUCT, 4);
      this.filledDocumentPattern.write(output);
      output.writeFieldEnd();
    }
    if (this.stage !== null && this.stage !== undefined) {
      output.writeFieldBegin('stage', Thrift.Type.STRUCT, 5);
      this.stage.write(output);
      output.writeFieldEnd();
    }
    if (this.documentDeadlineDate !== null && this.documentDeadlineDate !== undefined) {
      output.writeFieldBegin('documentDeadlineDate', Thrift.Type.I64, 6);
      output.writeI64(this.documentDeadlineDate);
      output.writeFieldEnd();
    }
    if (this.deleteDate !== null && this.deleteDate !== undefined) {
      output.writeFieldBegin('deleteDate', Thrift.Type.I64, 7);
      output.writeI64(this.deleteDate);
      output.writeFieldEnd();
    }
    if (this.numberDocument !== null && this.numberDocument !== undefined) {
      output.writeFieldBegin('numberDocument', Thrift.Type.STRING, 8);
      output.writeString(this.numberDocument);
      output.writeFieldEnd();
    }
    if (this.nameDocument !== null && this.nameDocument !== undefined) {
      output.writeFieldBegin('nameDocument', Thrift.Type.STRING, 9);
      output.writeString(this.nameDocument);
      output.writeFieldEnd();
    }
    if (this.chatId !== null && this.chatId !== undefined) {
      output.writeFieldBegin('chatId', Thrift.Type.STRING, 10);
      output.writeString(this.chatId);
      output.writeFieldEnd();
    }
    if (this.status !== null && this.status !== undefined) {
      output.writeFieldBegin('status', Thrift.Type.I32, 11);
      output.writeI32(this.status);
      output.writeFieldEnd();
    }
    if (this.subStatus !== null && this.subStatus !== undefined) {
      output.writeFieldBegin('subStatus', Thrift.Type.I32, 12);
      output.writeI32(this.subStatus);
      output.writeFieldEnd();
    }
    if (this.hasExternalLink !== null && this.hasExternalLink !== undefined) {
      output.writeFieldBegin('hasExternalLink', Thrift.Type.BOOL, 13);
      output.writeBool(this.hasExternalLink);
      output.writeFieldEnd();
    }
    if (this.reassignedDateTime !== null && this.reassignedDateTime !== undefined) {
      output.writeFieldBegin('reassignedDateTime', Thrift.Type.I64, 14);
      output.writeI64(this.reassignedDateTime);
      output.writeFieldEnd();
    }
    if (this.cardDeadlineDate !== null && this.cardDeadlineDate !== undefined) {
      output.writeFieldBegin('cardDeadlineDate', Thrift.Type.I64, 15);
      output.writeI64(this.cardDeadlineDate);
      output.writeFieldEnd();
    }
    if (this.actionMap !== null && this.actionMap !== undefined) {
      output.writeFieldBegin('actionMap', Thrift.Type.MAP, 16);
      output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.I32, Thrift.objectLength(this.actionMap));
      for (let kiter150 in this.actionMap) {
        if (this.actionMap.hasOwnProperty(kiter150)) {
          let viter151 = this.actionMap[kiter150];
          output.writeString(kiter150);
          output.writeI32(viter151);
        }
      }
      output.writeMapEnd();
      output.writeFieldEnd();
    }
    if (this.ownerType !== null && this.ownerType !== undefined) {
      output.writeFieldBegin('ownerType', Thrift.Type.I32, 17);
      output.writeI32(this.ownerType);
      output.writeFieldEnd();
    }
    if (this.iteration !== null && this.iteration !== undefined) {
      output.writeFieldBegin('iteration', Thrift.Type.I32, 18);
      output.writeI32(this.iteration);
      output.writeFieldEnd();
    }
    if (this.systemNumber !== null && this.systemNumber !== undefined) {
      output.writeFieldBegin('systemNumber', Thrift.Type.STRING, 19);
      output.writeString(this.systemNumber);
      output.writeFieldEnd();
    }
    if (this.additionConfirmer !== null && this.additionConfirmer !== undefined) {
      output.writeFieldBegin('additionConfirmer', Thrift.Type.BOOL, 20);
      output.writeBool(this.additionConfirmer);
      output.writeFieldEnd();
    }
    if (this.viewed !== null && this.viewed !== undefined) {
      output.writeFieldBegin('viewed', Thrift.Type.BOOL, 21);
      output.writeBool(this.viewed);
      output.writeFieldEnd();
    }
    if (this.hasDigitalSign !== null && this.hasDigitalSign !== undefined) {
      output.writeFieldBegin('hasDigitalSign', Thrift.Type.BOOL, 22);
      output.writeBool(this.hasDigitalSign);
      output.writeFieldEnd();
    }
    if (this.currentExecutors !== null && this.currentExecutors !== undefined) {
      output.writeFieldBegin('currentExecutors', Thrift.Type.LIST, 23);
      output.writeListBegin(Thrift.Type.STRUCT, this.currentExecutors.length);
      for (let iter152 in this.currentExecutors) {
        if (this.currentExecutors.hasOwnProperty(iter152)) {
          iter152 = this.currentExecutors[iter152];
          iter152.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.otherUsers !== null && this.otherUsers !== undefined) {
      output.writeFieldBegin('otherUsers', Thrift.Type.LIST, 24);
      output.writeListBegin(Thrift.Type.STRUCT, this.otherUsers.length);
      for (let iter153 in this.otherUsers) {
        if (this.otherUsers.hasOwnProperty(iter153)) {
          iter153 = this.otherUsers[iter153];
          iter153.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.scChangeDate !== null && this.scChangeDate !== undefined) {
      output.writeFieldBegin('scChangeDate', Thrift.Type.I64, 25);
      output.writeI64(this.scChangeDate);
      output.writeFieldEnd();
    }
    if (this.registrationDate !== null && this.registrationDate !== undefined) {
      output.writeFieldBegin('registrationDate', Thrift.Type.I64, 26);
      output.writeI64(this.registrationDate);
      output.writeFieldEnd();
    }
    if (this.sender !== null && this.sender !== undefined) {
      output.writeFieldBegin('sender', Thrift.Type.BOOL, 27);
      output.writeBool(this.sender);
      output.writeFieldEnd();
    }
    if (this.recipient !== null && this.recipient !== undefined) {
      output.writeFieldBegin('recipient', Thrift.Type.BOOL, 28);
      output.writeBool(this.recipient);
      output.writeFieldEnd();
    }
    if (this.originalUser !== null && this.originalUser !== undefined) {
      output.writeFieldBegin('originalUser', Thrift.Type.STRUCT, 29);
      this.originalUser.write(output);
      output.writeFieldEnd();
    }
    if (this.documentParticipantGroup !== null && this.documentParticipantGroup !== undefined) {
      output.writeFieldBegin('documentParticipantGroup', Thrift.Type.LIST, 30);
      output.writeListBegin(Thrift.Type.STRUCT, this.documentParticipantGroup.length);
      for (let iter154 in this.documentParticipantGroup) {
        if (this.documentParticipantGroup.hasOwnProperty(iter154)) {
          iter154 = this.documentParticipantGroup[iter154];
          iter154.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.controlForDocument !== null && this.controlForDocument !== undefined) {
      output.writeFieldBegin('controlForDocument', Thrift.Type.BOOL, 31);
      output.writeBool(this.controlForDocument);
      output.writeFieldEnd();
    }
    if (this.controlForExecutor !== null && this.controlForExecutor !== undefined) {
      output.writeFieldBegin('controlForExecutor', Thrift.Type.BOOL, 32);
      output.writeBool(this.controlForExecutor);
      output.writeFieldEnd();
    }
    if (this.tags !== null && this.tags !== undefined) {
      output.writeFieldBegin('tags', Thrift.Type.LIST, 33);
      output.writeListBegin(Thrift.Type.STRING, this.tags.length);
      for (let iter155 in this.tags) {
        if (this.tags.hasOwnProperty(iter155)) {
          iter155 = this.tags[iter155];
          output.writeString(iter155);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.account !== null && this.account !== undefined) {
      output.writeFieldBegin('account', Thrift.Type.STRUCT, 34);
      this.account.write(output);
      output.writeFieldEnd();
    }
    if (this.moveError !== null && this.moveError !== undefined) {
      output.writeFieldBegin('moveError', Thrift.Type.BOOL, 35);
      output.writeBool(this.moveError);
      output.writeFieldEnd();
    }
    if (this.encripted !== null && this.encripted !== undefined) {
      output.writeFieldBegin('encripted', Thrift.Type.BOOL, 36);
      output.writeBool(this.encripted);
      output.writeFieldEnd();
    }
    if (this.icon !== null && this.icon !== undefined) {
      output.writeFieldBegin('icon', Thrift.Type.I32, 37);
      output.writeI32(this.icon);
      output.writeFieldEnd();
    }
    if (this.reassignDeadline !== null && this.reassignDeadline !== undefined) {
      output.writeFieldBegin('reassignDeadline', Thrift.Type.I64, 38);
      output.writeI64(this.reassignDeadline);
      output.writeFieldEnd();
    }
    if (this.countCurrentExecutors !== null && this.countCurrentExecutors !== undefined) {
      output.writeFieldBegin('countCurrentExecutors', Thrift.Type.I32, 39);
      output.writeI32(this.countCurrentExecutors);
      output.writeFieldEnd();
    }
    if (this.countOtherUsers !== null && this.countOtherUsers !== undefined) {
      output.writeFieldBegin('countOtherUsers', Thrift.Type.I32, 40);
      output.writeI32(this.countOtherUsers);
      output.writeFieldEnd();
    }
    if (this.countResponsibleUsers !== null && this.countResponsibleUsers !== undefined) {
      output.writeFieldBegin('countResponsibleUsers', Thrift.Type.I32, 41);
      output.writeI32(this.countResponsibleUsers);
      output.writeFieldEnd();
    }
    if (this.responsibleUsers !== null && this.responsibleUsers !== undefined) {
      output.writeFieldBegin('responsibleUsers', Thrift.Type.LIST, 42);
      output.writeListBegin(Thrift.Type.STRUCT, this.responsibleUsers.length);
      for (let iter156 in this.responsibleUsers) {
        if (this.responsibleUsers.hasOwnProperty(iter156)) {
          iter156 = this.responsibleUsers[iter156];
          iter156.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.countConfirmerUsers !== null && this.countConfirmerUsers !== undefined) {
      output.writeFieldBegin('countConfirmerUsers', Thrift.Type.I32, 43);
      output.writeI32(this.countConfirmerUsers);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AttachmentPermissions = class {
  constructor(args) {
    this.onlineEdit = null;
    this.onlineComment = null;
    this.changeEditMode = null;
    this.canSign = null;
    if (args) {
      if (args.onlineEdit !== undefined && args.onlineEdit !== null) {
        this.onlineEdit = args.onlineEdit;
      }
      if (args.onlineComment !== undefined && args.onlineComment !== null) {
        this.onlineComment = args.onlineComment;
      }
      if (args.changeEditMode !== undefined && args.changeEditMode !== null) {
        this.changeEditMode = args.changeEditMode;
      }
      if (args.canSign !== undefined && args.canSign !== null) {
        this.canSign = args.canSign;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.BOOL) {
          this.onlineEdit = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.BOOL) {
          this.onlineComment = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.BOOL) {
          this.changeEditMode = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.BOOL) {
          this.canSign = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AttachmentPermissions');
    if (this.onlineEdit !== null && this.onlineEdit !== undefined) {
      output.writeFieldBegin('onlineEdit', Thrift.Type.BOOL, 1);
      output.writeBool(this.onlineEdit);
      output.writeFieldEnd();
    }
    if (this.onlineComment !== null && this.onlineComment !== undefined) {
      output.writeFieldBegin('onlineComment', Thrift.Type.BOOL, 2);
      output.writeBool(this.onlineComment);
      output.writeFieldEnd();
    }
    if (this.changeEditMode !== null && this.changeEditMode !== undefined) {
      output.writeFieldBegin('changeEditMode', Thrift.Type.BOOL, 3);
      output.writeBool(this.changeEditMode);
      output.writeFieldEnd();
    }
    if (this.canSign !== null && this.canSign !== undefined) {
      output.writeFieldBegin('canSign', Thrift.Type.BOOL, 4);
      output.writeBool(this.canSign);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AttachmentVersionInfo = class {
  constructor(args) {
    this.id = null;
    this.status = null;
    this.precalculatedRank = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.status !== undefined && args.status !== null) {
        this.status = args.status;
      }
      if (args.precalculatedRank !== undefined && args.precalculatedRank !== null) {
        this.precalculatedRank = args.precalculatedRank;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.status = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I32) {
          this.precalculatedRank = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AttachmentVersionInfo');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.status !== null && this.status !== undefined) {
      output.writeFieldBegin('status', Thrift.Type.I32, 2);
      output.writeI32(this.status);
      output.writeFieldEnd();
    }
    if (this.precalculatedRank !== null && this.precalculatedRank !== undefined) {
      output.writeFieldBegin('precalculatedRank', Thrift.Type.I32, 3);
      output.writeI32(this.precalculatedRank);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
Attachment = class {
  constructor(args) {
    this.id = null;
    this.documentId = null;
    this.fileName = null;
    this.createDate = null;
    this.attHash = null;
    this.preview = null;
    this.creatorId = null;
    this.creator = null;
    this.size = null;
    this.status = null;
    this.stageId = null;
    this.hasDigitalSign = null;
    this.docExecId = null;
    this.autoReplacement = null;
    this.originalUserId = null;
    this.originalUser = null;
    this.forDraft = null;
    this.waitForPublish = null;
    this.fVersion = null;
    this.iteration = null;
    this.attachmentPermissions = null;
    this.versionCount = null;
    this.fType = null;
    this.accessMode = null;
    this.editMode = null;
    this.externalId = null;
    this.meetingId = null;
    this.attachmentExtStatus = null;
    this.versionInfo = null;
    this.patternAttachmentTemplateId = null;
    this.isHidden = null;
    this.signCertKeys = null;
    this.autoAdd = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.fileName !== undefined && args.fileName !== null) {
        this.fileName = args.fileName;
      }
      if (args.createDate !== undefined && args.createDate !== null) {
        this.createDate = args.createDate;
      }
      if (args.attHash !== undefined && args.attHash !== null) {
        this.attHash = args.attHash;
      }
      if (args.preview !== undefined && args.preview !== null) {
        this.preview = Thrift.copyList(args.preview, [null]);
      }
      if (args.creatorId !== undefined && args.creatorId !== null) {
        this.creatorId = args.creatorId;
      }
      if (args.creator !== undefined && args.creator !== null) {
        this.creator = new UserOrGroup(args.creator);
      }
      if (args.size !== undefined && args.size !== null) {
        this.size = args.size;
      }
      if (args.status !== undefined && args.status !== null) {
        this.status = args.status;
      }
      if (args.stageId !== undefined && args.stageId !== null) {
        this.stageId = args.stageId;
      }
      if (args.hasDigitalSign !== undefined && args.hasDigitalSign !== null) {
        this.hasDigitalSign = args.hasDigitalSign;
      }
      if (args.docExecId !== undefined && args.docExecId !== null) {
        this.docExecId = args.docExecId;
      }
      if (args.autoReplacement !== undefined && args.autoReplacement !== null) {
        this.autoReplacement = args.autoReplacement;
      }
      if (args.originalUserId !== undefined && args.originalUserId !== null) {
        this.originalUserId = args.originalUserId;
      }
      if (args.originalUser !== undefined && args.originalUser !== null) {
        this.originalUser = new UserOrGroup(args.originalUser);
      }
      if (args.forDraft !== undefined && args.forDraft !== null) {
        this.forDraft = args.forDraft;
      }
      if (args.waitForPublish !== undefined && args.waitForPublish !== null) {
        this.waitForPublish = args.waitForPublish;
      }
      if (args.fVersion !== undefined && args.fVersion !== null) {
        this.fVersion = args.fVersion;
      }
      if (args.iteration !== undefined && args.iteration !== null) {
        this.iteration = args.iteration;
      }
      if (args.attachmentPermissions !== undefined && args.attachmentPermissions !== null) {
        this.attachmentPermissions = new AttachmentPermissions(args.attachmentPermissions);
      }
      if (args.versionCount !== undefined && args.versionCount !== null) {
        this.versionCount = args.versionCount;
      }
      if (args.fType !== undefined && args.fType !== null) {
        this.fType = args.fType;
      }
      if (args.accessMode !== undefined && args.accessMode !== null) {
        this.accessMode = args.accessMode;
      }
      if (args.editMode !== undefined && args.editMode !== null) {
        this.editMode = args.editMode;
      }
      if (args.externalId !== undefined && args.externalId !== null) {
        this.externalId = args.externalId;
      }
      if (args.meetingId !== undefined && args.meetingId !== null) {
        this.meetingId = args.meetingId;
      }
      if (args.attachmentExtStatus !== undefined && args.attachmentExtStatus !== null) {
        this.attachmentExtStatus = args.attachmentExtStatus;
      }
      if (args.versionInfo !== undefined && args.versionInfo !== null) {
        this.versionInfo = Thrift.copyList(args.versionInfo, [AttachmentVersionInfo]);
      }
      if (args.patternAttachmentTemplateId !== undefined && args.patternAttachmentTemplateId !== null) {
        this.patternAttachmentTemplateId = args.patternAttachmentTemplateId;
      }
      if (args.isHidden !== undefined && args.isHidden !== null) {
        this.isHidden = args.isHidden;
      }
      if (args.signCertKeys !== undefined && args.signCertKeys !== null) {
        this.signCertKeys = Thrift.copyList(args.signCertKeys, [null]);
      }
      if (args.autoAdd !== undefined && args.autoAdd !== null) {
        this.autoAdd = args.autoAdd;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.fileName = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I64) {
          this.createDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRING) {
          this.attHash = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.LIST) {
          this.preview = [];
          const _rtmp3158 = input.readListBegin();
          const _size157 = _rtmp3158.size || 0;
          for (let _i159 = 0; _i159 < _size157; ++_i159) {
            let elem160 = null;
            elem160 = input.readI32().value;
            this.preview.push(elem160);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.STRING) {
          this.creatorId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.STRUCT) {
          this.creator = new UserOrGroup();
          this.creator.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 9:
        if (ftype == Thrift.Type.I64) {
          this.size = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 10:
        if (ftype == Thrift.Type.I32) {
          this.status = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 11:
        if (ftype == Thrift.Type.STRING) {
          this.stageId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 12:
        if (ftype == Thrift.Type.BOOL) {
          this.hasDigitalSign = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 13:
        if (ftype == Thrift.Type.STRING) {
          this.docExecId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 14:
        if (ftype == Thrift.Type.BOOL) {
          this.autoReplacement = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 15:
        if (ftype == Thrift.Type.STRING) {
          this.originalUserId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 16:
        if (ftype == Thrift.Type.STRUCT) {
          this.originalUser = new UserOrGroup();
          this.originalUser.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 17:
        if (ftype == Thrift.Type.BOOL) {
          this.forDraft = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 18:
        if (ftype == Thrift.Type.BOOL) {
          this.waitForPublish = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 19:
        if (ftype == Thrift.Type.I64) {
          this.fVersion = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 20:
        if (ftype == Thrift.Type.I32) {
          this.iteration = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 21:
        if (ftype == Thrift.Type.STRUCT) {
          this.attachmentPermissions = new AttachmentPermissions();
          this.attachmentPermissions.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 22:
        if (ftype == Thrift.Type.I32) {
          this.versionCount = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 23:
        if (ftype == Thrift.Type.I32) {
          this.fType = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 24:
        if (ftype == Thrift.Type.I32) {
          this.accessMode = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 25:
        if (ftype == Thrift.Type.I32) {
          this.editMode = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 26:
        if (ftype == Thrift.Type.STRING) {
          this.externalId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 27:
        if (ftype == Thrift.Type.STRING) {
          this.meetingId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 28:
        if (ftype == Thrift.Type.I32) {
          this.attachmentExtStatus = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 29:
        if (ftype == Thrift.Type.LIST) {
          this.versionInfo = [];
          const _rtmp3162 = input.readListBegin();
          const _size161 = _rtmp3162.size || 0;
          for (let _i163 = 0; _i163 < _size161; ++_i163) {
            let elem164 = null;
            elem164 = new AttachmentVersionInfo();
            elem164.read(input);
            this.versionInfo.push(elem164);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 30:
        if (ftype == Thrift.Type.STRING) {
          this.patternAttachmentTemplateId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 31:
        if (ftype == Thrift.Type.BOOL) {
          this.isHidden = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 32:
        if (ftype == Thrift.Type.SET) {
          this.signCertKeys = [];
          const _rtmp3166 = input.readSetBegin();
          const _size165 = _rtmp3166.size || 0;
          for (let _i167 = 0; _i167 < _size165; ++_i167) {
            let elem168 = null;
            elem168 = input.readString().value;
            this.signCertKeys.push(elem168);
          }
          input.readSetEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 33:
        if (ftype == Thrift.Type.BOOL) {
          this.autoAdd = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Attachment');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.fileName !== null && this.fileName !== undefined) {
      output.writeFieldBegin('fileName', Thrift.Type.STRING, 3);
      output.writeString(this.fileName);
      output.writeFieldEnd();
    }
    if (this.createDate !== null && this.createDate !== undefined) {
      output.writeFieldBegin('createDate', Thrift.Type.I64, 4);
      output.writeI64(this.createDate);
      output.writeFieldEnd();
    }
    if (this.attHash !== null && this.attHash !== undefined) {
      output.writeFieldBegin('attHash', Thrift.Type.STRING, 5);
      output.writeString(this.attHash);
      output.writeFieldEnd();
    }
    if (this.preview !== null && this.preview !== undefined) {
      output.writeFieldBegin('preview', Thrift.Type.LIST, 6);
      output.writeListBegin(Thrift.Type.I32, this.preview.length);
      for (let iter169 in this.preview) {
        if (this.preview.hasOwnProperty(iter169)) {
          iter169 = this.preview[iter169];
          output.writeI32(iter169);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.creatorId !== null && this.creatorId !== undefined) {
      output.writeFieldBegin('creatorId', Thrift.Type.STRING, 7);
      output.writeString(this.creatorId);
      output.writeFieldEnd();
    }
    if (this.creator !== null && this.creator !== undefined) {
      output.writeFieldBegin('creator', Thrift.Type.STRUCT, 8);
      this.creator.write(output);
      output.writeFieldEnd();
    }
    if (this.size !== null && this.size !== undefined) {
      output.writeFieldBegin('size', Thrift.Type.I64, 9);
      output.writeI64(this.size);
      output.writeFieldEnd();
    }
    if (this.status !== null && this.status !== undefined) {
      output.writeFieldBegin('status', Thrift.Type.I32, 10);
      output.writeI32(this.status);
      output.writeFieldEnd();
    }
    if (this.stageId !== null && this.stageId !== undefined) {
      output.writeFieldBegin('stageId', Thrift.Type.STRING, 11);
      output.writeString(this.stageId);
      output.writeFieldEnd();
    }
    if (this.hasDigitalSign !== null && this.hasDigitalSign !== undefined) {
      output.writeFieldBegin('hasDigitalSign', Thrift.Type.BOOL, 12);
      output.writeBool(this.hasDigitalSign);
      output.writeFieldEnd();
    }
    if (this.docExecId !== null && this.docExecId !== undefined) {
      output.writeFieldBegin('docExecId', Thrift.Type.STRING, 13);
      output.writeString(this.docExecId);
      output.writeFieldEnd();
    }
    if (this.autoReplacement !== null && this.autoReplacement !== undefined) {
      output.writeFieldBegin('autoReplacement', Thrift.Type.BOOL, 14);
      output.writeBool(this.autoReplacement);
      output.writeFieldEnd();
    }
    if (this.originalUserId !== null && this.originalUserId !== undefined) {
      output.writeFieldBegin('originalUserId', Thrift.Type.STRING, 15);
      output.writeString(this.originalUserId);
      output.writeFieldEnd();
    }
    if (this.originalUser !== null && this.originalUser !== undefined) {
      output.writeFieldBegin('originalUser', Thrift.Type.STRUCT, 16);
      this.originalUser.write(output);
      output.writeFieldEnd();
    }
    if (this.forDraft !== null && this.forDraft !== undefined) {
      output.writeFieldBegin('forDraft', Thrift.Type.BOOL, 17);
      output.writeBool(this.forDraft);
      output.writeFieldEnd();
    }
    if (this.waitForPublish !== null && this.waitForPublish !== undefined) {
      output.writeFieldBegin('waitForPublish', Thrift.Type.BOOL, 18);
      output.writeBool(this.waitForPublish);
      output.writeFieldEnd();
    }
    if (this.fVersion !== null && this.fVersion !== undefined) {
      output.writeFieldBegin('fVersion', Thrift.Type.I64, 19);
      output.writeI64(this.fVersion);
      output.writeFieldEnd();
    }
    if (this.iteration !== null && this.iteration !== undefined) {
      output.writeFieldBegin('iteration', Thrift.Type.I32, 20);
      output.writeI32(this.iteration);
      output.writeFieldEnd();
    }
    if (this.attachmentPermissions !== null && this.attachmentPermissions !== undefined) {
      output.writeFieldBegin('attachmentPermissions', Thrift.Type.STRUCT, 21);
      this.attachmentPermissions.write(output);
      output.writeFieldEnd();
    }
    if (this.versionCount !== null && this.versionCount !== undefined) {
      output.writeFieldBegin('versionCount', Thrift.Type.I32, 22);
      output.writeI32(this.versionCount);
      output.writeFieldEnd();
    }
    if (this.fType !== null && this.fType !== undefined) {
      output.writeFieldBegin('fType', Thrift.Type.I32, 23);
      output.writeI32(this.fType);
      output.writeFieldEnd();
    }
    if (this.accessMode !== null && this.accessMode !== undefined) {
      output.writeFieldBegin('accessMode', Thrift.Type.I32, 24);
      output.writeI32(this.accessMode);
      output.writeFieldEnd();
    }
    if (this.editMode !== null && this.editMode !== undefined) {
      output.writeFieldBegin('editMode', Thrift.Type.I32, 25);
      output.writeI32(this.editMode);
      output.writeFieldEnd();
    }
    if (this.externalId !== null && this.externalId !== undefined) {
      output.writeFieldBegin('externalId', Thrift.Type.STRING, 26);
      output.writeString(this.externalId);
      output.writeFieldEnd();
    }
    if (this.meetingId !== null && this.meetingId !== undefined) {
      output.writeFieldBegin('meetingId', Thrift.Type.STRING, 27);
      output.writeString(this.meetingId);
      output.writeFieldEnd();
    }
    if (this.attachmentExtStatus !== null && this.attachmentExtStatus !== undefined) {
      output.writeFieldBegin('attachmentExtStatus', Thrift.Type.I32, 28);
      output.writeI32(this.attachmentExtStatus);
      output.writeFieldEnd();
    }
    if (this.versionInfo !== null && this.versionInfo !== undefined) {
      output.writeFieldBegin('versionInfo', Thrift.Type.LIST, 29);
      output.writeListBegin(Thrift.Type.STRUCT, this.versionInfo.length);
      for (let iter170 in this.versionInfo) {
        if (this.versionInfo.hasOwnProperty(iter170)) {
          iter170 = this.versionInfo[iter170];
          iter170.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.patternAttachmentTemplateId !== null && this.patternAttachmentTemplateId !== undefined) {
      output.writeFieldBegin('patternAttachmentTemplateId', Thrift.Type.STRING, 30);
      output.writeString(this.patternAttachmentTemplateId);
      output.writeFieldEnd();
    }
    if (this.isHidden !== null && this.isHidden !== undefined) {
      output.writeFieldBegin('isHidden', Thrift.Type.BOOL, 31);
      output.writeBool(this.isHidden);
      output.writeFieldEnd();
    }
    if (this.signCertKeys !== null && this.signCertKeys !== undefined) {
      output.writeFieldBegin('signCertKeys', Thrift.Type.SET, 32);
      output.writeSetBegin(Thrift.Type.STRING, this.signCertKeys.length);
      for (let iter171 in this.signCertKeys) {
        if (this.signCertKeys.hasOwnProperty(iter171)) {
          iter171 = this.signCertKeys[iter171];
          output.writeString(iter171);
        }
      }
      output.writeSetEnd();
      output.writeFieldEnd();
    }
    if (this.autoAdd !== null && this.autoAdd !== undefined) {
      output.writeFieldBegin('autoAdd', Thrift.Type.BOOL, 33);
      output.writeBool(this.autoAdd);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentRelation = class {
  constructor(args) {
    this.id = null;
    this.createDate = null;
    this.docId1 = null;
    this.docId2 = null;
    this.createDoc2Date = null;
    this.doc2Name = null;
    this.doc2Number = null;
    this.doc2SystemNumber = null;
    this.doc2Access = null;
    this.relationType = null;
    this.doc2Status = null;
    this.doc2SubStatus = null;
    this.doc2DeadlineDate = null;
    this.doc2CardDeadlineDate = null;
    this.resolution = null;
    this.doc2ActionType = null;
    this.doc2HasConfirmationCard = null;
    this.doc2Icon = null;
    this.doc2PatternName = null;
    this.doc2PatternGroupName = null;
    this.doc2StageName = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.createDate !== undefined && args.createDate !== null) {
        this.createDate = args.createDate;
      }
      if (args.docId1 !== undefined && args.docId1 !== null) {
        this.docId1 = args.docId1;
      }
      if (args.docId2 !== undefined && args.docId2 !== null) {
        this.docId2 = args.docId2;
      }
      if (args.createDoc2Date !== undefined && args.createDoc2Date !== null) {
        this.createDoc2Date = args.createDoc2Date;
      }
      if (args.doc2Name !== undefined && args.doc2Name !== null) {
        this.doc2Name = args.doc2Name;
      }
      if (args.doc2Number !== undefined && args.doc2Number !== null) {
        this.doc2Number = args.doc2Number;
      }
      if (args.doc2SystemNumber !== undefined && args.doc2SystemNumber !== null) {
        this.doc2SystemNumber = args.doc2SystemNumber;
      }
      if (args.doc2Access !== undefined && args.doc2Access !== null) {
        this.doc2Access = args.doc2Access;
      }
      if (args.relationType !== undefined && args.relationType !== null) {
        this.relationType = args.relationType;
      }
      if (args.doc2Status !== undefined && args.doc2Status !== null) {
        this.doc2Status = args.doc2Status;
      }
      if (args.doc2SubStatus !== undefined && args.doc2SubStatus !== null) {
        this.doc2SubStatus = args.doc2SubStatus;
      }
      if (args.doc2DeadlineDate !== undefined && args.doc2DeadlineDate !== null) {
        this.doc2DeadlineDate = args.doc2DeadlineDate;
      }
      if (args.doc2CardDeadlineDate !== undefined && args.doc2CardDeadlineDate !== null) {
        this.doc2CardDeadlineDate = args.doc2CardDeadlineDate;
      }
      if (args.resolution !== undefined && args.resolution !== null) {
        this.resolution = args.resolution;
      }
      if (args.doc2ActionType !== undefined && args.doc2ActionType !== null) {
        this.doc2ActionType = Thrift.copyMap(args.doc2ActionType, [null]);
      }
      if (args.doc2HasConfirmationCard !== undefined && args.doc2HasConfirmationCard !== null) {
        this.doc2HasConfirmationCard = args.doc2HasConfirmationCard;
      }
      if (args.doc2Icon !== undefined && args.doc2Icon !== null) {
        this.doc2Icon = args.doc2Icon;
      }
      if (args.doc2PatternName !== undefined && args.doc2PatternName !== null) {
        this.doc2PatternName = args.doc2PatternName;
      }
      if (args.doc2PatternGroupName !== undefined && args.doc2PatternGroupName !== null) {
        this.doc2PatternGroupName = args.doc2PatternGroupName;
      }
      if (args.doc2StageName !== undefined && args.doc2StageName !== null) {
        this.doc2StageName = args.doc2StageName;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I64) {
          this.createDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.docId1 = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.docId2 = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.I64) {
          this.createDoc2Date = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.STRING) {
          this.doc2Name = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.STRING) {
          this.doc2Number = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.STRING) {
          this.doc2SystemNumber = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 9:
        if (ftype == Thrift.Type.BOOL) {
          this.doc2Access = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 10:
        if (ftype == Thrift.Type.I32) {
          this.relationType = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 11:
        if (ftype == Thrift.Type.I32) {
          this.doc2Status = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 12:
        if (ftype == Thrift.Type.I32) {
          this.doc2SubStatus = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 13:
        if (ftype == Thrift.Type.I64) {
          this.doc2DeadlineDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 14:
        if (ftype == Thrift.Type.I64) {
          this.doc2CardDeadlineDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 15:
        if (ftype == Thrift.Type.STRING) {
          this.resolution = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 16:
        if (ftype == Thrift.Type.MAP) {
          this.doc2ActionType = {};
          const _rtmp3173 = input.readMapBegin();
          const _size172 = _rtmp3173.size || 0;
          for (let _i174 = 0; _i174 < _size172; ++_i174) {
            if (_i174 > 0 ) {
              if (input.rstack.length > input.rpos[input.rpos.length -1] + 1) {
                input.rstack.pop();
              }
            }
            let key175 = null;
            let val176 = null;
            key175 = input.readString().value;
            val176 = input.readI32().value;
            this.doc2ActionType[key175] = val176;
          }
          input.readMapEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 17:
        if (ftype == Thrift.Type.BOOL) {
          this.doc2HasConfirmationCard = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 18:
        if (ftype == Thrift.Type.I32) {
          this.doc2Icon = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 19:
        if (ftype == Thrift.Type.STRING) {
          this.doc2PatternName = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 20:
        if (ftype == Thrift.Type.STRING) {
          this.doc2PatternGroupName = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 21:
        if (ftype == Thrift.Type.STRING) {
          this.doc2StageName = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentRelation');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.createDate !== null && this.createDate !== undefined) {
      output.writeFieldBegin('createDate', Thrift.Type.I64, 2);
      output.writeI64(this.createDate);
      output.writeFieldEnd();
    }
    if (this.docId1 !== null && this.docId1 !== undefined) {
      output.writeFieldBegin('docId1', Thrift.Type.STRING, 3);
      output.writeString(this.docId1);
      output.writeFieldEnd();
    }
    if (this.docId2 !== null && this.docId2 !== undefined) {
      output.writeFieldBegin('docId2', Thrift.Type.STRING, 4);
      output.writeString(this.docId2);
      output.writeFieldEnd();
    }
    if (this.createDoc2Date !== null && this.createDoc2Date !== undefined) {
      output.writeFieldBegin('createDoc2Date', Thrift.Type.I64, 5);
      output.writeI64(this.createDoc2Date);
      output.writeFieldEnd();
    }
    if (this.doc2Name !== null && this.doc2Name !== undefined) {
      output.writeFieldBegin('doc2Name', Thrift.Type.STRING, 6);
      output.writeString(this.doc2Name);
      output.writeFieldEnd();
    }
    if (this.doc2Number !== null && this.doc2Number !== undefined) {
      output.writeFieldBegin('doc2Number', Thrift.Type.STRING, 7);
      output.writeString(this.doc2Number);
      output.writeFieldEnd();
    }
    if (this.doc2SystemNumber !== null && this.doc2SystemNumber !== undefined) {
      output.writeFieldBegin('doc2SystemNumber', Thrift.Type.STRING, 8);
      output.writeString(this.doc2SystemNumber);
      output.writeFieldEnd();
    }
    if (this.doc2Access !== null && this.doc2Access !== undefined) {
      output.writeFieldBegin('doc2Access', Thrift.Type.BOOL, 9);
      output.writeBool(this.doc2Access);
      output.writeFieldEnd();
    }
    if (this.relationType !== null && this.relationType !== undefined) {
      output.writeFieldBegin('relationType', Thrift.Type.I32, 10);
      output.writeI32(this.relationType);
      output.writeFieldEnd();
    }
    if (this.doc2Status !== null && this.doc2Status !== undefined) {
      output.writeFieldBegin('doc2Status', Thrift.Type.I32, 11);
      output.writeI32(this.doc2Status);
      output.writeFieldEnd();
    }
    if (this.doc2SubStatus !== null && this.doc2SubStatus !== undefined) {
      output.writeFieldBegin('doc2SubStatus', Thrift.Type.I32, 12);
      output.writeI32(this.doc2SubStatus);
      output.writeFieldEnd();
    }
    if (this.doc2DeadlineDate !== null && this.doc2DeadlineDate !== undefined) {
      output.writeFieldBegin('doc2DeadlineDate', Thrift.Type.I64, 13);
      output.writeI64(this.doc2DeadlineDate);
      output.writeFieldEnd();
    }
    if (this.doc2CardDeadlineDate !== null && this.doc2CardDeadlineDate !== undefined) {
      output.writeFieldBegin('doc2CardDeadlineDate', Thrift.Type.I64, 14);
      output.writeI64(this.doc2CardDeadlineDate);
      output.writeFieldEnd();
    }
    if (this.resolution !== null && this.resolution !== undefined) {
      output.writeFieldBegin('resolution', Thrift.Type.STRING, 15);
      output.writeString(this.resolution);
      output.writeFieldEnd();
    }
    if (this.doc2ActionType !== null && this.doc2ActionType !== undefined) {
      output.writeFieldBegin('doc2ActionType', Thrift.Type.MAP, 16);
      output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.I32, Thrift.objectLength(this.doc2ActionType));
      for (let kiter177 in this.doc2ActionType) {
        if (this.doc2ActionType.hasOwnProperty(kiter177)) {
          let viter178 = this.doc2ActionType[kiter177];
          output.writeString(kiter177);
          output.writeI32(viter178);
        }
      }
      output.writeMapEnd();
      output.writeFieldEnd();
    }
    if (this.doc2HasConfirmationCard !== null && this.doc2HasConfirmationCard !== undefined) {
      output.writeFieldBegin('doc2HasConfirmationCard', Thrift.Type.BOOL, 17);
      output.writeBool(this.doc2HasConfirmationCard);
      output.writeFieldEnd();
    }
    if (this.doc2Icon !== null && this.doc2Icon !== undefined) {
      output.writeFieldBegin('doc2Icon', Thrift.Type.I32, 18);
      output.writeI32(this.doc2Icon);
      output.writeFieldEnd();
    }
    if (this.doc2PatternName !== null && this.doc2PatternName !== undefined) {
      output.writeFieldBegin('doc2PatternName', Thrift.Type.STRING, 19);
      output.writeString(this.doc2PatternName);
      output.writeFieldEnd();
    }
    if (this.doc2PatternGroupName !== null && this.doc2PatternGroupName !== undefined) {
      output.writeFieldBegin('doc2PatternGroupName', Thrift.Type.STRING, 20);
      output.writeString(this.doc2PatternGroupName);
      output.writeFieldEnd();
    }
    if (this.doc2StageName !== null && this.doc2StageName !== undefined) {
      output.writeFieldBegin('doc2StageName', Thrift.Type.STRING, 21);
      output.writeString(this.doc2StageName);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ExecutionTree = class {
  constructor(args) {
    this.card = null;
    this.attachments = null;
    this.comments = null;
    this.childTree = null;
    this.parentTree = null;
    this.docRelations = null;
    this.period = null;
    this.periodicEndDate = null;
    if (args) {
      if (args.card !== undefined && args.card !== null) {
        this.card = new DocumentExecution(args.card);
      }
      if (args.attachments !== undefined && args.attachments !== null) {
        this.attachments = Thrift.copyList(args.attachments, [Attachment]);
      }
      if (args.comments !== undefined && args.comments !== null) {
        this.comments = Thrift.copyList(args.comments, [DocumentComment]);
      }
      if (args.childTree !== undefined && args.childTree !== null) {
        this.childTree = Thrift.copyList(args.childTree, [null]);
      }
      if (args.parentTree !== undefined && args.parentTree !== null) {
        this.parentTree = new ExecutionTree(args.parentTree);
      }
      if (args.docRelations !== undefined && args.docRelations !== null) {
        this.docRelations = Thrift.copyList(args.docRelations, [DocumentRelation]);
      }
      if (args.period !== undefined && args.period !== null) {
        this.period = args.period;
      }
      if (args.periodicEndDate !== undefined && args.periodicEndDate !== null) {
        this.periodicEndDate = args.periodicEndDate;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.card = new DocumentExecution();
          this.card.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.LIST) {
          this.attachments = [];
          const _rtmp3180 = input.readListBegin();
          const _size179 = _rtmp3180.size || 0;
          for (let _i181 = 0; _i181 < _size179; ++_i181) {
            let elem182 = null;
            elem182 = new Attachment();
            elem182.read(input);
            this.attachments.push(elem182);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.comments = [];
          const _rtmp3184 = input.readListBegin();
          const _size183 = _rtmp3184.size || 0;
          for (let _i185 = 0; _i185 < _size183; ++_i185) {
            let elem186 = null;
            elem186 = new DocumentComment();
            elem186.read(input);
            this.comments.push(elem186);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.LIST) {
          this.childTree = [];
          const _rtmp3188 = input.readListBegin();
          const _size187 = _rtmp3188.size || 0;
          for (let _i189 = 0; _i189 < _size187; ++_i189) {
            let elem190 = null;
            elem190 = new ExecutionTree();
            elem190.read(input);
            this.childTree.push(elem190);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRUCT) {
          this.parentTree = new ExecutionTree();
          this.parentTree.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.LIST) {
          this.docRelations = [];
          const _rtmp3192 = input.readListBegin();
          const _size191 = _rtmp3192.size || 0;
          for (let _i193 = 0; _i193 < _size191; ++_i193) {
            let elem194 = null;
            elem194 = new DocumentRelation();
            elem194.read(input);
            this.docRelations.push(elem194);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.STRING) {
          this.period = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.I64) {
          this.periodicEndDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ExecutionTree');
    if (this.card !== null && this.card !== undefined) {
      output.writeFieldBegin('card', Thrift.Type.STRUCT, 1);
      this.card.write(output);
      output.writeFieldEnd();
    }
    if (this.attachments !== null && this.attachments !== undefined) {
      output.writeFieldBegin('attachments', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.STRUCT, this.attachments.length);
      for (let iter195 in this.attachments) {
        if (this.attachments.hasOwnProperty(iter195)) {
          iter195 = this.attachments[iter195];
          iter195.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.comments !== null && this.comments !== undefined) {
      output.writeFieldBegin('comments', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRUCT, this.comments.length);
      for (let iter196 in this.comments) {
        if (this.comments.hasOwnProperty(iter196)) {
          iter196 = this.comments[iter196];
          iter196.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.childTree !== null && this.childTree !== undefined) {
      output.writeFieldBegin('childTree', Thrift.Type.LIST, 4);
      output.writeListBegin(Thrift.Type.STRUCT, this.childTree.length);
      for (let iter197 in this.childTree) {
        if (this.childTree.hasOwnProperty(iter197)) {
          iter197 = this.childTree[iter197];
          iter197.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.parentTree !== null && this.parentTree !== undefined) {
      output.writeFieldBegin('parentTree', Thrift.Type.STRUCT, 5);
      this.parentTree.write(output);
      output.writeFieldEnd();
    }
    if (this.docRelations !== null && this.docRelations !== undefined) {
      output.writeFieldBegin('docRelations', Thrift.Type.LIST, 6);
      output.writeListBegin(Thrift.Type.STRUCT, this.docRelations.length);
      for (let iter198 in this.docRelations) {
        if (this.docRelations.hasOwnProperty(iter198)) {
          iter198 = this.docRelations[iter198];
          iter198.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.period !== null && this.period !== undefined) {
      output.writeFieldBegin('period', Thrift.Type.STRING, 7);
      output.writeString(this.period);
      output.writeFieldEnd();
    }
    if (this.periodicEndDate !== null && this.periodicEndDate !== undefined) {
      output.writeFieldBegin('periodicEndDate', Thrift.Type.I64, 8);
      output.writeI64(this.periodicEndDate);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
PassedStage = class {
  constructor(args) {
    this.passedStage = null;
    this.iteration = null;
    this.startDate = null;
    this.factDate = null;
    this.deadLineDate = null;
    if (args) {
      if (args.passedStage !== undefined && args.passedStage !== null) {
        this.passedStage = new DocumentPatternStage(args.passedStage);
      }
      if (args.iteration !== undefined && args.iteration !== null) {
        this.iteration = args.iteration;
      }
      if (args.startDate !== undefined && args.startDate !== null) {
        this.startDate = args.startDate;
      }
      if (args.factDate !== undefined && args.factDate !== null) {
        this.factDate = args.factDate;
      }
      if (args.deadLineDate !== undefined && args.deadLineDate !== null) {
        this.deadLineDate = args.deadLineDate;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.passedStage = new DocumentPatternStage();
          this.passedStage.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.iteration = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I64) {
          this.startDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I64) {
          this.factDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.I64) {
          this.deadLineDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('PassedStage');
    if (this.passedStage !== null && this.passedStage !== undefined) {
      output.writeFieldBegin('passedStage', Thrift.Type.STRUCT, 1);
      this.passedStage.write(output);
      output.writeFieldEnd();
    }
    if (this.iteration !== null && this.iteration !== undefined) {
      output.writeFieldBegin('iteration', Thrift.Type.I32, 2);
      output.writeI32(this.iteration);
      output.writeFieldEnd();
    }
    if (this.startDate !== null && this.startDate !== undefined) {
      output.writeFieldBegin('startDate', Thrift.Type.I64, 3);
      output.writeI64(this.startDate);
      output.writeFieldEnd();
    }
    if (this.factDate !== null && this.factDate !== undefined) {
      output.writeFieldBegin('factDate', Thrift.Type.I64, 4);
      output.writeI64(this.factDate);
      output.writeFieldEnd();
    }
    if (this.deadLineDate !== null && this.deadLineDate !== undefined) {
      output.writeFieldBegin('deadLineDate', Thrift.Type.I64, 5);
      output.writeI64(this.deadLineDate);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AttCreateInfo = class {
  constructor(args) {
    this.attachmentId = null;
    this.attachmentTemplateId = null;
    this.fileName = null;
    this.forDraft = null;
    this.editMode = null;
    this.meetingId = null;
    this.attachmentExtStatus = null;
    if (args) {
      if (args.attachmentId !== undefined && args.attachmentId !== null) {
        this.attachmentId = args.attachmentId;
      }
      if (args.attachmentTemplateId !== undefined && args.attachmentTemplateId !== null) {
        this.attachmentTemplateId = args.attachmentTemplateId;
      }
      if (args.fileName !== undefined && args.fileName !== null) {
        this.fileName = args.fileName;
      }
      if (args.forDraft !== undefined && args.forDraft !== null) {
        this.forDraft = args.forDraft;
      }
      if (args.editMode !== undefined && args.editMode !== null) {
        this.editMode = args.editMode;
      }
      if (args.meetingId !== undefined && args.meetingId !== null) {
        this.meetingId = args.meetingId;
      }
      if (args.attachmentExtStatus !== undefined && args.attachmentExtStatus !== null) {
        this.attachmentExtStatus = args.attachmentExtStatus;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.attachmentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.attachmentTemplateId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.fileName = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.BOOL) {
          this.forDraft = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.I32) {
          this.editMode = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.STRING) {
          this.meetingId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.I32) {
          this.attachmentExtStatus = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AttCreateInfo');
    if (this.attachmentId !== null && this.attachmentId !== undefined) {
      output.writeFieldBegin('attachmentId', Thrift.Type.STRING, 1);
      output.writeString(this.attachmentId);
      output.writeFieldEnd();
    }
    if (this.attachmentTemplateId !== null && this.attachmentTemplateId !== undefined) {
      output.writeFieldBegin('attachmentTemplateId', Thrift.Type.STRING, 2);
      output.writeString(this.attachmentTemplateId);
      output.writeFieldEnd();
    }
    if (this.fileName !== null && this.fileName !== undefined) {
      output.writeFieldBegin('fileName', Thrift.Type.STRING, 3);
      output.writeString(this.fileName);
      output.writeFieldEnd();
    }
    if (this.forDraft !== null && this.forDraft !== undefined) {
      output.writeFieldBegin('forDraft', Thrift.Type.BOOL, 4);
      output.writeBool(this.forDraft);
      output.writeFieldEnd();
    }
    if (this.editMode !== null && this.editMode !== undefined) {
      output.writeFieldBegin('editMode', Thrift.Type.I32, 5);
      output.writeI32(this.editMode);
      output.writeFieldEnd();
    }
    if (this.meetingId !== null && this.meetingId !== undefined) {
      output.writeFieldBegin('meetingId', Thrift.Type.STRING, 6);
      output.writeString(this.meetingId);
      output.writeFieldEnd();
    }
    if (this.attachmentExtStatus !== null && this.attachmentExtStatus !== undefined) {
      output.writeFieldBegin('attachmentExtStatus', Thrift.Type.I32, 7);
      output.writeI32(this.attachmentExtStatus);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentReassign = class {
  constructor(args) {
    this.id = null;
    this.dateStart = null;
    this.dateEnd = null;
    this.userOrGroup = null;
    this.deadLineTime = null;
    this.reassignType = null;
    this.comment = null;
    this.periodical = null;
    this.startPeriod = null;
    this.nextStartPeriod = null;
    this.periodicEndDate = null;
    this.cardActivityPeriod = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.dateStart !== undefined && args.dateStart !== null) {
        this.dateStart = args.dateStart;
      }
      if (args.dateEnd !== undefined && args.dateEnd !== null) {
        this.dateEnd = args.dateEnd;
      }
      if (args.userOrGroup !== undefined && args.userOrGroup !== null) {
        this.userOrGroup = new UserOrGroup(args.userOrGroup);
      }
      if (args.deadLineTime !== undefined && args.deadLineTime !== null) {
        this.deadLineTime = args.deadLineTime;
      }
      if (args.reassignType !== undefined && args.reassignType !== null) {
        this.reassignType = args.reassignType;
      }
      if (args.comment !== undefined && args.comment !== null) {
        this.comment = args.comment;
      }
      if (args.periodical !== undefined && args.periodical !== null) {
        this.periodical = args.periodical;
      }
      if (args.startPeriod !== undefined && args.startPeriod !== null) {
        this.startPeriod = args.startPeriod;
      }
      if (args.nextStartPeriod !== undefined && args.nextStartPeriod !== null) {
        this.nextStartPeriod = args.nextStartPeriod;
      }
      if (args.periodicEndDate !== undefined && args.periodicEndDate !== null) {
        this.periodicEndDate = args.periodicEndDate;
      }
      if (args.cardActivityPeriod !== undefined && args.cardActivityPeriod !== null) {
        this.cardActivityPeriod = args.cardActivityPeriod;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I64) {
          this.dateStart = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I64) {
          this.dateEnd = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.userOrGroup = new UserOrGroup();
          this.userOrGroup.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.I64) {
          this.deadLineTime = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.I32) {
          this.reassignType = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.STRING) {
          this.comment = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.BOOL) {
          this.periodical = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 9:
        if (ftype == Thrift.Type.I64) {
          this.startPeriod = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 10:
        if (ftype == Thrift.Type.STRING) {
          this.nextStartPeriod = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 11:
        if (ftype == Thrift.Type.I64) {
          this.periodicEndDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 12:
        if (ftype == Thrift.Type.STRING) {
          this.cardActivityPeriod = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentReassign');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.dateStart !== null && this.dateStart !== undefined) {
      output.writeFieldBegin('dateStart', Thrift.Type.I64, 2);
      output.writeI64(this.dateStart);
      output.writeFieldEnd();
    }
    if (this.dateEnd !== null && this.dateEnd !== undefined) {
      output.writeFieldBegin('dateEnd', Thrift.Type.I64, 3);
      output.writeI64(this.dateEnd);
      output.writeFieldEnd();
    }
    if (this.userOrGroup !== null && this.userOrGroup !== undefined) {
      output.writeFieldBegin('userOrGroup', Thrift.Type.STRUCT, 4);
      this.userOrGroup.write(output);
      output.writeFieldEnd();
    }
    if (this.deadLineTime !== null && this.deadLineTime !== undefined) {
      output.writeFieldBegin('deadLineTime', Thrift.Type.I64, 5);
      output.writeI64(this.deadLineTime);
      output.writeFieldEnd();
    }
    if (this.reassignType !== null && this.reassignType !== undefined) {
      output.writeFieldBegin('reassignType', Thrift.Type.I32, 6);
      output.writeI32(this.reassignType);
      output.writeFieldEnd();
    }
    if (this.comment !== null && this.comment !== undefined) {
      output.writeFieldBegin('comment', Thrift.Type.STRING, 7);
      output.writeString(this.comment);
      output.writeFieldEnd();
    }
    if (this.periodical !== null && this.periodical !== undefined) {
      output.writeFieldBegin('periodical', Thrift.Type.BOOL, 8);
      output.writeBool(this.periodical);
      output.writeFieldEnd();
    }
    if (this.startPeriod !== null && this.startPeriod !== undefined) {
      output.writeFieldBegin('startPeriod', Thrift.Type.I64, 9);
      output.writeI64(this.startPeriod);
      output.writeFieldEnd();
    }
    if (this.nextStartPeriod !== null && this.nextStartPeriod !== undefined) {
      output.writeFieldBegin('nextStartPeriod', Thrift.Type.STRING, 10);
      output.writeString(this.nextStartPeriod);
      output.writeFieldEnd();
    }
    if (this.periodicEndDate !== null && this.periodicEndDate !== undefined) {
      output.writeFieldBegin('periodicEndDate', Thrift.Type.I64, 11);
      output.writeI64(this.periodicEndDate);
      output.writeFieldEnd();
    }
    if (this.cardActivityPeriod !== null && this.cardActivityPeriod !== undefined) {
      output.writeFieldBegin('cardActivityPeriod', Thrift.Type.STRING, 12);
      output.writeString(this.cardActivityPeriod);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ContentHolderShowPlace = class {
  constructor(args) {
    this.id = null;
    this.stageId = null;
    this.seqNum = null;
    this.accessRule = null;
    this.contentHolder = null;
    this.allowEdit = null;
    this.linkId = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.stageId !== undefined && args.stageId !== null) {
        this.stageId = args.stageId;
      }
      if (args.seqNum !== undefined && args.seqNum !== null) {
        this.seqNum = args.seqNum;
      }
      if (args.accessRule !== undefined && args.accessRule !== null) {
        this.accessRule = new AccessRule(args.accessRule);
      }
      if (args.contentHolder !== undefined && args.contentHolder !== null) {
        this.contentHolder = new ContentHolder(args.contentHolder);
      }
      if (args.allowEdit !== undefined && args.allowEdit !== null) {
        this.allowEdit = args.allowEdit;
      }
      if (args.linkId !== undefined && args.linkId !== null) {
        this.linkId = args.linkId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.stageId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I32) {
          this.seqNum = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessRule = new AccessRule();
          this.accessRule.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRUCT) {
          this.contentHolder = new ContentHolder();
          this.contentHolder.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.BOOL) {
          this.allowEdit = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.STRING) {
          this.linkId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ContentHolderShowPlace');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.stageId !== null && this.stageId !== undefined) {
      output.writeFieldBegin('stageId', Thrift.Type.STRING, 2);
      output.writeString(this.stageId);
      output.writeFieldEnd();
    }
    if (this.seqNum !== null && this.seqNum !== undefined) {
      output.writeFieldBegin('seqNum', Thrift.Type.I32, 3);
      output.writeI32(this.seqNum);
      output.writeFieldEnd();
    }
    if (this.accessRule !== null && this.accessRule !== undefined) {
      output.writeFieldBegin('accessRule', Thrift.Type.STRUCT, 4);
      this.accessRule.write(output);
      output.writeFieldEnd();
    }
    if (this.contentHolder !== null && this.contentHolder !== undefined) {
      output.writeFieldBegin('contentHolder', Thrift.Type.STRUCT, 5);
      this.contentHolder.write(output);
      output.writeFieldEnd();
    }
    if (this.allowEdit !== null && this.allowEdit !== undefined) {
      output.writeFieldBegin('allowEdit', Thrift.Type.BOOL, 6);
      output.writeBool(this.allowEdit);
      output.writeFieldEnd();
    }
    if (this.linkId !== null && this.linkId !== undefined) {
      output.writeFieldBegin('linkId', Thrift.Type.STRING, 7);
      output.writeString(this.linkId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ContentHolder = class {
  constructor(args) {
    this.id = null;
    this.patternId = null;
    this.oName = null;
    this.isSystem = null;
    this.contentHolderLink = null;
    this.visibleOnShort = null;
    this.visibleOnFull = null;
    this.showInInfo = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.patternId !== undefined && args.patternId !== null) {
        this.patternId = args.patternId;
      }
      if (args.oName !== undefined && args.oName !== null) {
        this.oName = args.oName;
      }
      if (args.isSystem !== undefined && args.isSystem !== null) {
        this.isSystem = args.isSystem;
      }
      if (args.contentHolderLink !== undefined && args.contentHolderLink !== null) {
        this.contentHolderLink = Thrift.copyList(args.contentHolderLink, [null]);
      }
      if (args.visibleOnShort !== undefined && args.visibleOnShort !== null) {
        this.visibleOnShort = args.visibleOnShort;
      }
      if (args.visibleOnFull !== undefined && args.visibleOnFull !== null) {
        this.visibleOnFull = args.visibleOnFull;
      }
      if (args.showInInfo !== undefined && args.showInInfo !== null) {
        this.showInInfo = args.showInInfo;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.patternId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.oName = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.BOOL) {
          this.isSystem = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.LIST) {
          this.contentHolderLink = [];
          const _rtmp3200 = input.readListBegin();
          const _size199 = _rtmp3200.size || 0;
          for (let _i201 = 0; _i201 < _size199; ++_i201) {
            let elem202 = null;
            elem202 = new ContentHolderLink();
            elem202.read(input);
            this.contentHolderLink.push(elem202);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.BOOL) {
          this.visibleOnShort = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.BOOL) {
          this.visibleOnFull = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.BOOL) {
          this.showInInfo = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ContentHolder');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.patternId !== null && this.patternId !== undefined) {
      output.writeFieldBegin('patternId', Thrift.Type.STRING, 2);
      output.writeString(this.patternId);
      output.writeFieldEnd();
    }
    if (this.oName !== null && this.oName !== undefined) {
      output.writeFieldBegin('oName', Thrift.Type.STRING, 3);
      output.writeString(this.oName);
      output.writeFieldEnd();
    }
    if (this.isSystem !== null && this.isSystem !== undefined) {
      output.writeFieldBegin('isSystem', Thrift.Type.BOOL, 4);
      output.writeBool(this.isSystem);
      output.writeFieldEnd();
    }
    if (this.contentHolderLink !== null && this.contentHolderLink !== undefined) {
      output.writeFieldBegin('contentHolderLink', Thrift.Type.LIST, 5);
      output.writeListBegin(Thrift.Type.STRUCT, this.contentHolderLink.length);
      for (let iter203 in this.contentHolderLink) {
        if (this.contentHolderLink.hasOwnProperty(iter203)) {
          iter203 = this.contentHolderLink[iter203];
          iter203.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.visibleOnShort !== null && this.visibleOnShort !== undefined) {
      output.writeFieldBegin('visibleOnShort', Thrift.Type.BOOL, 6);
      output.writeBool(this.visibleOnShort);
      output.writeFieldEnd();
    }
    if (this.visibleOnFull !== null && this.visibleOnFull !== undefined) {
      output.writeFieldBegin('visibleOnFull', Thrift.Type.BOOL, 7);
      output.writeBool(this.visibleOnFull);
      output.writeFieldEnd();
    }
    if (this.showInInfo !== null && this.showInInfo !== undefined) {
      output.writeFieldBegin('showInInfo', Thrift.Type.BOOL, 8);
      output.writeBool(this.showInInfo);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ContentHolderLink = class {
  constructor(args) {
    this.id = null;
    this.contentItem = null;
    this.requared = null;
    this.readOnly = null;
    this.order = null;
    this.showPlace = null;
    this.visible = null;
    this.visibleScript = null;
    this.readonlyScript = null;
    this.onChangeScript = null;
    this.allowForCurUser = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.contentItem !== undefined && args.contentItem !== null) {
        this.contentItem = new ContentItem(args.contentItem);
      }
      if (args.requared !== undefined && args.requared !== null) {
        this.requared = args.requared;
      }
      if (args.readOnly !== undefined && args.readOnly !== null) {
        this.readOnly = args.readOnly;
      }
      if (args.order !== undefined && args.order !== null) {
        this.order = args.order;
      }
      if (args.showPlace !== undefined && args.showPlace !== null) {
        this.showPlace = args.showPlace;
      }
      if (args.visible !== undefined && args.visible !== null) {
        this.visible = args.visible;
      }
      if (args.visibleScript !== undefined && args.visibleScript !== null) {
        this.visibleScript = args.visibleScript;
      }
      if (args.readonlyScript !== undefined && args.readonlyScript !== null) {
        this.readonlyScript = args.readonlyScript;
      }
      if (args.onChangeScript !== undefined && args.onChangeScript !== null) {
        this.onChangeScript = args.onChangeScript;
      }
      if (args.allowForCurUser !== undefined && args.allowForCurUser !== null) {
        this.allowForCurUser = args.allowForCurUser;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.contentItem = new ContentItem();
          this.contentItem.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.BOOL) {
          this.requared = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.BOOL) {
          this.readOnly = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.I32) {
          this.order = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.I32) {
          this.showPlace = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.BOOL) {
          this.visible = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.STRING) {
          this.visibleScript = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 9:
        if (ftype == Thrift.Type.STRING) {
          this.readonlyScript = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 10:
        if (ftype == Thrift.Type.STRING) {
          this.onChangeScript = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 11:
        if (ftype == Thrift.Type.BOOL) {
          this.allowForCurUser = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ContentHolderLink');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.contentItem !== null && this.contentItem !== undefined) {
      output.writeFieldBegin('contentItem', Thrift.Type.STRUCT, 2);
      this.contentItem.write(output);
      output.writeFieldEnd();
    }
    if (this.requared !== null && this.requared !== undefined) {
      output.writeFieldBegin('requared', Thrift.Type.BOOL, 3);
      output.writeBool(this.requared);
      output.writeFieldEnd();
    }
    if (this.readOnly !== null && this.readOnly !== undefined) {
      output.writeFieldBegin('readOnly', Thrift.Type.BOOL, 4);
      output.writeBool(this.readOnly);
      output.writeFieldEnd();
    }
    if (this.order !== null && this.order !== undefined) {
      output.writeFieldBegin('order', Thrift.Type.I32, 5);
      output.writeI32(this.order);
      output.writeFieldEnd();
    }
    if (this.showPlace !== null && this.showPlace !== undefined) {
      output.writeFieldBegin('showPlace', Thrift.Type.I32, 6);
      output.writeI32(this.showPlace);
      output.writeFieldEnd();
    }
    if (this.visible !== null && this.visible !== undefined) {
      output.writeFieldBegin('visible', Thrift.Type.BOOL, 7);
      output.writeBool(this.visible);
      output.writeFieldEnd();
    }
    if (this.visibleScript !== null && this.visibleScript !== undefined) {
      output.writeFieldBegin('visibleScript', Thrift.Type.STRING, 8);
      output.writeString(this.visibleScript);
      output.writeFieldEnd();
    }
    if (this.readonlyScript !== null && this.readonlyScript !== undefined) {
      output.writeFieldBegin('readonlyScript', Thrift.Type.STRING, 9);
      output.writeString(this.readonlyScript);
      output.writeFieldEnd();
    }
    if (this.onChangeScript !== null && this.onChangeScript !== undefined) {
      output.writeFieldBegin('onChangeScript', Thrift.Type.STRING, 10);
      output.writeString(this.onChangeScript);
      output.writeFieldEnd();
    }
    if (this.allowForCurUser !== null && this.allowForCurUser !== undefined) {
      output.writeFieldBegin('allowForCurUser', Thrift.Type.BOOL, 11);
      output.writeBool(this.allowForCurUser);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ContentTab = class {
  constructor(args) {
    this.id = null;
    this.oName = null;
    this.seqNum = null;
    this.contentItems = null;
    this.enableEdit = null;
    this.visibleOnShort = null;
    this.visibleOnFull = null;
    this.allowForCurUser = null;
    this.visible = null;
    this.editOnCreate = null;
    this.visibleOnCreate = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.oName !== undefined && args.oName !== null) {
        this.oName = args.oName;
      }
      if (args.seqNum !== undefined && args.seqNum !== null) {
        this.seqNum = args.seqNum;
      }
      if (args.contentItems !== undefined && args.contentItems !== null) {
        this.contentItems = Thrift.copyList(args.contentItems, [ContentItem]);
      }
      if (args.enableEdit !== undefined && args.enableEdit !== null) {
        this.enableEdit = Thrift.copyMap(args.enableEdit, [AccessRule]);
      }
      if (args.visibleOnShort !== undefined && args.visibleOnShort !== null) {
        this.visibleOnShort = args.visibleOnShort;
      }
      if (args.visibleOnFull !== undefined && args.visibleOnFull !== null) {
        this.visibleOnFull = args.visibleOnFull;
      }
      if (args.allowForCurUser !== undefined && args.allowForCurUser !== null) {
        this.allowForCurUser = args.allowForCurUser;
      }
      if (args.visible !== undefined && args.visible !== null) {
        this.visible = Thrift.copyMap(args.visible, [null]);
      }
      if (args.editOnCreate !== undefined && args.editOnCreate !== null) {
        this.editOnCreate = args.editOnCreate;
      }
      if (args.visibleOnCreate !== undefined && args.visibleOnCreate !== null) {
        this.visibleOnCreate = args.visibleOnCreate;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.oName = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I32) {
          this.seqNum = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.LIST) {
          this.contentItems = [];
          const _rtmp3205 = input.readListBegin();
          const _size204 = _rtmp3205.size || 0;
          for (let _i206 = 0; _i206 < _size204; ++_i206) {
            let elem207 = null;
            elem207 = new ContentItem();
            elem207.read(input);
            this.contentItems.push(elem207);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.MAP) {
          this.enableEdit = {};
          const _rtmp3209 = input.readMapBegin();
          const _size208 = _rtmp3209.size || 0;
          for (let _i210 = 0; _i210 < _size208; ++_i210) {
            if (_i210 > 0 ) {
              if (input.rstack.length > input.rpos[input.rpos.length -1] + 1) {
                input.rstack.pop();
              }
            }
            let key211 = null;
            let val212 = null;
            key211 = input.readString().value;
            val212 = new AccessRule();
            val212.read(input);
            this.enableEdit[key211] = val212;
          }
          input.readMapEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.BOOL) {
          this.visibleOnShort = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.BOOL) {
          this.visibleOnFull = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.BOOL) {
          this.allowForCurUser = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 9:
        if (ftype == Thrift.Type.MAP) {
          this.visible = {};
          const _rtmp3214 = input.readMapBegin();
          const _size213 = _rtmp3214.size || 0;
          for (let _i215 = 0; _i215 < _size213; ++_i215) {
            if (_i215 > 0 ) {
              if (input.rstack.length > input.rpos[input.rpos.length -1] + 1) {
                input.rstack.pop();
              }
            }
            let key216 = null;
            let val217 = null;
            key216 = input.readString().value;
            val217 = input.readBool().value;
            this.visible[key216] = val217;
          }
          input.readMapEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 10:
        if (ftype == Thrift.Type.BOOL) {
          this.editOnCreate = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 11:
        if (ftype == Thrift.Type.BOOL) {
          this.visibleOnCreate = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ContentTab');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.oName !== null && this.oName !== undefined) {
      output.writeFieldBegin('oName', Thrift.Type.STRING, 2);
      output.writeString(this.oName);
      output.writeFieldEnd();
    }
    if (this.seqNum !== null && this.seqNum !== undefined) {
      output.writeFieldBegin('seqNum', Thrift.Type.I32, 3);
      output.writeI32(this.seqNum);
      output.writeFieldEnd();
    }
    if (this.contentItems !== null && this.contentItems !== undefined) {
      output.writeFieldBegin('contentItems', Thrift.Type.LIST, 4);
      output.writeListBegin(Thrift.Type.STRUCT, this.contentItems.length);
      for (let iter218 in this.contentItems) {
        if (this.contentItems.hasOwnProperty(iter218)) {
          iter218 = this.contentItems[iter218];
          iter218.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.enableEdit !== null && this.enableEdit !== undefined) {
      output.writeFieldBegin('enableEdit', Thrift.Type.MAP, 5);
      output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.STRUCT, Thrift.objectLength(this.enableEdit));
      for (let kiter219 in this.enableEdit) {
        if (this.enableEdit.hasOwnProperty(kiter219)) {
          let viter220 = this.enableEdit[kiter219];
          output.writeString(kiter219);
          viter220.write(output);
        }
      }
      output.writeMapEnd();
      output.writeFieldEnd();
    }
    if (this.visibleOnShort !== null && this.visibleOnShort !== undefined) {
      output.writeFieldBegin('visibleOnShort', Thrift.Type.BOOL, 6);
      output.writeBool(this.visibleOnShort);
      output.writeFieldEnd();
    }
    if (this.visibleOnFull !== null && this.visibleOnFull !== undefined) {
      output.writeFieldBegin('visibleOnFull', Thrift.Type.BOOL, 7);
      output.writeBool(this.visibleOnFull);
      output.writeFieldEnd();
    }
    if (this.allowForCurUser !== null && this.allowForCurUser !== undefined) {
      output.writeFieldBegin('allowForCurUser', Thrift.Type.BOOL, 8);
      output.writeBool(this.allowForCurUser);
      output.writeFieldEnd();
    }
    if (this.visible !== null && this.visible !== undefined) {
      output.writeFieldBegin('visible', Thrift.Type.MAP, 9);
      output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.BOOL, Thrift.objectLength(this.visible));
      for (let kiter221 in this.visible) {
        if (this.visible.hasOwnProperty(kiter221)) {
          let viter222 = this.visible[kiter221];
          output.writeString(kiter221);
          output.writeBool(viter222);
        }
      }
      output.writeMapEnd();
      output.writeFieldEnd();
    }
    if (this.editOnCreate !== null && this.editOnCreate !== undefined) {
      output.writeFieldBegin('editOnCreate', Thrift.Type.BOOL, 10);
      output.writeBool(this.editOnCreate);
      output.writeFieldEnd();
    }
    if (this.visibleOnCreate !== null && this.visibleOnCreate !== undefined) {
      output.writeFieldBegin('visibleOnCreate', Thrift.Type.BOOL, 11);
      output.writeBool(this.visibleOnCreate);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
HistoryData = class {
  constructor(args) {
    this.id = null;
    this.createDate = null;
    this.documentId = null;
    this.level = null;
    this.key = null;
    this.parameters = null;
    this.client = null;
    this.originalUser = null;
    this.docNumber = null;
    this.docSysNumber = null;
    this.attachmentId = null;
    this.attachmentFileName = null;
    this.ip1 = null;
    this.ip2 = null;
    this.patternId = null;
    this.hasDetailData = null;
    this.nomenclatureNumberId = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.createDate !== undefined && args.createDate !== null) {
        this.createDate = args.createDate;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.level !== undefined && args.level !== null) {
        this.level = args.level;
      }
      if (args.key !== undefined && args.key !== null) {
        this.key = args.key;
      }
      if (args.parameters !== undefined && args.parameters !== null) {
        this.parameters = Thrift.copyList(args.parameters, [null]);
      }
      if (args.client !== undefined && args.client !== null) {
        this.client = new UserOrGroup(args.client);
      }
      if (args.originalUser !== undefined && args.originalUser !== null) {
        this.originalUser = new UserOrGroup(args.originalUser);
      }
      if (args.docNumber !== undefined && args.docNumber !== null) {
        this.docNumber = args.docNumber;
      }
      if (args.docSysNumber !== undefined && args.docSysNumber !== null) {
        this.docSysNumber = args.docSysNumber;
      }
      if (args.attachmentId !== undefined && args.attachmentId !== null) {
        this.attachmentId = args.attachmentId;
      }
      if (args.attachmentFileName !== undefined && args.attachmentFileName !== null) {
        this.attachmentFileName = args.attachmentFileName;
      }
      if (args.ip1 !== undefined && args.ip1 !== null) {
        this.ip1 = args.ip1;
      }
      if (args.ip2 !== undefined && args.ip2 !== null) {
        this.ip2 = args.ip2;
      }
      if (args.patternId !== undefined && args.patternId !== null) {
        this.patternId = args.patternId;
      }
      if (args.hasDetailData !== undefined && args.hasDetailData !== null) {
        this.hasDetailData = args.hasDetailData;
      }
      if (args.nomenclatureNumberId !== undefined && args.nomenclatureNumberId !== null) {
        this.nomenclatureNumberId = args.nomenclatureNumberId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I64) {
          this.createDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I32) {
          this.level = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRING) {
          this.key = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.LIST) {
          this.parameters = [];
          const _rtmp3224 = input.readListBegin();
          const _size223 = _rtmp3224.size || 0;
          for (let _i225 = 0; _i225 < _size223; ++_i225) {
            let elem226 = null;
            elem226 = input.readString().value;
            this.parameters.push(elem226);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.STRUCT) {
          this.client = new UserOrGroup();
          this.client.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.STRUCT) {
          this.originalUser = new UserOrGroup();
          this.originalUser.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 9:
        if (ftype == Thrift.Type.STRING) {
          this.docNumber = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 10:
        if (ftype == Thrift.Type.STRING) {
          this.docSysNumber = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 11:
        if (ftype == Thrift.Type.STRING) {
          this.attachmentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 12:
        if (ftype == Thrift.Type.STRING) {
          this.attachmentFileName = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 13:
        if (ftype == Thrift.Type.STRING) {
          this.ip1 = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 14:
        if (ftype == Thrift.Type.STRING) {
          this.ip2 = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 15:
        if (ftype == Thrift.Type.STRING) {
          this.patternId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 16:
        if (ftype == Thrift.Type.BOOL) {
          this.hasDetailData = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 17:
        if (ftype == Thrift.Type.STRING) {
          this.nomenclatureNumberId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('HistoryData');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.createDate !== null && this.createDate !== undefined) {
      output.writeFieldBegin('createDate', Thrift.Type.I64, 2);
      output.writeI64(this.createDate);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 3);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.level !== null && this.level !== undefined) {
      output.writeFieldBegin('level', Thrift.Type.I32, 4);
      output.writeI32(this.level);
      output.writeFieldEnd();
    }
    if (this.key !== null && this.key !== undefined) {
      output.writeFieldBegin('key', Thrift.Type.STRING, 5);
      output.writeString(this.key);
      output.writeFieldEnd();
    }
    if (this.parameters !== null && this.parameters !== undefined) {
      output.writeFieldBegin('parameters', Thrift.Type.LIST, 6);
      output.writeListBegin(Thrift.Type.STRING, this.parameters.length);
      for (let iter227 in this.parameters) {
        if (this.parameters.hasOwnProperty(iter227)) {
          iter227 = this.parameters[iter227];
          output.writeString(iter227);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.client !== null && this.client !== undefined) {
      output.writeFieldBegin('client', Thrift.Type.STRUCT, 7);
      this.client.write(output);
      output.writeFieldEnd();
    }
    if (this.originalUser !== null && this.originalUser !== undefined) {
      output.writeFieldBegin('originalUser', Thrift.Type.STRUCT, 8);
      this.originalUser.write(output);
      output.writeFieldEnd();
    }
    if (this.docNumber !== null && this.docNumber !== undefined) {
      output.writeFieldBegin('docNumber', Thrift.Type.STRING, 9);
      output.writeString(this.docNumber);
      output.writeFieldEnd();
    }
    if (this.docSysNumber !== null && this.docSysNumber !== undefined) {
      output.writeFieldBegin('docSysNumber', Thrift.Type.STRING, 10);
      output.writeString(this.docSysNumber);
      output.writeFieldEnd();
    }
    if (this.attachmentId !== null && this.attachmentId !== undefined) {
      output.writeFieldBegin('attachmentId', Thrift.Type.STRING, 11);
      output.writeString(this.attachmentId);
      output.writeFieldEnd();
    }
    if (this.attachmentFileName !== null && this.attachmentFileName !== undefined) {
      output.writeFieldBegin('attachmentFileName', Thrift.Type.STRING, 12);
      output.writeString(this.attachmentFileName);
      output.writeFieldEnd();
    }
    if (this.ip1 !== null && this.ip1 !== undefined) {
      output.writeFieldBegin('ip1', Thrift.Type.STRING, 13);
      output.writeString(this.ip1);
      output.writeFieldEnd();
    }
    if (this.ip2 !== null && this.ip2 !== undefined) {
      output.writeFieldBegin('ip2', Thrift.Type.STRING, 14);
      output.writeString(this.ip2);
      output.writeFieldEnd();
    }
    if (this.patternId !== null && this.patternId !== undefined) {
      output.writeFieldBegin('patternId', Thrift.Type.STRING, 15);
      output.writeString(this.patternId);
      output.writeFieldEnd();
    }
    if (this.hasDetailData !== null && this.hasDetailData !== undefined) {
      output.writeFieldBegin('hasDetailData', Thrift.Type.BOOL, 16);
      output.writeBool(this.hasDetailData);
      output.writeFieldEnd();
    }
    if (this.nomenclatureNumberId !== null && this.nomenclatureNumberId !== undefined) {
      output.writeFieldBegin('nomenclatureNumberId', Thrift.Type.STRING, 17);
      output.writeString(this.nomenclatureNumberId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
HistoryPage = class {
  constructor(args) {
    this.historyList = null;
    this.totalCount = null;
    if (args) {
      if (args.historyList !== undefined && args.historyList !== null) {
        this.historyList = Thrift.copyList(args.historyList, [HistoryData]);
      }
      if (args.totalCount !== undefined && args.totalCount !== null) {
        this.totalCount = args.totalCount;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.LIST) {
          this.historyList = [];
          const _rtmp3229 = input.readListBegin();
          const _size228 = _rtmp3229.size || 0;
          for (let _i230 = 0; _i230 < _size228; ++_i230) {
            let elem231 = null;
            elem231 = new HistoryData();
            elem231.read(input);
            this.historyList.push(elem231);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I64) {
          this.totalCount = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('HistoryPage');
    if (this.historyList !== null && this.historyList !== undefined) {
      output.writeFieldBegin('historyList', Thrift.Type.LIST, 1);
      output.writeListBegin(Thrift.Type.STRUCT, this.historyList.length);
      for (let iter232 in this.historyList) {
        if (this.historyList.hasOwnProperty(iter232)) {
          iter232 = this.historyList[iter232];
          iter232.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.totalCount !== null && this.totalCount !== undefined) {
      output.writeFieldBegin('totalCount', Thrift.Type.I64, 2);
      output.writeI64(this.totalCount);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DeadlineHistory = class {
  constructor(args) {
    this.id = null;
    this.createDate = null;
    this.creator = null;
    this.document = null;
    this.documentExecution = null;
    this.oldDeadlineDate = null;
    this.theNewDeadlineDate = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.createDate !== undefined && args.createDate !== null) {
        this.createDate = args.createDate;
      }
      if (args.creator !== undefined && args.creator !== null) {
        this.creator = new UserOrGroup(args.creator);
      }
      if (args.document !== undefined && args.document !== null) {
        this.document = new Document(args.document);
      }
      if (args.documentExecution !== undefined && args.documentExecution !== null) {
        this.documentExecution = new DocumentExecution(args.documentExecution);
      }
      if (args.oldDeadlineDate !== undefined && args.oldDeadlineDate !== null) {
        this.oldDeadlineDate = args.oldDeadlineDate;
      }
      if (args.theNewDeadlineDate !== undefined && args.theNewDeadlineDate !== null) {
        this.theNewDeadlineDate = args.theNewDeadlineDate;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I64) {
          this.createDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.creator = new UserOrGroup();
          this.creator.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.document = new Document();
          this.document.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRUCT) {
          this.documentExecution = new DocumentExecution();
          this.documentExecution.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.I64) {
          this.oldDeadlineDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.I64) {
          this.theNewDeadlineDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DeadlineHistory');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.createDate !== null && this.createDate !== undefined) {
      output.writeFieldBegin('createDate', Thrift.Type.I64, 2);
      output.writeI64(this.createDate);
      output.writeFieldEnd();
    }
    if (this.creator !== null && this.creator !== undefined) {
      output.writeFieldBegin('creator', Thrift.Type.STRUCT, 3);
      this.creator.write(output);
      output.writeFieldEnd();
    }
    if (this.document !== null && this.document !== undefined) {
      output.writeFieldBegin('document', Thrift.Type.STRUCT, 4);
      this.document.write(output);
      output.writeFieldEnd();
    }
    if (this.documentExecution !== null && this.documentExecution !== undefined) {
      output.writeFieldBegin('documentExecution', Thrift.Type.STRUCT, 5);
      this.documentExecution.write(output);
      output.writeFieldEnd();
    }
    if (this.oldDeadlineDate !== null && this.oldDeadlineDate !== undefined) {
      output.writeFieldBegin('oldDeadlineDate', Thrift.Type.I64, 6);
      output.writeI64(this.oldDeadlineDate);
      output.writeFieldEnd();
    }
    if (this.theNewDeadlineDate !== null && this.theNewDeadlineDate !== undefined) {
      output.writeFieldBegin('theNewDeadlineDate', Thrift.Type.I64, 7);
      output.writeI64(this.theNewDeadlineDate);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentExtShare = class {
  constructor(args) {
    this.id = null;
    this.documentId = null;
    this.shareType = null;
    this.userId = null;
    this.guestId = null;
    this.secretCode = null;
    this.ruleSet = null;
    this.validTillDate = null;
    this.creatorId = null;
    this.createDate = null;
    this.extId = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.shareType !== undefined && args.shareType !== null) {
        this.shareType = args.shareType;
      }
      if (args.userId !== undefined && args.userId !== null) {
        this.userId = args.userId;
      }
      if (args.guestId !== undefined && args.guestId !== null) {
        this.guestId = args.guestId;
      }
      if (args.secretCode !== undefined && args.secretCode !== null) {
        this.secretCode = args.secretCode;
      }
      if (args.ruleSet !== undefined && args.ruleSet !== null) {
        this.ruleSet = Thrift.copyList(args.ruleSet, [null]);
      }
      if (args.validTillDate !== undefined && args.validTillDate !== null) {
        this.validTillDate = args.validTillDate;
      }
      if (args.creatorId !== undefined && args.creatorId !== null) {
        this.creatorId = args.creatorId;
      }
      if (args.createDate !== undefined && args.createDate !== null) {
        this.createDate = args.createDate;
      }
      if (args.extId !== undefined && args.extId !== null) {
        this.extId = args.extId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.shareType = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.userId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRING) {
          this.guestId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.STRING) {
          this.secretCode = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.SET) {
          this.ruleSet = [];
          const _rtmp3234 = input.readSetBegin();
          const _size233 = _rtmp3234.size || 0;
          for (let _i235 = 0; _i235 < _size233; ++_i235) {
            let elem236 = null;
            elem236 = input.readI32().value;
            this.ruleSet.push(elem236);
          }
          input.readSetEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.I64) {
          this.validTillDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 9:
        if (ftype == Thrift.Type.STRING) {
          this.creatorId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 10:
        if (ftype == Thrift.Type.I64) {
          this.createDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 11:
        if (ftype == Thrift.Type.STRING) {
          this.extId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentExtShare');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.shareType !== null && this.shareType !== undefined) {
      output.writeFieldBegin('shareType', Thrift.Type.STRING, 3);
      output.writeString(this.shareType);
      output.writeFieldEnd();
    }
    if (this.userId !== null && this.userId !== undefined) {
      output.writeFieldBegin('userId', Thrift.Type.STRING, 4);
      output.writeString(this.userId);
      output.writeFieldEnd();
    }
    if (this.guestId !== null && this.guestId !== undefined) {
      output.writeFieldBegin('guestId', Thrift.Type.STRING, 5);
      output.writeString(this.guestId);
      output.writeFieldEnd();
    }
    if (this.secretCode !== null && this.secretCode !== undefined) {
      output.writeFieldBegin('secretCode', Thrift.Type.STRING, 6);
      output.writeString(this.secretCode);
      output.writeFieldEnd();
    }
    if (this.ruleSet !== null && this.ruleSet !== undefined) {
      output.writeFieldBegin('ruleSet', Thrift.Type.SET, 7);
      output.writeSetBegin(Thrift.Type.I32, this.ruleSet.length);
      for (let iter237 in this.ruleSet) {
        if (this.ruleSet.hasOwnProperty(iter237)) {
          iter237 = this.ruleSet[iter237];
          output.writeI32(iter237);
        }
      }
      output.writeSetEnd();
      output.writeFieldEnd();
    }
    if (this.validTillDate !== null && this.validTillDate !== undefined) {
      output.writeFieldBegin('validTillDate', Thrift.Type.I64, 8);
      output.writeI64(this.validTillDate);
      output.writeFieldEnd();
    }
    if (this.creatorId !== null && this.creatorId !== undefined) {
      output.writeFieldBegin('creatorId', Thrift.Type.STRING, 9);
      output.writeString(this.creatorId);
      output.writeFieldEnd();
    }
    if (this.createDate !== null && this.createDate !== undefined) {
      output.writeFieldBegin('createDate', Thrift.Type.I64, 10);
      output.writeI64(this.createDate);
      output.writeFieldEnd();
    }
    if (this.extId !== null && this.extId !== undefined) {
      output.writeFieldBegin('extId', Thrift.Type.STRING, 11);
      output.writeString(this.extId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
PatternVariable = class {
  constructor(args) {
    this.id = null;
    this.key = null;
    this.defValue = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.key !== undefined && args.key !== null) {
        this.key = args.key;
      }
      if (args.defValue !== undefined && args.defValue !== null) {
        this.defValue = args.defValue;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.key = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.defValue = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('PatternVariable');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.key !== null && this.key !== undefined) {
      output.writeFieldBegin('key', Thrift.Type.STRING, 2);
      output.writeString(this.key);
      output.writeFieldEnd();
    }
    if (this.defValue !== null && this.defValue !== undefined) {
      output.writeFieldBegin('defValue', Thrift.Type.STRING, 3);
      output.writeString(this.defValue);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
PatternProcessRoleExec = class {
  constructor(args) {
    this.userOrGroup = null;
    this.childUserId = null;
    this.comment = null;
    this.commentDescription = null;
    this.deadlineDate = null;
    if (args) {
      if (args.userOrGroup !== undefined && args.userOrGroup !== null) {
        this.userOrGroup = new UserOrGroup(args.userOrGroup);
      }
      if (args.childUserId !== undefined && args.childUserId !== null) {
        this.childUserId = args.childUserId;
      }
      if (args.comment !== undefined && args.comment !== null) {
        this.comment = args.comment;
      }
      if (args.commentDescription !== undefined && args.commentDescription !== null) {
        this.commentDescription = args.commentDescription;
      }
      if (args.deadlineDate !== undefined && args.deadlineDate !== null) {
        this.deadlineDate = args.deadlineDate;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.userOrGroup = new UserOrGroup();
          this.userOrGroup.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.childUserId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.comment = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.commentDescription = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.I64) {
          this.deadlineDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('PatternProcessRoleExec');
    if (this.userOrGroup !== null && this.userOrGroup !== undefined) {
      output.writeFieldBegin('userOrGroup', Thrift.Type.STRUCT, 1);
      this.userOrGroup.write(output);
      output.writeFieldEnd();
    }
    if (this.childUserId !== null && this.childUserId !== undefined) {
      output.writeFieldBegin('childUserId', Thrift.Type.STRING, 2);
      output.writeString(this.childUserId);
      output.writeFieldEnd();
    }
    if (this.comment !== null && this.comment !== undefined) {
      output.writeFieldBegin('comment', Thrift.Type.STRING, 3);
      output.writeString(this.comment);
      output.writeFieldEnd();
    }
    if (this.commentDescription !== null && this.commentDescription !== undefined) {
      output.writeFieldBegin('commentDescription', Thrift.Type.STRING, 4);
      output.writeString(this.commentDescription);
      output.writeFieldEnd();
    }
    if (this.deadlineDate !== null && this.deadlineDate !== undefined) {
      output.writeFieldBegin('deadlineDate', Thrift.Type.I64, 5);
      output.writeI64(this.deadlineDate);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
PatternProcessRole = class {
  constructor(args) {
    this.id = null;
    this.key = null;
    this.oName = null;
    this.fixed = null;
    this.single = null;
    this.roleExecList = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.key !== undefined && args.key !== null) {
        this.key = args.key;
      }
      if (args.oName !== undefined && args.oName !== null) {
        this.oName = args.oName;
      }
      if (args.fixed !== undefined && args.fixed !== null) {
        this.fixed = args.fixed;
      }
      if (args.single !== undefined && args.single !== null) {
        this.single = args.single;
      }
      if (args.roleExecList !== undefined && args.roleExecList !== null) {
        this.roleExecList = Thrift.copyList(args.roleExecList, [PatternProcessRoleExec]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.key = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.oName = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.BOOL) {
          this.fixed = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.BOOL) {
          this.single = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.LIST) {
          this.roleExecList = [];
          const _rtmp3239 = input.readListBegin();
          const _size238 = _rtmp3239.size || 0;
          for (let _i240 = 0; _i240 < _size238; ++_i240) {
            let elem241 = null;
            elem241 = new PatternProcessRoleExec();
            elem241.read(input);
            this.roleExecList.push(elem241);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('PatternProcessRole');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.key !== null && this.key !== undefined) {
      output.writeFieldBegin('key', Thrift.Type.STRING, 2);
      output.writeString(this.key);
      output.writeFieldEnd();
    }
    if (this.oName !== null && this.oName !== undefined) {
      output.writeFieldBegin('oName', Thrift.Type.STRING, 3);
      output.writeString(this.oName);
      output.writeFieldEnd();
    }
    if (this.fixed !== null && this.fixed !== undefined) {
      output.writeFieldBegin('fixed', Thrift.Type.BOOL, 4);
      output.writeBool(this.fixed);
      output.writeFieldEnd();
    }
    if (this.single !== null && this.single !== undefined) {
      output.writeFieldBegin('single', Thrift.Type.BOOL, 5);
      output.writeBool(this.single);
      output.writeFieldEnd();
    }
    if (this.roleExecList !== null && this.roleExecList !== undefined) {
      output.writeFieldBegin('roleExecList', Thrift.Type.LIST, 6);
      output.writeListBegin(Thrift.Type.STRUCT, this.roleExecList.length);
      for (let iter242 in this.roleExecList) {
        if (this.roleExecList.hasOwnProperty(iter242)) {
          iter242 = this.roleExecList[iter242];
          iter242.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentRelationInfo = class {
  constructor(args) {
    this.id = null;
    this.createDate = null;
    this.name = null;
    this.systemNumber = null;
    this.numberDocument = null;
    this.registrationDate = null;
    this.doc2Access = null;
    this.status = null;
    this.subStatus = null;
    this.deadlineDate = null;
    this.cardDeadlineDate = null;
    this.icon = null;
    this.patternName = null;
    this.stageName = null;
    this.actionMap = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.createDate !== undefined && args.createDate !== null) {
        this.createDate = args.createDate;
      }
      if (args.name !== undefined && args.name !== null) {
        this.name = args.name;
      }
      if (args.systemNumber !== undefined && args.systemNumber !== null) {
        this.systemNumber = args.systemNumber;
      }
      if (args.numberDocument !== undefined && args.numberDocument !== null) {
        this.numberDocument = args.numberDocument;
      }
      if (args.registrationDate !== undefined && args.registrationDate !== null) {
        this.registrationDate = args.registrationDate;
      }
      if (args.doc2Access !== undefined && args.doc2Access !== null) {
        this.doc2Access = args.doc2Access;
      }
      if (args.status !== undefined && args.status !== null) {
        this.status = args.status;
      }
      if (args.subStatus !== undefined && args.subStatus !== null) {
        this.subStatus = args.subStatus;
      }
      if (args.deadlineDate !== undefined && args.deadlineDate !== null) {
        this.deadlineDate = args.deadlineDate;
      }
      if (args.cardDeadlineDate !== undefined && args.cardDeadlineDate !== null) {
        this.cardDeadlineDate = args.cardDeadlineDate;
      }
      if (args.icon !== undefined && args.icon !== null) {
        this.icon = args.icon;
      }
      if (args.patternName !== undefined && args.patternName !== null) {
        this.patternName = args.patternName;
      }
      if (args.stageName !== undefined && args.stageName !== null) {
        this.stageName = args.stageName;
      }
      if (args.actionMap !== undefined && args.actionMap !== null) {
        this.actionMap = Thrift.copyMap(args.actionMap, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I64) {
          this.createDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.name = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.systemNumber = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRING) {
          this.numberDocument = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.I64) {
          this.registrationDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.BOOL) {
          this.doc2Access = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.I32) {
          this.status = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 9:
        if (ftype == Thrift.Type.I32) {
          this.subStatus = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 10:
        if (ftype == Thrift.Type.I64) {
          this.deadlineDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 11:
        if (ftype == Thrift.Type.I64) {
          this.cardDeadlineDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 12:
        if (ftype == Thrift.Type.I32) {
          this.icon = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 13:
        if (ftype == Thrift.Type.STRING) {
          this.patternName = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 14:
        if (ftype == Thrift.Type.STRING) {
          this.stageName = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 15:
        if (ftype == Thrift.Type.MAP) {
          this.actionMap = {};
          const _rtmp3244 = input.readMapBegin();
          const _size243 = _rtmp3244.size || 0;
          for (let _i245 = 0; _i245 < _size243; ++_i245) {
            if (_i245 > 0 ) {
              if (input.rstack.length > input.rpos[input.rpos.length -1] + 1) {
                input.rstack.pop();
              }
            }
            let key246 = null;
            let val247 = null;
            key246 = input.readString().value;
            val247 = input.readI32().value;
            this.actionMap[key246] = val247;
          }
          input.readMapEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentRelationInfo');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.createDate !== null && this.createDate !== undefined) {
      output.writeFieldBegin('createDate', Thrift.Type.I64, 2);
      output.writeI64(this.createDate);
      output.writeFieldEnd();
    }
    if (this.name !== null && this.name !== undefined) {
      output.writeFieldBegin('name', Thrift.Type.STRING, 3);
      output.writeString(this.name);
      output.writeFieldEnd();
    }
    if (this.systemNumber !== null && this.systemNumber !== undefined) {
      output.writeFieldBegin('systemNumber', Thrift.Type.STRING, 4);
      output.writeString(this.systemNumber);
      output.writeFieldEnd();
    }
    if (this.numberDocument !== null && this.numberDocument !== undefined) {
      output.writeFieldBegin('numberDocument', Thrift.Type.STRING, 5);
      output.writeString(this.numberDocument);
      output.writeFieldEnd();
    }
    if (this.registrationDate !== null && this.registrationDate !== undefined) {
      output.writeFieldBegin('registrationDate', Thrift.Type.I64, 6);
      output.writeI64(this.registrationDate);
      output.writeFieldEnd();
    }
    if (this.doc2Access !== null && this.doc2Access !== undefined) {
      output.writeFieldBegin('doc2Access', Thrift.Type.BOOL, 7);
      output.writeBool(this.doc2Access);
      output.writeFieldEnd();
    }
    if (this.status !== null && this.status !== undefined) {
      output.writeFieldBegin('status', Thrift.Type.I32, 8);
      output.writeI32(this.status);
      output.writeFieldEnd();
    }
    if (this.subStatus !== null && this.subStatus !== undefined) {
      output.writeFieldBegin('subStatus', Thrift.Type.I32, 9);
      output.writeI32(this.subStatus);
      output.writeFieldEnd();
    }
    if (this.deadlineDate !== null && this.deadlineDate !== undefined) {
      output.writeFieldBegin('deadlineDate', Thrift.Type.I64, 10);
      output.writeI64(this.deadlineDate);
      output.writeFieldEnd();
    }
    if (this.cardDeadlineDate !== null && this.cardDeadlineDate !== undefined) {
      output.writeFieldBegin('cardDeadlineDate', Thrift.Type.I64, 11);
      output.writeI64(this.cardDeadlineDate);
      output.writeFieldEnd();
    }
    if (this.icon !== null && this.icon !== undefined) {
      output.writeFieldBegin('icon', Thrift.Type.I32, 12);
      output.writeI32(this.icon);
      output.writeFieldEnd();
    }
    if (this.patternName !== null && this.patternName !== undefined) {
      output.writeFieldBegin('patternName', Thrift.Type.STRING, 13);
      output.writeString(this.patternName);
      output.writeFieldEnd();
    }
    if (this.stageName !== null && this.stageName !== undefined) {
      output.writeFieldBegin('stageName', Thrift.Type.STRING, 14);
      output.writeString(this.stageName);
      output.writeFieldEnd();
    }
    if (this.actionMap !== null && this.actionMap !== undefined) {
      output.writeFieldBegin('actionMap', Thrift.Type.MAP, 15);
      output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.I32, Thrift.objectLength(this.actionMap));
      for (let kiter248 in this.actionMap) {
        if (this.actionMap.hasOwnProperty(kiter248)) {
          let viter249 = this.actionMap[kiter248];
          output.writeString(kiter248);
          output.writeI32(viter249);
        }
      }
      output.writeMapEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentRelationLink = class {
  constructor(args) {
    this.fromId = null;
    this.toId = null;
    this.linkType = null;
    this.isAuto = null;
    if (args) {
      if (args.fromId !== undefined && args.fromId !== null) {
        this.fromId = args.fromId;
      }
      if (args.toId !== undefined && args.toId !== null) {
        this.toId = args.toId;
      }
      if (args.linkType !== undefined && args.linkType !== null) {
        this.linkType = args.linkType;
      }
      if (args.isAuto !== undefined && args.isAuto !== null) {
        this.isAuto = args.isAuto;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.fromId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.toId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I32) {
          this.linkType = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.BOOL) {
          this.isAuto = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentRelationLink');
    if (this.fromId !== null && this.fromId !== undefined) {
      output.writeFieldBegin('fromId', Thrift.Type.STRING, 1);
      output.writeString(this.fromId);
      output.writeFieldEnd();
    }
    if (this.toId !== null && this.toId !== undefined) {
      output.writeFieldBegin('toId', Thrift.Type.STRING, 2);
      output.writeString(this.toId);
      output.writeFieldEnd();
    }
    if (this.linkType !== null && this.linkType !== undefined) {
      output.writeFieldBegin('linkType', Thrift.Type.I32, 3);
      output.writeI32(this.linkType);
      output.writeFieldEnd();
    }
    if (this.isAuto !== null && this.isAuto !== undefined) {
      output.writeFieldBegin('isAuto', Thrift.Type.BOOL, 4);
      output.writeBool(this.isAuto);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentRelationModel = class {
  constructor(args) {
    this.docId = null;
    this.docRelInfoList = null;
    this.docRelLinkList = null;
    if (args) {
      if (args.docId !== undefined && args.docId !== null) {
        this.docId = args.docId;
      }
      if (args.docRelInfoList !== undefined && args.docRelInfoList !== null) {
        this.docRelInfoList = Thrift.copyList(args.docRelInfoList, [DocumentRelationInfo]);
      }
      if (args.docRelLinkList !== undefined && args.docRelLinkList !== null) {
        this.docRelLinkList = Thrift.copyList(args.docRelLinkList, [DocumentRelationLink]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.docId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.LIST) {
          this.docRelInfoList = [];
          const _rtmp3251 = input.readListBegin();
          const _size250 = _rtmp3251.size || 0;
          for (let _i252 = 0; _i252 < _size250; ++_i252) {
            let elem253 = null;
            elem253 = new DocumentRelationInfo();
            elem253.read(input);
            this.docRelInfoList.push(elem253);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.docRelLinkList = [];
          const _rtmp3255 = input.readListBegin();
          const _size254 = _rtmp3255.size || 0;
          for (let _i256 = 0; _i256 < _size254; ++_i256) {
            let elem257 = null;
            elem257 = new DocumentRelationLink();
            elem257.read(input);
            this.docRelLinkList.push(elem257);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentRelationModel');
    if (this.docId !== null && this.docId !== undefined) {
      output.writeFieldBegin('docId', Thrift.Type.STRING, 1);
      output.writeString(this.docId);
      output.writeFieldEnd();
    }
    if (this.docRelInfoList !== null && this.docRelInfoList !== undefined) {
      output.writeFieldBegin('docRelInfoList', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.STRUCT, this.docRelInfoList.length);
      for (let iter258 in this.docRelInfoList) {
        if (this.docRelInfoList.hasOwnProperty(iter258)) {
          iter258 = this.docRelInfoList[iter258];
          iter258.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.docRelLinkList !== null && this.docRelLinkList !== undefined) {
      output.writeFieldBegin('docRelLinkList', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRUCT, this.docRelLinkList.length);
      for (let iter259 in this.docRelLinkList) {
        if (this.docRelLinkList.hasOwnProperty(iter259)) {
          iter259 = this.docRelLinkList[iter259];
          iter259.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
//
// Autogenerated by Thrift Compiler (0.13.0)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//
if (typeof Int64 === 'undefined' && typeof require === 'function') {
  const Int64 = require('node-int64');
}


AccountDefineConf = {
  'GROUP_ALL' : 0,
  'DECISION_DICT' : 1,
  'A4_TEMPLATE_DICT' : 2
};
ReportType = {
  'XML' : 0,
  'PDF' : 1,
  'XLS' : 2,
  'DOC' : 3
};
ReportTemplateType = {
  'COMMON' : 0,
  'PATTERN' : 1
};
FileStorageType = {
  'PRIMARY' : 0,
  'ARCHIVE' : 1
};
NotificationType = {
  'MEETING_CREATE' : 0,
  'MEETING_UPDATE' : 1,
  'MEETING_CANCEL' : 2,
  'MEETING_SUGGESTION_OTHER_TIME' : 3,
  'MEETING_INVITATION_SECRETARY' : 4,
  'MEETING_MOVE_TO_PRE_VOTE' : 5,
  'MEETING_MOVE_TO_PREPARE' : 6,
  'MEETING_MOVE_TO_VOTE' : 7,
  'DOCUMENT_MOVE_TO_NEXT_STAGE' : 8,
  'DOCUMENT_PERIODICAL_REMINDER' : 9,
  'DOCUMENT_REASSIGN' : 10,
  'DOCUMENT_REASSIGN_WITH_CONTROL' : 11,
  'REASSIGN_DOCUMENT_EXECUTION_CARD_CLOSED' : 12,
  'REASSIGN_DOCUMENT_EXECUTION_CARD_REVOKED' : 13,
  'DOCUMENT_EXECUTION_CARD_CLOSED' : 14,
  'DOCUMENT_ON_CONTROL_RETURNED' : 15,
  'DOCUMENT_EXPIRED' : 16,
  'DOCUMENT_DEADLINE_ONCOMING' : 17,
  'DOCUMENT_DEADLINE_OVERDUE' : 18,
  'DOCUMENT_EXECUTION_DELETED' : 19,
  'RESET_PASSWORD' : 20,
  'SET_PASSWORD_FOR_NEW_USER' : 21,
  'DOCUMENT_REGISTERED' : 22,
  'DOCUMENT_EXECUTION_CARD_AUTO_CLOSED' : 23,
  'DOCUMENT_DECISION' : 24,
  'DOCUMENT_FAMILIARIZATION' : 25,
  'DOCUMENT_ADDITIONAL_DECISION' : 26,
  'DOCUMENT_ADD_ADDITIONAL_CONFIRMER' : 27,
  'DOCUMENT_ATTACHMENT_LOADED' : 28,
  'RECOVERY_PASSWORD' : 29,
  'DOCUMENT_EXECUTOR_REMINDER' : 30,
  'EVENT_CREATE' : 31,
  'EVENT_UPDATE' : 32,
  'EVENT_CANCEL' : 33,
  'REGISTRATION_LDAP_USER' : 34,
  'NEWS_CREATE' : 35,
  'COMING_USER_CERTIFICATE_DEADLINE' : 36,
  'USER_CERTIFICATE_DEADLINE' : 37,
  'USER_CERTIFICATE_DELETED' : 38,
  'CERTIFICATE_APPROVED' : 39,
  'CERTIFICATE_DECLINED' : 40
};
KeyState = {
  'LOADED' : 0,
  'CONFIRM' : 1,
  'PROHIBITED' : 2,
  'NO_FILE' : 3,
  'DELETED' : 4
};
SearchType = {
  'S_LIKE' : 0,
  'S_LIKE_SEMANTIC' : 1,
  'S_ALL' : 2,
  'S_ALL_SEMANTIC' : 3,
  'S_ANY' : 4,
  'S_ANY_SEMANTIC' : 5
};
ExecutorActionType = {
  'ADD' : 0,
  'DELETE' : 1
};
Account = class {
  constructor(args) {
    this.id = null;
    this.createDate = null;
    this.accountName = null;
    this.main = null;
    this.confidential = null;
    this.encrypted = null;
    this.accountCof = null;
    this.storages = null;
    this.accountGroupId = null;
    this.orderNum = null;
    this.extType = null;
    this.authServiceId = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.createDate !== undefined && args.createDate !== null) {
        this.createDate = args.createDate;
      }
      if (args.accountName !== undefined && args.accountName !== null) {
        this.accountName = args.accountName;
      }
      if (args.main !== undefined && args.main !== null) {
        this.main = args.main;
      }
      if (args.confidential !== undefined && args.confidential !== null) {
        this.confidential = args.confidential;
      }
      if (args.encrypted !== undefined && args.encrypted !== null) {
        this.encrypted = args.encrypted;
      }
      if (args.accountCof !== undefined && args.accountCof !== null) {
        this.accountCof = Thrift.copyMap(args.accountCof, [null]);
      }
      if (args.storages !== undefined && args.storages !== null) {
        this.storages = Thrift.copyList(args.storages, [null]);
      }
      if (args.accountGroupId !== undefined && args.accountGroupId !== null) {
        this.accountGroupId = args.accountGroupId;
      }
      if (args.orderNum !== undefined && args.orderNum !== null) {
        this.orderNum = args.orderNum;
      }
      if (args.extType !== undefined && args.extType !== null) {
        this.extType = args.extType;
      }
      if (args.authServiceId !== undefined && args.authServiceId !== null) {
        this.authServiceId = args.authServiceId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I64) {
          this.createDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.accountName = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.BOOL) {
          this.main = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.BOOL) {
          this.confidential = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.BOOL) {
          this.encrypted = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.MAP) {
          this.accountCof = {};
          const _rtmp31 = input.readMapBegin();
          const _size0 = _rtmp31.size || 0;
          for (let _i2 = 0; _i2 < _size0; ++_i2) {
            if (_i2 > 0 ) {
              if (input.rstack.length > input.rpos[input.rpos.length -1] + 1) {
                input.rstack.pop();
              }
            }
            let key3 = null;
            let val4 = null;
            key3 = input.readI32().value;
            val4 = input.readString().value;
            this.accountCof[key3] = val4;
          }
          input.readMapEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.LIST) {
          this.storages = [];
          const _rtmp36 = input.readListBegin();
          const _size5 = _rtmp36.size || 0;
          for (let _i7 = 0; _i7 < _size5; ++_i7) {
            let elem8 = null;
            elem8 = new FileStorage();
            elem8.read(input);
            this.storages.push(elem8);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 9:
        if (ftype == Thrift.Type.STRING) {
          this.accountGroupId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 10:
        if (ftype == Thrift.Type.I32) {
          this.orderNum = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 11:
        if (ftype == Thrift.Type.STRING) {
          this.extType = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 12:
        if (ftype == Thrift.Type.STRING) {
          this.authServiceId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Account');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.createDate !== null && this.createDate !== undefined) {
      output.writeFieldBegin('createDate', Thrift.Type.I64, 2);
      output.writeI64(this.createDate);
      output.writeFieldEnd();
    }
    if (this.accountName !== null && this.accountName !== undefined) {
      output.writeFieldBegin('accountName', Thrift.Type.STRING, 3);
      output.writeString(this.accountName);
      output.writeFieldEnd();
    }
    if (this.main !== null && this.main !== undefined) {
      output.writeFieldBegin('main', Thrift.Type.BOOL, 4);
      output.writeBool(this.main);
      output.writeFieldEnd();
    }
    if (this.confidential !== null && this.confidential !== undefined) {
      output.writeFieldBegin('confidential', Thrift.Type.BOOL, 5);
      output.writeBool(this.confidential);
      output.writeFieldEnd();
    }
    if (this.encrypted !== null && this.encrypted !== undefined) {
      output.writeFieldBegin('encrypted', Thrift.Type.BOOL, 6);
      output.writeBool(this.encrypted);
      output.writeFieldEnd();
    }
    if (this.accountCof !== null && this.accountCof !== undefined) {
      output.writeFieldBegin('accountCof', Thrift.Type.MAP, 7);
      output.writeMapBegin(Thrift.Type.I32, Thrift.Type.STRING, Thrift.objectLength(this.accountCof));
      for (let kiter9 in this.accountCof) {
        if (this.accountCof.hasOwnProperty(kiter9)) {
          let viter10 = this.accountCof[kiter9];
          output.writeI32(kiter9);
          output.writeString(viter10);
        }
      }
      output.writeMapEnd();
      output.writeFieldEnd();
    }
    if (this.storages !== null && this.storages !== undefined) {
      output.writeFieldBegin('storages', Thrift.Type.LIST, 8);
      output.writeListBegin(Thrift.Type.STRUCT, this.storages.length);
      for (let iter11 in this.storages) {
        if (this.storages.hasOwnProperty(iter11)) {
          iter11 = this.storages[iter11];
          iter11.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.accountGroupId !== null && this.accountGroupId !== undefined) {
      output.writeFieldBegin('accountGroupId', Thrift.Type.STRING, 9);
      output.writeString(this.accountGroupId);
      output.writeFieldEnd();
    }
    if (this.orderNum !== null && this.orderNum !== undefined) {
      output.writeFieldBegin('orderNum', Thrift.Type.I32, 10);
      output.writeI32(this.orderNum);
      output.writeFieldEnd();
    }
    if (this.extType !== null && this.extType !== undefined) {
      output.writeFieldBegin('extType', Thrift.Type.STRING, 11);
      output.writeString(this.extType);
      output.writeFieldEnd();
    }
    if (this.authServiceId !== null && this.authServiceId !== undefined) {
      output.writeFieldBegin('authServiceId', Thrift.Type.STRING, 12);
      output.writeString(this.authServiceId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
AccountGroup = class {
  constructor(args) {
    this.id = null;
    this.oName = null;
    this.accounts = null;
    this.blocked = null;
    this.visibleAllAccounts = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.oName !== undefined && args.oName !== null) {
        this.oName = args.oName;
      }
      if (args.accounts !== undefined && args.accounts !== null) {
        this.accounts = Thrift.copyList(args.accounts, [Account]);
      }
      if (args.blocked !== undefined && args.blocked !== null) {
        this.blocked = args.blocked;
      }
      if (args.visibleAllAccounts !== undefined && args.visibleAllAccounts !== null) {
        this.visibleAllAccounts = args.visibleAllAccounts;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.oName = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.accounts = [];
          const _rtmp313 = input.readListBegin();
          const _size12 = _rtmp313.size || 0;
          for (let _i14 = 0; _i14 < _size12; ++_i14) {
            let elem15 = null;
            elem15 = new Account();
            elem15.read(input);
            this.accounts.push(elem15);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.BOOL) {
          this.blocked = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.BOOL) {
          this.visibleAllAccounts = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('AccountGroup');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.oName !== null && this.oName !== undefined) {
      output.writeFieldBegin('oName', Thrift.Type.STRING, 2);
      output.writeString(this.oName);
      output.writeFieldEnd();
    }
    if (this.accounts !== null && this.accounts !== undefined) {
      output.writeFieldBegin('accounts', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRUCT, this.accounts.length);
      for (let iter16 in this.accounts) {
        if (this.accounts.hasOwnProperty(iter16)) {
          iter16 = this.accounts[iter16];
          iter16.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.blocked !== null && this.blocked !== undefined) {
      output.writeFieldBegin('blocked', Thrift.Type.BOOL, 4);
      output.writeBool(this.blocked);
      output.writeFieldEnd();
    }
    if (this.visibleAllAccounts !== null && this.visibleAllAccounts !== undefined) {
      output.writeFieldBegin('visibleAllAccounts', Thrift.Type.BOOL, 5);
      output.writeBool(this.visibleAllAccounts);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ReportParams = class {
  constructor(args) {
    this.id = null;
    this.key = null;
    this.value = null;
    this.type = null;
    this.requared = null;
    this.oName = null;
    this.handbookId = null;
    this.handbookLookupCol = null;
    this.handbookSelectColumn = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.key !== undefined && args.key !== null) {
        this.key = args.key;
      }
      if (args.value !== undefined && args.value !== null) {
        this.value = args.value;
      }
      if (args.type !== undefined && args.type !== null) {
        this.type = args.type;
      }
      if (args.requared !== undefined && args.requared !== null) {
        this.requared = args.requared;
      }
      if (args.oName !== undefined && args.oName !== null) {
        this.oName = args.oName;
      }
      if (args.handbookId !== undefined && args.handbookId !== null) {
        this.handbookId = args.handbookId;
      }
      if (args.handbookLookupCol !== undefined && args.handbookLookupCol !== null) {
        this.handbookLookupCol = args.handbookLookupCol;
      }
      if (args.handbookSelectColumn !== undefined && args.handbookSelectColumn !== null) {
        this.handbookSelectColumn = args.handbookSelectColumn;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.key = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.value = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I32) {
          this.type = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.BOOL) {
          this.requared = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.STRING) {
          this.oName = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.STRING) {
          this.handbookId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.STRING) {
          this.handbookLookupCol = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 9:
        if (ftype == Thrift.Type.STRING) {
          this.handbookSelectColumn = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ReportParams');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.key !== null && this.key !== undefined) {
      output.writeFieldBegin('key', Thrift.Type.STRING, 2);
      output.writeString(this.key);
      output.writeFieldEnd();
    }
    if (this.value !== null && this.value !== undefined) {
      output.writeFieldBegin('value', Thrift.Type.STRING, 3);
      output.writeString(this.value);
      output.writeFieldEnd();
    }
    if (this.type !== null && this.type !== undefined) {
      output.writeFieldBegin('type', Thrift.Type.I32, 4);
      output.writeI32(this.type);
      output.writeFieldEnd();
    }
    if (this.requared !== null && this.requared !== undefined) {
      output.writeFieldBegin('requared', Thrift.Type.BOOL, 5);
      output.writeBool(this.requared);
      output.writeFieldEnd();
    }
    if (this.oName !== null && this.oName !== undefined) {
      output.writeFieldBegin('oName', Thrift.Type.STRING, 6);
      output.writeString(this.oName);
      output.writeFieldEnd();
    }
    if (this.handbookId !== null && this.handbookId !== undefined) {
      output.writeFieldBegin('handbookId', Thrift.Type.STRING, 7);
      output.writeString(this.handbookId);
      output.writeFieldEnd();
    }
    if (this.handbookLookupCol !== null && this.handbookLookupCol !== undefined) {
      output.writeFieldBegin('handbookLookupCol', Thrift.Type.STRING, 8);
      output.writeString(this.handbookLookupCol);
      output.writeFieldEnd();
    }
    if (this.handbookSelectColumn !== null && this.handbookSelectColumn !== undefined) {
      output.writeFieldBegin('handbookSelectColumn', Thrift.Type.STRING, 9);
      output.writeString(this.handbookSelectColumn);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
ReportTemplate = class {
  constructor(args) {
    this.id = null;
    this.createDate = null;
    this.reportName = null;
    this.fastPrint = null;
    this.reportCount = null;
    this.adParams = null;
    this.group = null;
    this.reportType = null;
    this.accountIds = null;
    this.reportTypes = null;
    this.addWatermark = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.createDate !== undefined && args.createDate !== null) {
        this.createDate = args.createDate;
      }
      if (args.reportName !== undefined && args.reportName !== null) {
        this.reportName = args.reportName;
      }
      if (args.fastPrint !== undefined && args.fastPrint !== null) {
        this.fastPrint = args.fastPrint;
      }
      if (args.reportCount !== undefined && args.reportCount !== null) {
        this.reportCount = args.reportCount;
      }
      if (args.adParams !== undefined && args.adParams !== null) {
        this.adParams = Thrift.copyList(args.adParams, [ReportParams]);
      }
      if (args.group !== undefined && args.group !== null) {
        this.group = args.group;
      }
      if (args.reportType !== undefined && args.reportType !== null) {
        this.reportType = args.reportType;
      }
      if (args.accountIds !== undefined && args.accountIds !== null) {
        this.accountIds = Thrift.copyList(args.accountIds, [null]);
      }
      if (args.reportTypes !== undefined && args.reportTypes !== null) {
        this.reportTypes = Thrift.copyList(args.reportTypes, [null]);
      }
      if (args.addWatermark !== undefined && args.addWatermark !== null) {
        this.addWatermark = args.addWatermark;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I64) {
          this.createDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.reportName = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.BOOL) {
          this.fastPrint = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.I64) {
          this.reportCount = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.LIST) {
          this.adParams = [];
          const _rtmp318 = input.readListBegin();
          const _size17 = _rtmp318.size || 0;
          for (let _i19 = 0; _i19 < _size17; ++_i19) {
            let elem20 = null;
            elem20 = new ReportParams();
            elem20.read(input);
            this.adParams.push(elem20);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.STRING) {
          this.group = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.I32) {
          this.reportType = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 9:
        if (ftype == Thrift.Type.SET) {
          this.accountIds = [];
          const _rtmp322 = input.readSetBegin();
          const _size21 = _rtmp322.size || 0;
          for (let _i23 = 0; _i23 < _size21; ++_i23) {
            let elem24 = null;
            elem24 = input.readString().value;
            this.accountIds.push(elem24);
          }
          input.readSetEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 10:
        if (ftype == Thrift.Type.SET) {
          this.reportTypes = [];
          const _rtmp326 = input.readSetBegin();
          const _size25 = _rtmp326.size || 0;
          for (let _i27 = 0; _i27 < _size25; ++_i27) {
            let elem28 = null;
            elem28 = input.readI32().value;
            this.reportTypes.push(elem28);
          }
          input.readSetEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 11:
        if (ftype == Thrift.Type.BOOL) {
          this.addWatermark = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ReportTemplate');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.createDate !== null && this.createDate !== undefined) {
      output.writeFieldBegin('createDate', Thrift.Type.I64, 2);
      output.writeI64(this.createDate);
      output.writeFieldEnd();
    }
    if (this.reportName !== null && this.reportName !== undefined) {
      output.writeFieldBegin('reportName', Thrift.Type.STRING, 3);
      output.writeString(this.reportName);
      output.writeFieldEnd();
    }
    if (this.fastPrint !== null && this.fastPrint !== undefined) {
      output.writeFieldBegin('fastPrint', Thrift.Type.BOOL, 4);
      output.writeBool(this.fastPrint);
      output.writeFieldEnd();
    }
    if (this.reportCount !== null && this.reportCount !== undefined) {
      output.writeFieldBegin('reportCount', Thrift.Type.I64, 5);
      output.writeI64(this.reportCount);
      output.writeFieldEnd();
    }
    if (this.adParams !== null && this.adParams !== undefined) {
      output.writeFieldBegin('adParams', Thrift.Type.LIST, 6);
      output.writeListBegin(Thrift.Type.STRUCT, this.adParams.length);
      for (let iter29 in this.adParams) {
        if (this.adParams.hasOwnProperty(iter29)) {
          iter29 = this.adParams[iter29];
          iter29.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.group !== null && this.group !== undefined) {
      output.writeFieldBegin('group', Thrift.Type.STRING, 7);
      output.writeString(this.group);
      output.writeFieldEnd();
    }
    if (this.reportType !== null && this.reportType !== undefined) {
      output.writeFieldBegin('reportType', Thrift.Type.I32, 8);
      output.writeI32(this.reportType);
      output.writeFieldEnd();
    }
    if (this.accountIds !== null && this.accountIds !== undefined) {
      output.writeFieldBegin('accountIds', Thrift.Type.SET, 9);
      output.writeSetBegin(Thrift.Type.STRING, this.accountIds.length);
      for (let iter30 in this.accountIds) {
        if (this.accountIds.hasOwnProperty(iter30)) {
          iter30 = this.accountIds[iter30];
          output.writeString(iter30);
        }
      }
      output.writeSetEnd();
      output.writeFieldEnd();
    }
    if (this.reportTypes !== null && this.reportTypes !== undefined) {
      output.writeFieldBegin('reportTypes', Thrift.Type.SET, 10);
      output.writeSetBegin(Thrift.Type.I32, this.reportTypes.length);
      for (let iter31 in this.reportTypes) {
        if (this.reportTypes.hasOwnProperty(iter31)) {
          iter31 = this.reportTypes[iter31];
          output.writeI32(iter31);
        }
      }
      output.writeSetEnd();
      output.writeFieldEnd();
    }
    if (this.addWatermark !== null && this.addWatermark !== undefined) {
      output.writeFieldBegin('addWatermark', Thrift.Type.BOOL, 11);
      output.writeBool(this.addWatermark);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
SecurityClassification = class {
  constructor(args) {
    this.id = null;
    this.gname = null;
    this.scDescription = null;
    this.group = null;
    this.share = null;
    this.scMask = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.gname !== undefined && args.gname !== null) {
        this.gname = args.gname;
      }
      if (args.scDescription !== undefined && args.scDescription !== null) {
        this.scDescription = args.scDescription;
      }
      if (args.group !== undefined && args.group !== null) {
        this.group = args.group;
      }
      if (args.share !== undefined && args.share !== null) {
        this.share = args.share;
      }
      if (args.scMask !== undefined && args.scMask !== null) {
        this.scMask = args.scMask;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.gname = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.scDescription = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.group = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.BOOL) {
          this.share = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.STRING) {
          this.scMask = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('SecurityClassification');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.gname !== null && this.gname !== undefined) {
      output.writeFieldBegin('gname', Thrift.Type.STRING, 2);
      output.writeString(this.gname);
      output.writeFieldEnd();
    }
    if (this.scDescription !== null && this.scDescription !== undefined) {
      output.writeFieldBegin('scDescription', Thrift.Type.STRING, 3);
      output.writeString(this.scDescription);
      output.writeFieldEnd();
    }
    if (this.group !== null && this.group !== undefined) {
      output.writeFieldBegin('group', Thrift.Type.STRING, 4);
      output.writeString(this.group);
      output.writeFieldEnd();
    }
    if (this.share !== null && this.share !== undefined) {
      output.writeFieldBegin('share', Thrift.Type.BOOL, 5);
      output.writeBool(this.share);
      output.writeFieldEnd();
    }
    if (this.scMask !== null && this.scMask !== undefined) {
      output.writeFieldBegin('scMask', Thrift.Type.STRING, 6);
      output.writeString(this.scMask);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
News = class {
  constructor(args) {
    this.id = null;
    this.createDate = null;
    this.theNewsName = null;
    this.theNewsDescription = null;
    this.accountIds = null;
    this.previewUrl = null;
    this.urls = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.createDate !== undefined && args.createDate !== null) {
        this.createDate = args.createDate;
      }
      if (args.theNewsName !== undefined && args.theNewsName !== null) {
        this.theNewsName = args.theNewsName;
      }
      if (args.theNewsDescription !== undefined && args.theNewsDescription !== null) {
        this.theNewsDescription = args.theNewsDescription;
      }
      if (args.accountIds !== undefined && args.accountIds !== null) {
        this.accountIds = Thrift.copyList(args.accountIds, [null]);
      }
      if (args.previewUrl !== undefined && args.previewUrl !== null) {
        this.previewUrl = args.previewUrl;
      }
      if (args.urls !== undefined && args.urls !== null) {
        this.urls = Thrift.copyList(args.urls, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I64) {
          this.createDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.theNewsName = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.theNewsDescription = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.SET) {
          this.accountIds = [];
          const _rtmp333 = input.readSetBegin();
          const _size32 = _rtmp333.size || 0;
          for (let _i34 = 0; _i34 < _size32; ++_i34) {
            let elem35 = null;
            elem35 = input.readString().value;
            this.accountIds.push(elem35);
          }
          input.readSetEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.STRING) {
          this.previewUrl = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.LIST) {
          this.urls = [];
          const _rtmp337 = input.readListBegin();
          const _size36 = _rtmp337.size || 0;
          for (let _i38 = 0; _i38 < _size36; ++_i38) {
            let elem39 = null;
            elem39 = input.readString().value;
            this.urls.push(elem39);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('News');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.createDate !== null && this.createDate !== undefined) {
      output.writeFieldBegin('createDate', Thrift.Type.I64, 2);
      output.writeI64(this.createDate);
      output.writeFieldEnd();
    }
    if (this.theNewsName !== null && this.theNewsName !== undefined) {
      output.writeFieldBegin('theNewsName', Thrift.Type.STRING, 3);
      output.writeString(this.theNewsName);
      output.writeFieldEnd();
    }
    if (this.theNewsDescription !== null && this.theNewsDescription !== undefined) {
      output.writeFieldBegin('theNewsDescription', Thrift.Type.STRING, 4);
      output.writeString(this.theNewsDescription);
      output.writeFieldEnd();
    }
    if (this.accountIds !== null && this.accountIds !== undefined) {
      output.writeFieldBegin('accountIds', Thrift.Type.SET, 5);
      output.writeSetBegin(Thrift.Type.STRING, this.accountIds.length);
      for (let iter40 in this.accountIds) {
        if (this.accountIds.hasOwnProperty(iter40)) {
          iter40 = this.accountIds[iter40];
          output.writeString(iter40);
        }
      }
      output.writeSetEnd();
      output.writeFieldEnd();
    }
    if (this.previewUrl !== null && this.previewUrl !== undefined) {
      output.writeFieldBegin('previewUrl', Thrift.Type.STRING, 6);
      output.writeString(this.previewUrl);
      output.writeFieldEnd();
    }
    if (this.urls !== null && this.urls !== undefined) {
      output.writeFieldBegin('urls', Thrift.Type.LIST, 7);
      output.writeListBegin(Thrift.Type.STRING, this.urls.length);
      for (let iter41 in this.urls) {
        if (this.urls.hasOwnProperty(iter41)) {
          iter41 = this.urls[iter41];
          output.writeString(iter41);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
FileStorage = class {
  constructor(args) {
    this.id = null;
    this.uri = null;
    this.createDate = null;
    this.type = null;
    this.priority = null;
    this.readOnly = null;
    this.descriptionFileStorage = null;
    this.capacity = null;
    this.freeSpace = null;
    this.accountId = null;
    this.allowEdit = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.uri !== undefined && args.uri !== null) {
        this.uri = args.uri;
      }
      if (args.createDate !== undefined && args.createDate !== null) {
        this.createDate = args.createDate;
      }
      if (args.type !== undefined && args.type !== null) {
        this.type = args.type;
      }
      if (args.priority !== undefined && args.priority !== null) {
        this.priority = args.priority;
      }
      if (args.readOnly !== undefined && args.readOnly !== null) {
        this.readOnly = args.readOnly;
      }
      if (args.descriptionFileStorage !== undefined && args.descriptionFileStorage !== null) {
        this.descriptionFileStorage = args.descriptionFileStorage;
      }
      if (args.capacity !== undefined && args.capacity !== null) {
        this.capacity = args.capacity;
      }
      if (args.freeSpace !== undefined && args.freeSpace !== null) {
        this.freeSpace = args.freeSpace;
      }
      if (args.accountId !== undefined && args.accountId !== null) {
        this.accountId = args.accountId;
      }
      if (args.allowEdit !== undefined && args.allowEdit !== null) {
        this.allowEdit = args.allowEdit;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.uri = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I64) {
          this.createDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I32) {
          this.type = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.I32) {
          this.priority = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.BOOL) {
          this.readOnly = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.STRING) {
          this.descriptionFileStorage = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.I64) {
          this.capacity = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 9:
        if (ftype == Thrift.Type.I64) {
          this.freeSpace = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 10:
        if (ftype == Thrift.Type.STRING) {
          this.accountId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 11:
        if (ftype == Thrift.Type.BOOL) {
          this.allowEdit = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('FileStorage');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.uri !== null && this.uri !== undefined) {
      output.writeFieldBegin('uri', Thrift.Type.STRING, 2);
      output.writeString(this.uri);
      output.writeFieldEnd();
    }
    if (this.createDate !== null && this.createDate !== undefined) {
      output.writeFieldBegin('createDate', Thrift.Type.I64, 3);
      output.writeI64(this.createDate);
      output.writeFieldEnd();
    }
    if (this.type !== null && this.type !== undefined) {
      output.writeFieldBegin('type', Thrift.Type.I32, 4);
      output.writeI32(this.type);
      output.writeFieldEnd();
    }
    if (this.priority !== null && this.priority !== undefined) {
      output.writeFieldBegin('priority', Thrift.Type.I32, 5);
      output.writeI32(this.priority);
      output.writeFieldEnd();
    }
    if (this.readOnly !== null && this.readOnly !== undefined) {
      output.writeFieldBegin('readOnly', Thrift.Type.BOOL, 6);
      output.writeBool(this.readOnly);
      output.writeFieldEnd();
    }
    if (this.descriptionFileStorage !== null && this.descriptionFileStorage !== undefined) {
      output.writeFieldBegin('descriptionFileStorage', Thrift.Type.STRING, 7);
      output.writeString(this.descriptionFileStorage);
      output.writeFieldEnd();
    }
    if (this.capacity !== null && this.capacity !== undefined) {
      output.writeFieldBegin('capacity', Thrift.Type.I64, 8);
      output.writeI64(this.capacity);
      output.writeFieldEnd();
    }
    if (this.freeSpace !== null && this.freeSpace !== undefined) {
      output.writeFieldBegin('freeSpace', Thrift.Type.I64, 9);
      output.writeI64(this.freeSpace);
      output.writeFieldEnd();
    }
    if (this.accountId !== null && this.accountId !== undefined) {
      output.writeFieldBegin('accountId', Thrift.Type.STRING, 10);
      output.writeString(this.accountId);
      output.writeFieldEnd();
    }
    if (this.allowEdit !== null && this.allowEdit !== undefined) {
      output.writeFieldBegin('allowEdit', Thrift.Type.BOOL, 11);
      output.writeBool(this.allowEdit);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
CertificateInfo = class {
  constructor(args) {
    this.serialNumber = null;
    this.issuerDN = null;
    this.subjectDN = null;
    this.signDate = null;
    this.beforeDate = null;
    this.afterDate = null;
    this.signature = null;
    if (args) {
      if (args.serialNumber !== undefined && args.serialNumber !== null) {
        this.serialNumber = args.serialNumber;
      }
      if (args.issuerDN !== undefined && args.issuerDN !== null) {
        this.issuerDN = args.issuerDN;
      }
      if (args.subjectDN !== undefined && args.subjectDN !== null) {
        this.subjectDN = args.subjectDN;
      }
      if (args.signDate !== undefined && args.signDate !== null) {
        this.signDate = args.signDate;
      }
      if (args.beforeDate !== undefined && args.beforeDate !== null) {
        this.beforeDate = args.beforeDate;
      }
      if (args.afterDate !== undefined && args.afterDate !== null) {
        this.afterDate = args.afterDate;
      }
      if (args.signature !== undefined && args.signature !== null) {
        this.signature = args.signature;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.serialNumber = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.issuerDN = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.subjectDN = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I64) {
          this.signDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.I64) {
          this.beforeDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.I64) {
          this.afterDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.STRING) {
          this.signature = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('CertificateInfo');
    if (this.serialNumber !== null && this.serialNumber !== undefined) {
      output.writeFieldBegin('serialNumber', Thrift.Type.STRING, 1);
      output.writeString(this.serialNumber);
      output.writeFieldEnd();
    }
    if (this.issuerDN !== null && this.issuerDN !== undefined) {
      output.writeFieldBegin('issuerDN', Thrift.Type.STRING, 2);
      output.writeString(this.issuerDN);
      output.writeFieldEnd();
    }
    if (this.subjectDN !== null && this.subjectDN !== undefined) {
      output.writeFieldBegin('subjectDN', Thrift.Type.STRING, 3);
      output.writeString(this.subjectDN);
      output.writeFieldEnd();
    }
    if (this.signDate !== null && this.signDate !== undefined) {
      output.writeFieldBegin('signDate', Thrift.Type.I64, 4);
      output.writeI64(this.signDate);
      output.writeFieldEnd();
    }
    if (this.beforeDate !== null && this.beforeDate !== undefined) {
      output.writeFieldBegin('beforeDate', Thrift.Type.I64, 5);
      output.writeI64(this.beforeDate);
      output.writeFieldEnd();
    }
    if (this.afterDate !== null && this.afterDate !== undefined) {
      output.writeFieldBegin('afterDate', Thrift.Type.I64, 6);
      output.writeI64(this.afterDate);
      output.writeFieldEnd();
    }
    if (this.signature !== null && this.signature !== undefined) {
      output.writeFieldBegin('signature', Thrift.Type.STRING, 7);
      output.writeString(this.signature);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
//
// Autogenerated by Thrift Compiler (0.13.0)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//
if (typeof Int64 === 'undefined' && typeof require === 'function') {
  const Int64 = require('node-int64');
}


MrkContactType = {
  'EMAIL' : 0,
  'PHONE' : 1
};
MrkDocumentType = {
  'DRAFT' : 0,
  'INPUT' : 1,
  'OUTPUT' : 2
};
MrkHistoryKey = {
  'CLIENT_LOGIN' : 0,
  'CLIENT_CREATED' : 1,
  'ACCOUNT_CHANGED' : 2,
  'ACCOUNT_CREATED' : 3,
  'ORGANIZATION_CREATED' : 4,
  'DOCUMENT_UPDATE' : 5,
  'DOCUMENT_CREATE' : 6,
  'DOCUMENT_VIEW' : 7,
  'ATTACHMENT_CREATED' : 8,
  'USER_REMOVED' : 9,
  'USER_CHANGED' : 10
};
MrkContactInfo = class {
  constructor(args) {
    this.id = null;
    this.createDate = null;
    this.cType = null;
    this.cValue = null;
    this.verified = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.createDate !== undefined && args.createDate !== null) {
        this.createDate = args.createDate;
      }
      if (args.cType !== undefined && args.cType !== null) {
        this.cType = args.cType;
      }
      if (args.cValue !== undefined && args.cValue !== null) {
        this.cValue = args.cValue;
      }
      if (args.verified !== undefined && args.verified !== null) {
        this.verified = args.verified;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I64) {
          this.createDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I32) {
          this.cType = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.cValue = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.BOOL) {
          this.verified = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('MrkContactInfo');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.createDate !== null && this.createDate !== undefined) {
      output.writeFieldBegin('createDate', Thrift.Type.I64, 2);
      output.writeI64(this.createDate);
      output.writeFieldEnd();
    }
    if (this.cType !== null && this.cType !== undefined) {
      output.writeFieldBegin('cType', Thrift.Type.I32, 3);
      output.writeI32(this.cType);
      output.writeFieldEnd();
    }
    if (this.cValue !== null && this.cValue !== undefined) {
      output.writeFieldBegin('cValue', Thrift.Type.STRING, 4);
      output.writeString(this.cValue);
      output.writeFieldEnd();
    }
    if (this.verified !== null && this.verified !== undefined) {
      output.writeFieldBegin('verified', Thrift.Type.BOOL, 5);
      output.writeBool(this.verified);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
MrkClient = class {
  constructor(args) {
    this.id = null;
    this.createDate = null;
    this.deleteDate = null;
    this.login = null;
    this.firstName = null;
    this.lastName = null;
    this.middleName = null;
    this.position = null;
    this.contacts = null;
    this.inn = null;
    this.birthDate = null;
    this.chief = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.createDate !== undefined && args.createDate !== null) {
        this.createDate = args.createDate;
      }
      if (args.deleteDate !== undefined && args.deleteDate !== null) {
        this.deleteDate = args.deleteDate;
      }
      if (args.login !== undefined && args.login !== null) {
        this.login = args.login;
      }
      if (args.firstName !== undefined && args.firstName !== null) {
        this.firstName = args.firstName;
      }
      if (args.lastName !== undefined && args.lastName !== null) {
        this.lastName = args.lastName;
      }
      if (args.middleName !== undefined && args.middleName !== null) {
        this.middleName = args.middleName;
      }
      if (args.position !== undefined && args.position !== null) {
        this.position = args.position;
      }
      if (args.contacts !== undefined && args.contacts !== null) {
        this.contacts = Thrift.copyList(args.contacts, [MrkContactInfo]);
      }
      if (args.inn !== undefined && args.inn !== null) {
        this.inn = args.inn;
      }
      if (args.birthDate !== undefined && args.birthDate !== null) {
        this.birthDate = args.birthDate;
      }
      if (args.chief !== undefined && args.chief !== null) {
        this.chief = args.chief;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I64) {
          this.createDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I64) {
          this.deleteDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.login = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRING) {
          this.firstName = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.STRING) {
          this.lastName = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.STRING) {
          this.middleName = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.STRING) {
          this.position = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 9:
        if (ftype == Thrift.Type.LIST) {
          this.contacts = [];
          const _rtmp31 = input.readListBegin();
          const _size0 = _rtmp31.size || 0;
          for (let _i2 = 0; _i2 < _size0; ++_i2) {
            let elem3 = null;
            elem3 = new MrkContactInfo();
            elem3.read(input);
            this.contacts.push(elem3);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 10:
        if (ftype == Thrift.Type.STRING) {
          this.inn = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 11:
        if (ftype == Thrift.Type.I64) {
          this.birthDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 12:
        if (ftype == Thrift.Type.BOOL) {
          this.chief = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('MrkClient');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.createDate !== null && this.createDate !== undefined) {
      output.writeFieldBegin('createDate', Thrift.Type.I64, 2);
      output.writeI64(this.createDate);
      output.writeFieldEnd();
    }
    if (this.deleteDate !== null && this.deleteDate !== undefined) {
      output.writeFieldBegin('deleteDate', Thrift.Type.I64, 3);
      output.writeI64(this.deleteDate);
      output.writeFieldEnd();
    }
    if (this.login !== null && this.login !== undefined) {
      output.writeFieldBegin('login', Thrift.Type.STRING, 4);
      output.writeString(this.login);
      output.writeFieldEnd();
    }
    if (this.firstName !== null && this.firstName !== undefined) {
      output.writeFieldBegin('firstName', Thrift.Type.STRING, 5);
      output.writeString(this.firstName);
      output.writeFieldEnd();
    }
    if (this.lastName !== null && this.lastName !== undefined) {
      output.writeFieldBegin('lastName', Thrift.Type.STRING, 6);
      output.writeString(this.lastName);
      output.writeFieldEnd();
    }
    if (this.middleName !== null && this.middleName !== undefined) {
      output.writeFieldBegin('middleName', Thrift.Type.STRING, 7);
      output.writeString(this.middleName);
      output.writeFieldEnd();
    }
    if (this.position !== null && this.position !== undefined) {
      output.writeFieldBegin('position', Thrift.Type.STRING, 8);
      output.writeString(this.position);
      output.writeFieldEnd();
    }
    if (this.contacts !== null && this.contacts !== undefined) {
      output.writeFieldBegin('contacts', Thrift.Type.LIST, 9);
      output.writeListBegin(Thrift.Type.STRUCT, this.contacts.length);
      for (let iter4 in this.contacts) {
        if (this.contacts.hasOwnProperty(iter4)) {
          iter4 = this.contacts[iter4];
          iter4.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.inn !== null && this.inn !== undefined) {
      output.writeFieldBegin('inn', Thrift.Type.STRING, 10);
      output.writeString(this.inn);
      output.writeFieldEnd();
    }
    if (this.birthDate !== null && this.birthDate !== undefined) {
      output.writeFieldBegin('birthDate', Thrift.Type.I64, 11);
      output.writeI64(this.birthDate);
      output.writeFieldEnd();
    }
    if (this.chief !== null && this.chief !== undefined) {
      output.writeFieldBegin('chief', Thrift.Type.BOOL, 12);
      output.writeBool(this.chief);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
MrkOrganization = class {
  constructor(args) {
    this.id = null;
    this.createDate = null;
    this.name = null;
    this.edrpo = null;
    this.adress = null;
    this.regAdress = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.createDate !== undefined && args.createDate !== null) {
        this.createDate = args.createDate;
      }
      if (args.name !== undefined && args.name !== null) {
        this.name = args.name;
      }
      if (args.edrpo !== undefined && args.edrpo !== null) {
        this.edrpo = args.edrpo;
      }
      if (args.adress !== undefined && args.adress !== null) {
        this.adress = args.adress;
      }
      if (args.regAdress !== undefined && args.regAdress !== null) {
        this.regAdress = args.regAdress;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I64) {
          this.createDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.name = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.edrpo = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRING) {
          this.adress = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.STRING) {
          this.regAdress = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('MrkOrganization');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.createDate !== null && this.createDate !== undefined) {
      output.writeFieldBegin('createDate', Thrift.Type.I64, 2);
      output.writeI64(this.createDate);
      output.writeFieldEnd();
    }
    if (this.name !== null && this.name !== undefined) {
      output.writeFieldBegin('name', Thrift.Type.STRING, 3);
      output.writeString(this.name);
      output.writeFieldEnd();
    }
    if (this.edrpo !== null && this.edrpo !== undefined) {
      output.writeFieldBegin('edrpo', Thrift.Type.STRING, 4);
      output.writeString(this.edrpo);
      output.writeFieldEnd();
    }
    if (this.adress !== null && this.adress !== undefined) {
      output.writeFieldBegin('adress', Thrift.Type.STRING, 5);
      output.writeString(this.adress);
      output.writeFieldEnd();
    }
    if (this.regAdress !== null && this.regAdress !== undefined) {
      output.writeFieldBegin('regAdress', Thrift.Type.STRING, 6);
      output.writeString(this.regAdress);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
MrkAccount = class {
  constructor(args) {
    this.id = null;
    this.clientList = null;
    this.organization = null;
    this.confirmed = null;
    this.contragent = null;
    this.blocked = null;
    this.signed = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.clientList !== undefined && args.clientList !== null) {
        this.clientList = Thrift.copyList(args.clientList, [MrkClient]);
      }
      if (args.organization !== undefined && args.organization !== null) {
        this.organization = new MrkOrganization(args.organization);
      }
      if (args.confirmed !== undefined && args.confirmed !== null) {
        this.confirmed = args.confirmed;
      }
      if (args.contragent !== undefined && args.contragent !== null) {
        this.contragent = args.contragent;
      }
      if (args.blocked !== undefined && args.blocked !== null) {
        this.blocked = args.blocked;
      }
      if (args.signed !== undefined && args.signed !== null) {
        this.signed = args.signed;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.LIST) {
          this.clientList = [];
          const _rtmp36 = input.readListBegin();
          const _size5 = _rtmp36.size || 0;
          for (let _i7 = 0; _i7 < _size5; ++_i7) {
            let elem8 = null;
            elem8 = new MrkClient();
            elem8.read(input);
            this.clientList.push(elem8);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.organization = new MrkOrganization();
          this.organization.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.BOOL) {
          this.confirmed = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.BOOL) {
          this.contragent = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.BOOL) {
          this.blocked = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.BOOL) {
          this.signed = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('MrkAccount');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.clientList !== null && this.clientList !== undefined) {
      output.writeFieldBegin('clientList', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.STRUCT, this.clientList.length);
      for (let iter9 in this.clientList) {
        if (this.clientList.hasOwnProperty(iter9)) {
          iter9 = this.clientList[iter9];
          iter9.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.organization !== null && this.organization !== undefined) {
      output.writeFieldBegin('organization', Thrift.Type.STRUCT, 3);
      this.organization.write(output);
      output.writeFieldEnd();
    }
    if (this.confirmed !== null && this.confirmed !== undefined) {
      output.writeFieldBegin('confirmed', Thrift.Type.BOOL, 4);
      output.writeBool(this.confirmed);
      output.writeFieldEnd();
    }
    if (this.contragent !== null && this.contragent !== undefined) {
      output.writeFieldBegin('contragent', Thrift.Type.BOOL, 5);
      output.writeBool(this.contragent);
      output.writeFieldEnd();
    }
    if (this.blocked !== null && this.blocked !== undefined) {
      output.writeFieldBegin('blocked', Thrift.Type.BOOL, 6);
      output.writeBool(this.blocked);
      output.writeFieldEnd();
    }
    if (this.signed !== null && this.signed !== undefined) {
      output.writeFieldBegin('signed', Thrift.Type.BOOL, 7);
      output.writeBool(this.signed);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
MrkClientSession = class {
  constructor(args) {
    this.id = null;
    this.createDate = null;
    this.client = null;
    this.organization = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.createDate !== undefined && args.createDate !== null) {
        this.createDate = args.createDate;
      }
      if (args.client !== undefined && args.client !== null) {
        this.client = new MrkClient(args.client);
      }
      if (args.organization !== undefined && args.organization !== null) {
        this.organization = new MrkOrganization(args.organization);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I64) {
          this.createDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.client = new MrkClient();
          this.client.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.organization = new MrkOrganization();
          this.organization.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('MrkClientSession');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.createDate !== null && this.createDate !== undefined) {
      output.writeFieldBegin('createDate', Thrift.Type.I64, 2);
      output.writeI64(this.createDate);
      output.writeFieldEnd();
    }
    if (this.client !== null && this.client !== undefined) {
      output.writeFieldBegin('client', Thrift.Type.STRUCT, 3);
      this.client.write(output);
      output.writeFieldEnd();
    }
    if (this.organization !== null && this.organization !== undefined) {
      output.writeFieldBegin('organization', Thrift.Type.STRUCT, 4);
      this.organization.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
MrkUser = class {
  constructor(args) {
    this.id = null;
    this.createDate = null;
    this.deleteDate = null;
    this.login = null;
    this.firstName = null;
    this.lastName = null;
    this.middleName = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.createDate !== undefined && args.createDate !== null) {
        this.createDate = args.createDate;
      }
      if (args.deleteDate !== undefined && args.deleteDate !== null) {
        this.deleteDate = args.deleteDate;
      }
      if (args.login !== undefined && args.login !== null) {
        this.login = args.login;
      }
      if (args.firstName !== undefined && args.firstName !== null) {
        this.firstName = args.firstName;
      }
      if (args.lastName !== undefined && args.lastName !== null) {
        this.lastName = args.lastName;
      }
      if (args.middleName !== undefined && args.middleName !== null) {
        this.middleName = args.middleName;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I64) {
          this.createDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I64) {
          this.deleteDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.login = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRING) {
          this.firstName = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.STRING) {
          this.lastName = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.STRING) {
          this.middleName = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('MrkUser');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.createDate !== null && this.createDate !== undefined) {
      output.writeFieldBegin('createDate', Thrift.Type.I64, 2);
      output.writeI64(this.createDate);
      output.writeFieldEnd();
    }
    if (this.deleteDate !== null && this.deleteDate !== undefined) {
      output.writeFieldBegin('deleteDate', Thrift.Type.I64, 3);
      output.writeI64(this.deleteDate);
      output.writeFieldEnd();
    }
    if (this.login !== null && this.login !== undefined) {
      output.writeFieldBegin('login', Thrift.Type.STRING, 4);
      output.writeString(this.login);
      output.writeFieldEnd();
    }
    if (this.firstName !== null && this.firstName !== undefined) {
      output.writeFieldBegin('firstName', Thrift.Type.STRING, 5);
      output.writeString(this.firstName);
      output.writeFieldEnd();
    }
    if (this.lastName !== null && this.lastName !== undefined) {
      output.writeFieldBegin('lastName', Thrift.Type.STRING, 6);
      output.writeString(this.lastName);
      output.writeFieldEnd();
    }
    if (this.middleName !== null && this.middleName !== undefined) {
      output.writeFieldBegin('middleName', Thrift.Type.STRING, 7);
      output.writeString(this.middleName);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
MrkUserPage = class {
  constructor(args) {
    this.users = null;
    this.count = null;
    if (args) {
      if (args.users !== undefined && args.users !== null) {
        this.users = Thrift.copyList(args.users, [MrkUser]);
      }
      if (args.count !== undefined && args.count !== null) {
        this.count = args.count;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.LIST) {
          this.users = [];
          const _rtmp311 = input.readListBegin();
          const _size10 = _rtmp311.size || 0;
          for (let _i12 = 0; _i12 < _size10; ++_i12) {
            let elem13 = null;
            elem13 = new MrkUser();
            elem13.read(input);
            this.users.push(elem13);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.count = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('MrkUserPage');
    if (this.users !== null && this.users !== undefined) {
      output.writeFieldBegin('users', Thrift.Type.LIST, 1);
      output.writeListBegin(Thrift.Type.STRUCT, this.users.length);
      for (let iter14 in this.users) {
        if (this.users.hasOwnProperty(iter14)) {
          iter14 = this.users[iter14];
          iter14.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.count !== null && this.count !== undefined) {
      output.writeFieldBegin('count', Thrift.Type.I32, 2);
      output.writeI32(this.count);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
MrkUserSession = class {
  constructor(args) {
    this.id = null;
    this.createDate = null;
    this.user = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.createDate !== undefined && args.createDate !== null) {
        this.createDate = args.createDate;
      }
      if (args.user !== undefined && args.user !== null) {
        this.user = new MrkUser(args.user);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I64) {
          this.createDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.user = new MrkUser();
          this.user.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('MrkUserSession');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.createDate !== null && this.createDate !== undefined) {
      output.writeFieldBegin('createDate', Thrift.Type.I64, 2);
      output.writeI64(this.createDate);
      output.writeFieldEnd();
    }
    if (this.user !== null && this.user !== undefined) {
      output.writeFieldBegin('user', Thrift.Type.STRUCT, 3);
      this.user.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
MrkDocument = class {
  constructor(args) {
    this.id = null;
    this.extId = null;
    this.accountId = null;
    this.patternId = null;
    this.patternName = null;
    this.name = null;
    this.type = null;
    this.createDate = null;
    this.parentId = null;
    this.viewed = null;
    this.sendDate = null;
    this.receiveDate = null;
    this.creatorId = null;
    this.groupNumber = null;
    this.signInSystem = null;
    this.extCameFrom = null;
    this.extNumber = null;
    this.extAuthorName = null;
    this.extAuthorEmail = null;
    this.extRespExecId = null;
    this.extRespPatternId = null;
    this.extRespReq = null;
    this.hasAttachments = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.extId !== undefined && args.extId !== null) {
        this.extId = args.extId;
      }
      if (args.accountId !== undefined && args.accountId !== null) {
        this.accountId = args.accountId;
      }
      if (args.patternId !== undefined && args.patternId !== null) {
        this.patternId = args.patternId;
      }
      if (args.patternName !== undefined && args.patternName !== null) {
        this.patternName = args.patternName;
      }
      if (args.name !== undefined && args.name !== null) {
        this.name = args.name;
      }
      if (args.type !== undefined && args.type !== null) {
        this.type = args.type;
      }
      if (args.createDate !== undefined && args.createDate !== null) {
        this.createDate = args.createDate;
      }
      if (args.parentId !== undefined && args.parentId !== null) {
        this.parentId = args.parentId;
      }
      if (args.viewed !== undefined && args.viewed !== null) {
        this.viewed = args.viewed;
      }
      if (args.sendDate !== undefined && args.sendDate !== null) {
        this.sendDate = args.sendDate;
      }
      if (args.receiveDate !== undefined && args.receiveDate !== null) {
        this.receiveDate = args.receiveDate;
      }
      if (args.creatorId !== undefined && args.creatorId !== null) {
        this.creatorId = args.creatorId;
      }
      if (args.groupNumber !== undefined && args.groupNumber !== null) {
        this.groupNumber = args.groupNumber;
      }
      if (args.signInSystem !== undefined && args.signInSystem !== null) {
        this.signInSystem = args.signInSystem;
      }
      if (args.extCameFrom !== undefined && args.extCameFrom !== null) {
        this.extCameFrom = args.extCameFrom;
      }
      if (args.extNumber !== undefined && args.extNumber !== null) {
        this.extNumber = args.extNumber;
      }
      if (args.extAuthorName !== undefined && args.extAuthorName !== null) {
        this.extAuthorName = args.extAuthorName;
      }
      if (args.extAuthorEmail !== undefined && args.extAuthorEmail !== null) {
        this.extAuthorEmail = args.extAuthorEmail;
      }
      if (args.extRespExecId !== undefined && args.extRespExecId !== null) {
        this.extRespExecId = args.extRespExecId;
      }
      if (args.extRespPatternId !== undefined && args.extRespPatternId !== null) {
        this.extRespPatternId = args.extRespPatternId;
      }
      if (args.extRespReq !== undefined && args.extRespReq !== null) {
        this.extRespReq = args.extRespReq;
      }
      if (args.hasAttachments !== undefined && args.hasAttachments !== null) {
        this.hasAttachments = args.hasAttachments;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.extId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.accountId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.patternId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRING) {
          this.patternName = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.STRING) {
          this.name = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.I32) {
          this.type = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.I64) {
          this.createDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 9:
        if (ftype == Thrift.Type.STRING) {
          this.parentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 10:
        if (ftype == Thrift.Type.BOOL) {
          this.viewed = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 11:
        if (ftype == Thrift.Type.I64) {
          this.sendDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 12:
        if (ftype == Thrift.Type.I64) {
          this.receiveDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 13:
        if (ftype == Thrift.Type.STRING) {
          this.creatorId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 14:
        if (ftype == Thrift.Type.STRING) {
          this.groupNumber = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 15:
        if (ftype == Thrift.Type.I32) {
          this.signInSystem = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 16:
        if (ftype == Thrift.Type.STRING) {
          this.extCameFrom = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 17:
        if (ftype == Thrift.Type.STRING) {
          this.extNumber = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 18:
        if (ftype == Thrift.Type.STRING) {
          this.extAuthorName = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 19:
        if (ftype == Thrift.Type.STRING) {
          this.extAuthorEmail = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 20:
        if (ftype == Thrift.Type.STRING) {
          this.extRespExecId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 21:
        if (ftype == Thrift.Type.STRING) {
          this.extRespPatternId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 22:
        if (ftype == Thrift.Type.I32) {
          this.extRespReq = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 23:
        if (ftype == Thrift.Type.BOOL) {
          this.hasAttachments = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('MrkDocument');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.extId !== null && this.extId !== undefined) {
      output.writeFieldBegin('extId', Thrift.Type.STRING, 2);
      output.writeString(this.extId);
      output.writeFieldEnd();
    }
    if (this.accountId !== null && this.accountId !== undefined) {
      output.writeFieldBegin('accountId', Thrift.Type.STRING, 3);
      output.writeString(this.accountId);
      output.writeFieldEnd();
    }
    if (this.patternId !== null && this.patternId !== undefined) {
      output.writeFieldBegin('patternId', Thrift.Type.STRING, 4);
      output.writeString(this.patternId);
      output.writeFieldEnd();
    }
    if (this.patternName !== null && this.patternName !== undefined) {
      output.writeFieldBegin('patternName', Thrift.Type.STRING, 5);
      output.writeString(this.patternName);
      output.writeFieldEnd();
    }
    if (this.name !== null && this.name !== undefined) {
      output.writeFieldBegin('name', Thrift.Type.STRING, 6);
      output.writeString(this.name);
      output.writeFieldEnd();
    }
    if (this.type !== null && this.type !== undefined) {
      output.writeFieldBegin('type', Thrift.Type.I32, 7);
      output.writeI32(this.type);
      output.writeFieldEnd();
    }
    if (this.createDate !== null && this.createDate !== undefined) {
      output.writeFieldBegin('createDate', Thrift.Type.I64, 8);
      output.writeI64(this.createDate);
      output.writeFieldEnd();
    }
    if (this.parentId !== null && this.parentId !== undefined) {
      output.writeFieldBegin('parentId', Thrift.Type.STRING, 9);
      output.writeString(this.parentId);
      output.writeFieldEnd();
    }
    if (this.viewed !== null && this.viewed !== undefined) {
      output.writeFieldBegin('viewed', Thrift.Type.BOOL, 10);
      output.writeBool(this.viewed);
      output.writeFieldEnd();
    }
    if (this.sendDate !== null && this.sendDate !== undefined) {
      output.writeFieldBegin('sendDate', Thrift.Type.I64, 11);
      output.writeI64(this.sendDate);
      output.writeFieldEnd();
    }
    if (this.receiveDate !== null && this.receiveDate !== undefined) {
      output.writeFieldBegin('receiveDate', Thrift.Type.I64, 12);
      output.writeI64(this.receiveDate);
      output.writeFieldEnd();
    }
    if (this.creatorId !== null && this.creatorId !== undefined) {
      output.writeFieldBegin('creatorId', Thrift.Type.STRING, 13);
      output.writeString(this.creatorId);
      output.writeFieldEnd();
    }
    if (this.groupNumber !== null && this.groupNumber !== undefined) {
      output.writeFieldBegin('groupNumber', Thrift.Type.STRING, 14);
      output.writeString(this.groupNumber);
      output.writeFieldEnd();
    }
    if (this.signInSystem !== null && this.signInSystem !== undefined) {
      output.writeFieldBegin('signInSystem', Thrift.Type.I32, 15);
      output.writeI32(this.signInSystem);
      output.writeFieldEnd();
    }
    if (this.extCameFrom !== null && this.extCameFrom !== undefined) {
      output.writeFieldBegin('extCameFrom', Thrift.Type.STRING, 16);
      output.writeString(this.extCameFrom);
      output.writeFieldEnd();
    }
    if (this.extNumber !== null && this.extNumber !== undefined) {
      output.writeFieldBegin('extNumber', Thrift.Type.STRING, 17);
      output.writeString(this.extNumber);
      output.writeFieldEnd();
    }
    if (this.extAuthorName !== null && this.extAuthorName !== undefined) {
      output.writeFieldBegin('extAuthorName', Thrift.Type.STRING, 18);
      output.writeString(this.extAuthorName);
      output.writeFieldEnd();
    }
    if (this.extAuthorEmail !== null && this.extAuthorEmail !== undefined) {
      output.writeFieldBegin('extAuthorEmail', Thrift.Type.STRING, 19);
      output.writeString(this.extAuthorEmail);
      output.writeFieldEnd();
    }
    if (this.extRespExecId !== null && this.extRespExecId !== undefined) {
      output.writeFieldBegin('extRespExecId', Thrift.Type.STRING, 20);
      output.writeString(this.extRespExecId);
      output.writeFieldEnd();
    }
    if (this.extRespPatternId !== null && this.extRespPatternId !== undefined) {
      output.writeFieldBegin('extRespPatternId', Thrift.Type.STRING, 21);
      output.writeString(this.extRespPatternId);
      output.writeFieldEnd();
    }
    if (this.extRespReq !== null && this.extRespReq !== undefined) {
      output.writeFieldBegin('extRespReq', Thrift.Type.I32, 22);
      output.writeI32(this.extRespReq);
      output.writeFieldEnd();
    }
    if (this.hasAttachments !== null && this.hasAttachments !== undefined) {
      output.writeFieldBegin('hasAttachments', Thrift.Type.BOOL, 23);
      output.writeBool(this.hasAttachments);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
MrkDocumentPage = class {
  constructor(args) {
    this.documentData = null;
    this.count = null;
    if (args) {
      if (args.documentData !== undefined && args.documentData !== null) {
        this.documentData = Thrift.copyList(args.documentData, [MrkDocument]);
      }
      if (args.count !== undefined && args.count !== null) {
        this.count = args.count;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.LIST) {
          this.documentData = [];
          const _rtmp316 = input.readListBegin();
          const _size15 = _rtmp316.size || 0;
          for (let _i17 = 0; _i17 < _size15; ++_i17) {
            let elem18 = null;
            elem18 = new MrkDocument();
            elem18.read(input);
            this.documentData.push(elem18);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.count = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('MrkDocumentPage');
    if (this.documentData !== null && this.documentData !== undefined) {
      output.writeFieldBegin('documentData', Thrift.Type.LIST, 1);
      output.writeListBegin(Thrift.Type.STRUCT, this.documentData.length);
      for (let iter19 in this.documentData) {
        if (this.documentData.hasOwnProperty(iter19)) {
          iter19 = this.documentData[iter19];
          iter19.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.count !== null && this.count !== undefined) {
      output.writeFieldBegin('count', Thrift.Type.I32, 2);
      output.writeI32(this.count);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
MrkAttachment = class {
  constructor(args) {
    this.id = null;
    this.fileName = null;
    this.account = null;
    this.creator = null;
    this.createDate = null;
    this.fSize = null;
    this.attHash = null;
    this.status = null;
    this.fType = null;
    this.hasDigitalSign = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.fileName !== undefined && args.fileName !== null) {
        this.fileName = args.fileName;
      }
      if (args.account !== undefined && args.account !== null) {
        this.account = new MrkAccount(args.account);
      }
      if (args.creator !== undefined && args.creator !== null) {
        this.creator = new MrkClient(args.creator);
      }
      if (args.createDate !== undefined && args.createDate !== null) {
        this.createDate = args.createDate;
      }
      if (args.fSize !== undefined && args.fSize !== null) {
        this.fSize = args.fSize;
      }
      if (args.attHash !== undefined && args.attHash !== null) {
        this.attHash = args.attHash;
      }
      if (args.status !== undefined && args.status !== null) {
        this.status = args.status;
      }
      if (args.fType !== undefined && args.fType !== null) {
        this.fType = args.fType;
      }
      if (args.hasDigitalSign !== undefined && args.hasDigitalSign !== null) {
        this.hasDigitalSign = args.hasDigitalSign;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.fileName = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.account = new MrkAccount();
          this.account.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.creator = new MrkClient();
          this.creator.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.I64) {
          this.createDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.I64) {
          this.fSize = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.STRING) {
          this.attHash = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.I32) {
          this.status = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 9:
        if (ftype == Thrift.Type.I32) {
          this.fType = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 10:
        if (ftype == Thrift.Type.BOOL) {
          this.hasDigitalSign = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('MrkAttachment');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.fileName !== null && this.fileName !== undefined) {
      output.writeFieldBegin('fileName', Thrift.Type.STRING, 2);
      output.writeString(this.fileName);
      output.writeFieldEnd();
    }
    if (this.account !== null && this.account !== undefined) {
      output.writeFieldBegin('account', Thrift.Type.STRUCT, 3);
      this.account.write(output);
      output.writeFieldEnd();
    }
    if (this.creator !== null && this.creator !== undefined) {
      output.writeFieldBegin('creator', Thrift.Type.STRUCT, 4);
      this.creator.write(output);
      output.writeFieldEnd();
    }
    if (this.createDate !== null && this.createDate !== undefined) {
      output.writeFieldBegin('createDate', Thrift.Type.I64, 5);
      output.writeI64(this.createDate);
      output.writeFieldEnd();
    }
    if (this.fSize !== null && this.fSize !== undefined) {
      output.writeFieldBegin('fSize', Thrift.Type.I64, 6);
      output.writeI64(this.fSize);
      output.writeFieldEnd();
    }
    if (this.attHash !== null && this.attHash !== undefined) {
      output.writeFieldBegin('attHash', Thrift.Type.STRING, 7);
      output.writeString(this.attHash);
      output.writeFieldEnd();
    }
    if (this.status !== null && this.status !== undefined) {
      output.writeFieldBegin('status', Thrift.Type.I32, 8);
      output.writeI32(this.status);
      output.writeFieldEnd();
    }
    if (this.fType !== null && this.fType !== undefined) {
      output.writeFieldBegin('fType', Thrift.Type.I32, 9);
      output.writeI32(this.fType);
      output.writeFieldEnd();
    }
    if (this.hasDigitalSign !== null && this.hasDigitalSign !== undefined) {
      output.writeFieldBegin('hasDigitalSign', Thrift.Type.BOOL, 10);
      output.writeBool(this.hasDigitalSign);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
MrkDocumentData = class {
  constructor(args) {
    this.document = null;
    this.items = null;
    this.atts = null;
    if (args) {
      if (args.document !== undefined && args.document !== null) {
        this.document = new MrkDocument(args.document);
      }
      if (args.items !== undefined && args.items !== null) {
        this.items = Thrift.copyList(args.items, [ContentItem]);
      }
      if (args.atts !== undefined && args.atts !== null) {
        this.atts = Thrift.copyList(args.atts, [MrkAttachment]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.document = new MrkDocument();
          this.document.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.LIST) {
          this.items = [];
          const _rtmp321 = input.readListBegin();
          const _size20 = _rtmp321.size || 0;
          for (let _i22 = 0; _i22 < _size20; ++_i22) {
            let elem23 = null;
            elem23 = new ContentItem();
            elem23.read(input);
            this.items.push(elem23);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.atts = [];
          const _rtmp325 = input.readListBegin();
          const _size24 = _rtmp325.size || 0;
          for (let _i26 = 0; _i26 < _size24; ++_i26) {
            let elem27 = null;
            elem27 = new MrkAttachment();
            elem27.read(input);
            this.atts.push(elem27);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('MrkDocumentData');
    if (this.document !== null && this.document !== undefined) {
      output.writeFieldBegin('document', Thrift.Type.STRUCT, 1);
      this.document.write(output);
      output.writeFieldEnd();
    }
    if (this.items !== null && this.items !== undefined) {
      output.writeFieldBegin('items', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.STRUCT, this.items.length);
      for (let iter28 in this.items) {
        if (this.items.hasOwnProperty(iter28)) {
          iter28 = this.items[iter28];
          iter28.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.atts !== null && this.atts !== undefined) {
      output.writeFieldBegin('atts', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRUCT, this.atts.length);
      for (let iter29 in this.atts) {
        if (this.atts.hasOwnProperty(iter29)) {
          iter29 = this.atts[iter29];
          iter29.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
MrkHistory = class {
  constructor(args) {
    this.id = null;
    this.createDate = null;
    this.accountId = null;
    this.key = null;
    this.clientId = null;
    this.userId = null;
    this.documentId = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.createDate !== undefined && args.createDate !== null) {
        this.createDate = args.createDate;
      }
      if (args.accountId !== undefined && args.accountId !== null) {
        this.accountId = args.accountId;
      }
      if (args.key !== undefined && args.key !== null) {
        this.key = args.key;
      }
      if (args.clientId !== undefined && args.clientId !== null) {
        this.clientId = args.clientId;
      }
      if (args.userId !== undefined && args.userId !== null) {
        this.userId = args.userId;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I64) {
          this.createDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.accountId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I32) {
          this.key = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRING) {
          this.clientId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.STRING) {
          this.userId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('MrkHistory');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.createDate !== null && this.createDate !== undefined) {
      output.writeFieldBegin('createDate', Thrift.Type.I64, 2);
      output.writeI64(this.createDate);
      output.writeFieldEnd();
    }
    if (this.accountId !== null && this.accountId !== undefined) {
      output.writeFieldBegin('accountId', Thrift.Type.STRING, 3);
      output.writeString(this.accountId);
      output.writeFieldEnd();
    }
    if (this.key !== null && this.key !== undefined) {
      output.writeFieldBegin('key', Thrift.Type.I32, 4);
      output.writeI32(this.key);
      output.writeFieldEnd();
    }
    if (this.clientId !== null && this.clientId !== undefined) {
      output.writeFieldBegin('clientId', Thrift.Type.STRING, 5);
      output.writeString(this.clientId);
      output.writeFieldEnd();
    }
    if (this.userId !== null && this.userId !== undefined) {
      output.writeFieldBegin('userId', Thrift.Type.STRING, 6);
      output.writeString(this.userId);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 7);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
MrkAlmexSysUser = class {
  constructor(args) {
    this.login = null;
    this.confirmed = null;
    this.contragent = null;
    if (args) {
      if (args.login !== undefined && args.login !== null) {
        this.login = args.login;
      }
      if (args.confirmed !== undefined && args.confirmed !== null) {
        this.confirmed = args.confirmed;
      }
      if (args.contragent !== undefined && args.contragent !== null) {
        this.contragent = args.contragent;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.login = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.BOOL) {
          this.confirmed = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.BOOL) {
          this.contragent = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('MrkAlmexSysUser');
    if (this.login !== null && this.login !== undefined) {
      output.writeFieldBegin('login', Thrift.Type.STRING, 1);
      output.writeString(this.login);
      output.writeFieldEnd();
    }
    if (this.confirmed !== null && this.confirmed !== undefined) {
      output.writeFieldBegin('confirmed', Thrift.Type.BOOL, 2);
      output.writeBool(this.confirmed);
      output.writeFieldEnd();
    }
    if (this.contragent !== null && this.contragent !== undefined) {
      output.writeFieldBegin('contragent', Thrift.Type.BOOL, 3);
      output.writeBool(this.contragent);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
MrkHistoryPage = class {
  constructor(args) {
    this.historyData = null;
    this.count = null;
    if (args) {
      if (args.historyData !== undefined && args.historyData !== null) {
        this.historyData = Thrift.copyList(args.historyData, [MrkHistory]);
      }
      if (args.count !== undefined && args.count !== null) {
        this.count = args.count;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.LIST) {
          this.historyData = [];
          const _rtmp331 = input.readListBegin();
          const _size30 = _rtmp331.size || 0;
          for (let _i32 = 0; _i32 < _size30; ++_i32) {
            let elem33 = null;
            elem33 = new MrkHistory();
            elem33.read(input);
            this.historyData.push(elem33);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.count = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('MrkHistoryPage');
    if (this.historyData !== null && this.historyData !== undefined) {
      output.writeFieldBegin('historyData', Thrift.Type.LIST, 1);
      output.writeListBegin(Thrift.Type.STRUCT, this.historyData.length);
      for (let iter34 in this.historyData) {
        if (this.historyData.hasOwnProperty(iter34)) {
          iter34 = this.historyData[iter34];
          iter34.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.count !== null && this.count !== undefined) {
      output.writeFieldBegin('count', Thrift.Type.I32, 2);
      output.writeI32(this.count);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
MrkAlmexSysUserPage = class {
  constructor(args) {
    this.almexUsersData = null;
    this.count = null;
    if (args) {
      if (args.almexUsersData !== undefined && args.almexUsersData !== null) {
        this.almexUsersData = Thrift.copyList(args.almexUsersData, [MrkAlmexSysUser]);
      }
      if (args.count !== undefined && args.count !== null) {
        this.count = args.count;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.LIST) {
          this.almexUsersData = [];
          const _rtmp336 = input.readListBegin();
          const _size35 = _rtmp336.size || 0;
          for (let _i37 = 0; _i37 < _size35; ++_i37) {
            let elem38 = null;
            elem38 = new MrkAlmexSysUser();
            elem38.read(input);
            this.almexUsersData.push(elem38);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.count = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('MrkAlmexSysUserPage');
    if (this.almexUsersData !== null && this.almexUsersData !== undefined) {
      output.writeFieldBegin('almexUsersData', Thrift.Type.LIST, 1);
      output.writeListBegin(Thrift.Type.STRUCT, this.almexUsersData.length);
      for (let iter39 in this.almexUsersData) {
        if (this.almexUsersData.hasOwnProperty(iter39)) {
          iter39 = this.almexUsersData[iter39];
          iter39.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.count !== null && this.count !== undefined) {
      output.writeFieldBegin('count', Thrift.Type.I32, 2);
      output.writeI32(this.count);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
MRK_CURRENT_VERSION = 'mrk-1.0.1';
//
// Autogenerated by Thrift Compiler (0.13.0)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//
if (typeof Int64 === 'undefined' && typeof require === 'function') {
  const Int64 = require('node-int64');
}


//HELPER FUNCTIONS AND STRUCTURES

MrkClientService_getInfo_args = class {
  constructor(args) {
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      input.skip(ftype);
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('MrkClientService_getInfo_args');
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
MrkClientService_getInfo_result = class {
  constructor(args) {
    this.success = null;
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyMap(args.success, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.MAP) {
          this.success = {};
          const _rtmp341 = input.readMapBegin();
          const _size40 = _rtmp341.size || 0;
          for (let _i42 = 0; _i42 < _size40; ++_i42) {
            if (_i42 > 0 ) {
              if (input.rstack.length > input.rpos[input.rpos.length -1] + 1) {
                input.rstack.pop();
              }
            }
            let key43 = null;
            let val44 = null;
            key43 = input.readString().value;
            val44 = input.readString().value;
            this.success[key43] = val44;
          }
          input.readMapEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('MrkClientService_getInfo_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.MAP, 0);
      output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.STRING, Thrift.objectLength(this.success));
      for (let kiter45 in this.success) {
        if (this.success.hasOwnProperty(kiter45)) {
          let viter46 = this.success[kiter45];
          output.writeString(kiter45);
          output.writeString(viter46);
        }
      }
      output.writeMapEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
MrkClientService_getAllLanguages_args = class {
  constructor(args) {
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      input.skip(ftype);
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('MrkClientService_getAllLanguages_args');
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
MrkClientService_getAllLanguages_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyMap(args.success, [null]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.MAP) {
          this.success = {};
          const _rtmp348 = input.readMapBegin();
          const _size47 = _rtmp348.size || 0;
          for (let _i49 = 0; _i49 < _size47; ++_i49) {
            if (_i49 > 0 ) {
              if (input.rstack.length > input.rpos[input.rpos.length -1] + 1) {
                input.rstack.pop();
              }
            }
            let key50 = null;
            let val51 = null;
            key50 = input.readString().value;
            val51 = input.readString().value;
            this.success[key50] = val51;
          }
          input.readMapEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('MrkClientService_getAllLanguages_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.MAP, 0);
      output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.STRING, Thrift.objectLength(this.success));
      for (let kiter52 in this.success) {
        if (this.success.hasOwnProperty(kiter52)) {
          let viter53 = this.success[kiter52];
          output.writeString(kiter52);
          output.writeString(viter53);
        }
      }
      output.writeMapEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
MrkClientService_authMrkClient_args = class {
  constructor(args) {
    this.login = null;
    this.password = null;
    this.ip = null;
    this.langCode = null;
    this.cacheVersion = null;
    if (args) {
      if (args.login !== undefined && args.login !== null) {
        this.login = args.login;
      }
      if (args.password !== undefined && args.password !== null) {
        this.password = args.password;
      }
      if (args.ip !== undefined && args.ip !== null) {
        this.ip = args.ip;
      }
      if (args.langCode !== undefined && args.langCode !== null) {
        this.langCode = args.langCode;
      }
      if (args.cacheVersion !== undefined && args.cacheVersion !== null) {
        this.cacheVersion = args.cacheVersion;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.login = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.password = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.ip = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.langCode = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.I32) {
          this.cacheVersion = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('MrkClientService_authMrkClient_args');
    if (this.login !== null && this.login !== undefined) {
      output.writeFieldBegin('login', Thrift.Type.STRING, 1);
      output.writeString(this.login);
      output.writeFieldEnd();
    }
    if (this.password !== null && this.password !== undefined) {
      output.writeFieldBegin('password', Thrift.Type.STRING, 2);
      output.writeString(this.password);
      output.writeFieldEnd();
    }
    if (this.ip !== null && this.ip !== undefined) {
      output.writeFieldBegin('ip', Thrift.Type.STRING, 3);
      output.writeString(this.ip);
      output.writeFieldEnd();
    }
    if (this.langCode !== null && this.langCode !== undefined) {
      output.writeFieldBegin('langCode', Thrift.Type.STRING, 4);
      output.writeString(this.langCode);
      output.writeFieldEnd();
    }
    if (this.cacheVersion !== null && this.cacheVersion !== undefined) {
      output.writeFieldBegin('cacheVersion', Thrift.Type.I32, 5);
      output.writeI32(this.cacheVersion);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
MrkClientService_authMrkClient_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new MrkClientSession(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new MrkClientSession();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('MrkClientService_authMrkClient_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
MrkClientService_refreshMrkClientSession_args = class {
  constructor(args) {
    this.token = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('MrkClientService_refreshMrkClientSession_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
MrkClientService_refreshMrkClientSession_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new MrkClientSession(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new MrkClientSession();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('MrkClientService_refreshMrkClientSession_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
MrkClientService_registration_args = class {
  constructor(args) {
    this.cl = null;
    this.password = null;
    this.organization = null;
    if (args) {
      if (args.cl !== undefined && args.cl !== null) {
        this.cl = new MrkClient(args.cl);
      }
      if (args.password !== undefined && args.password !== null) {
        this.password = args.password;
      }
      if (args.organization !== undefined && args.organization !== null) {
        this.organization = new MrkOrganization(args.organization);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.cl = new MrkClient();
          this.cl.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.password = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.organization = new MrkOrganization();
          this.organization.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('MrkClientService_registration_args');
    if (this.cl !== null && this.cl !== undefined) {
      output.writeFieldBegin('cl', Thrift.Type.STRUCT, 1);
      this.cl.write(output);
      output.writeFieldEnd();
    }
    if (this.password !== null && this.password !== undefined) {
      output.writeFieldBegin('password', Thrift.Type.STRING, 2);
      output.writeString(this.password);
      output.writeFieldEnd();
    }
    if (this.organization !== null && this.organization !== undefined) {
      output.writeFieldBegin('organization', Thrift.Type.STRUCT, 3);
      this.organization.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
MrkClientService_registration_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new MrkAccount(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new MrkAccount();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('MrkClientService_registration_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
MrkClientService_changePassword_args = class {
  constructor(args) {
    this.token = null;
    this.oldPassword = null;
    this.password = null;
    this.confirmation = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.oldPassword !== undefined && args.oldPassword !== null) {
        this.oldPassword = args.oldPassword;
      }
      if (args.password !== undefined && args.password !== null) {
        this.password = args.password;
      }
      if (args.confirmation !== undefined && args.confirmation !== null) {
        this.confirmation = args.confirmation;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.oldPassword = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.password = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.confirmation = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('MrkClientService_changePassword_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.oldPassword !== null && this.oldPassword !== undefined) {
      output.writeFieldBegin('oldPassword', Thrift.Type.STRING, 2);
      output.writeString(this.oldPassword);
      output.writeFieldEnd();
    }
    if (this.password !== null && this.password !== undefined) {
      output.writeFieldBegin('password', Thrift.Type.STRING, 3);
      output.writeString(this.password);
      output.writeFieldEnd();
    }
    if (this.confirmation !== null && this.confirmation !== undefined) {
      output.writeFieldBegin('confirmation', Thrift.Type.STRING, 4);
      output.writeString(this.confirmation);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
MrkClientService_changePassword_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('MrkClientService_changePassword_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
MrkClientService_getFullAccountInfo_args = class {
  constructor(args) {
    this.token = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('MrkClientService_getFullAccountInfo_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
MrkClientService_getFullAccountInfo_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new MrkAccount(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new MrkAccount();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('MrkClientService_getFullAccountInfo_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
MrkClientService_changeAccountInfo_args = class {
  constructor(args) {
    this.token = null;
    this.mrkAccount = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.mrkAccount !== undefined && args.mrkAccount !== null) {
        this.mrkAccount = new MrkAccount(args.mrkAccount);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.mrkAccount = new MrkAccount();
          this.mrkAccount.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('MrkClientService_changeAccountInfo_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.mrkAccount !== null && this.mrkAccount !== undefined) {
      output.writeFieldBegin('mrkAccount', Thrift.Type.STRUCT, 2);
      this.mrkAccount.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
MrkClientService_changeAccountInfo_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new MrkAccount(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new MrkAccount();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('MrkClientService_changeAccountInfo_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
MrkClientService_getProfileInfoForSing_args = class {
  constructor(args) {
    this.token = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('MrkClientService_getProfileInfoForSing_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
MrkClientService_getProfileInfoForSing_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRING) {
          this.success = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('MrkClientService_getProfileInfoForSing_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRING, 0);
      output.writeString(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
MrkClientService_signProfile_args = class {
  constructor(args) {
    this.token = null;
    this.signature = null;
    this.publicKey = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.signature !== undefined && args.signature !== null) {
        this.signature = args.signature;
      }
      if (args.publicKey !== undefined && args.publicKey !== null) {
        this.publicKey = args.publicKey;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.signature = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.publicKey = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('MrkClientService_signProfile_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.signature !== null && this.signature !== undefined) {
      output.writeFieldBegin('signature', Thrift.Type.STRING, 2);
      output.writeString(this.signature);
      output.writeFieldEnd();
    }
    if (this.publicKey !== null && this.publicKey !== undefined) {
      output.writeFieldBegin('publicKey', Thrift.Type.STRING, 3);
      output.writeString(this.publicKey);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
MrkClientService_signProfile_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('MrkClientService_signProfile_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
MrkClientService_getMrkDocumentPage_args = class {
  constructor(args) {
    this.token = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('MrkClientService_getMrkDocumentPage_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 2);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
MrkClientService_getMrkDocumentPage_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new MrkDocumentPage(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new MrkDocumentPage();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('MrkClientService_getMrkDocumentPage_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
MrkClientService_markMrkDocumentAsRead_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.read = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.read !== undefined && args.read !== null) {
        this.read = args.read;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.BOOL) {
          this.read = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('MrkClientService_markMrkDocumentAsRead_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.read !== null && this.read !== undefined) {
      output.writeFieldBegin('read', Thrift.Type.BOOL, 3);
      output.writeBool(this.read);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
MrkClientService_markMrkDocumentAsRead_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new MrkDocumentData(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new MrkDocumentData();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('MrkClientService_markMrkDocumentAsRead_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
MrkClientService_getMrkDocumentData_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('MrkClientService_getMrkDocumentData_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
MrkClientService_getMrkDocumentData_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new MrkDocumentData(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new MrkDocumentData();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('MrkClientService_getMrkDocumentData_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
MrkClientService_createOrUpdateMrkDocument_args = class {
  constructor(args) {
    this.token = null;
    this.document = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.document !== undefined && args.document !== null) {
        this.document = new MrkDocumentData(args.document);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.document = new MrkDocumentData();
          this.document.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('MrkClientService_createOrUpdateMrkDocument_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.document !== null && this.document !== undefined) {
      output.writeFieldBegin('document', Thrift.Type.STRUCT, 2);
      this.document.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
MrkClientService_createOrUpdateMrkDocument_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new MrkDocumentData(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new MrkDocumentData();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('MrkClientService_createOrUpdateMrkDocument_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
MrkClientService_getDocumentInfoForSing_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('MrkClientService_getDocumentInfoForSing_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
MrkClientService_getDocumentInfoForSing_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRING) {
          this.success = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('MrkClientService_getDocumentInfoForSing_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRING, 0);
      output.writeString(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
MrkClientService_sendDocument_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.signature = null;
    this.attachmentSignature = null;
    this.publicKey = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.signature !== undefined && args.signature !== null) {
        this.signature = args.signature;
      }
      if (args.attachmentSignature !== undefined && args.attachmentSignature !== null) {
        this.attachmentSignature = Thrift.copyMap(args.attachmentSignature, [null]);
      }
      if (args.publicKey !== undefined && args.publicKey !== null) {
        this.publicKey = args.publicKey;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.signature = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.MAP) {
          this.attachmentSignature = {};
          const _rtmp355 = input.readMapBegin();
          const _size54 = _rtmp355.size || 0;
          for (let _i56 = 0; _i56 < _size54; ++_i56) {
            if (_i56 > 0 ) {
              if (input.rstack.length > input.rpos[input.rpos.length -1] + 1) {
                input.rstack.pop();
              }
            }
            let key57 = null;
            let val58 = null;
            key57 = input.readString().value;
            val58 = input.readString().value;
            this.attachmentSignature[key57] = val58;
          }
          input.readMapEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRING) {
          this.publicKey = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('MrkClientService_sendDocument_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.signature !== null && this.signature !== undefined) {
      output.writeFieldBegin('signature', Thrift.Type.STRING, 3);
      output.writeString(this.signature);
      output.writeFieldEnd();
    }
    if (this.attachmentSignature !== null && this.attachmentSignature !== undefined) {
      output.writeFieldBegin('attachmentSignature', Thrift.Type.MAP, 4);
      output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.STRING, Thrift.objectLength(this.attachmentSignature));
      for (let kiter59 in this.attachmentSignature) {
        if (this.attachmentSignature.hasOwnProperty(kiter59)) {
          let viter60 = this.attachmentSignature[kiter59];
          output.writeString(kiter59);
          output.writeString(viter60);
        }
      }
      output.writeMapEnd();
      output.writeFieldEnd();
    }
    if (this.publicKey !== null && this.publicKey !== undefined) {
      output.writeFieldBegin('publicKey', Thrift.Type.STRING, 5);
      output.writeString(this.publicKey);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
MrkClientService_sendDocument_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new MrkDocumentData(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new MrkDocumentData();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('MrkClientService_sendDocument_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
MrkClientService_getMrkAttachmentById_args = class {
  constructor(args) {
    this.token = null;
    this.attachmentId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.attachmentId !== undefined && args.attachmentId !== null) {
        this.attachmentId = args.attachmentId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.attachmentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('MrkClientService_getMrkAttachmentById_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.attachmentId !== null && this.attachmentId !== undefined) {
      output.writeFieldBegin('attachmentId', Thrift.Type.STRING, 2);
      output.writeString(this.attachmentId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
MrkClientService_getMrkAttachmentById_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new MrkAttachment(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new MrkAttachment();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('MrkClientService_getMrkAttachmentById_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
MrkClientService_getAllMrkAttachments_args = class {
  constructor(args) {
    this.token = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('MrkClientService_getAllMrkAttachments_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 2);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
MrkClientService_getAllMrkAttachments_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [MrkAttachment]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp362 = input.readListBegin();
          const _size61 = _rtmp362.size || 0;
          for (let _i63 = 0; _i63 < _size61; ++_i63) {
            let elem64 = null;
            elem64 = new MrkAttachment();
            elem64.read(input);
            this.success.push(elem64);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('MrkClientService_getAllMrkAttachments_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter65 in this.success) {
        if (this.success.hasOwnProperty(iter65)) {
          iter65 = this.success[iter65];
          iter65.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
MrkClientService_getCountAllMrkAttachments_args = class {
  constructor(args) {
    this.token = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('MrkClientService_getCountAllMrkAttachments_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 2);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
MrkClientService_getCountAllMrkAttachments_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.I32) {
          this.success = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('MrkClientService_getCountAllMrkAttachments_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.I32, 0);
      output.writeI32(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
MrkClientService_createLoadableMrkAttachment_args = class {
  constructor(args) {
    this.token = null;
    this.mrkDocumentId = null;
    this.fileName = null;
    this.totalSize = null;
    this.countPortions = null;
    this.attachmentId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.mrkDocumentId !== undefined && args.mrkDocumentId !== null) {
        this.mrkDocumentId = args.mrkDocumentId;
      }
      if (args.fileName !== undefined && args.fileName !== null) {
        this.fileName = args.fileName;
      }
      if (args.totalSize !== undefined && args.totalSize !== null) {
        this.totalSize = args.totalSize;
      }
      if (args.countPortions !== undefined && args.countPortions !== null) {
        this.countPortions = args.countPortions;
      }
      if (args.attachmentId !== undefined && args.attachmentId !== null) {
        this.attachmentId = args.attachmentId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.mrkDocumentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.fileName = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I64) {
          this.totalSize = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.I32) {
          this.countPortions = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.STRING) {
          this.attachmentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('MrkClientService_createLoadableMrkAttachment_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.mrkDocumentId !== null && this.mrkDocumentId !== undefined) {
      output.writeFieldBegin('mrkDocumentId', Thrift.Type.STRING, 2);
      output.writeString(this.mrkDocumentId);
      output.writeFieldEnd();
    }
    if (this.fileName !== null && this.fileName !== undefined) {
      output.writeFieldBegin('fileName', Thrift.Type.STRING, 3);
      output.writeString(this.fileName);
      output.writeFieldEnd();
    }
    if (this.totalSize !== null && this.totalSize !== undefined) {
      output.writeFieldBegin('totalSize', Thrift.Type.I64, 4);
      output.writeI64(this.totalSize);
      output.writeFieldEnd();
    }
    if (this.countPortions !== null && this.countPortions !== undefined) {
      output.writeFieldBegin('countPortions', Thrift.Type.I32, 5);
      output.writeI32(this.countPortions);
      output.writeFieldEnd();
    }
    if (this.attachmentId !== null && this.attachmentId !== undefined) {
      output.writeFieldBegin('attachmentId', Thrift.Type.STRING, 6);
      output.writeString(this.attachmentId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
MrkClientService_createLoadableMrkAttachment_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRING) {
          this.success = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('MrkClientService_createLoadableMrkAttachment_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRING, 0);
      output.writeString(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
MrkClientService_uploadMrkAttachmentPortions_args = class {
  constructor(args) {
    this.token = null;
    this.attachmentId = null;
    this.numberPortion = null;
    this.fileContentBytes = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.attachmentId !== undefined && args.attachmentId !== null) {
        this.attachmentId = args.attachmentId;
      }
      if (args.numberPortion !== undefined && args.numberPortion !== null) {
        this.numberPortion = args.numberPortion;
      }
      if (args.fileContentBytes !== undefined && args.fileContentBytes !== null) {
        this.fileContentBytes = args.fileContentBytes;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.attachmentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I32) {
          this.numberPortion = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.fileContentBytes = input.readBinary().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('MrkClientService_uploadMrkAttachmentPortions_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.attachmentId !== null && this.attachmentId !== undefined) {
      output.writeFieldBegin('attachmentId', Thrift.Type.STRING, 2);
      output.writeString(this.attachmentId);
      output.writeFieldEnd();
    }
    if (this.numberPortion !== null && this.numberPortion !== undefined) {
      output.writeFieldBegin('numberPortion', Thrift.Type.I32, 3);
      output.writeI32(this.numberPortion);
      output.writeFieldEnd();
    }
    if (this.fileContentBytes !== null && this.fileContentBytes !== undefined) {
      output.writeFieldBegin('fileContentBytes', Thrift.Type.STRING, 4);
      output.writeBinary(this.fileContentBytes);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
MrkClientService_uploadMrkAttachmentPortions_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new MrkAttachment(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new MrkAttachment();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('MrkClientService_uploadMrkAttachmentPortions_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
MrkClientService_getMrkUserHistoryPage_args = class {
  constructor(args) {
    this.token = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('MrkClientService_getMrkUserHistoryPage_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 2);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
MrkClientService_getMrkUserHistoryPage_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new MrkHistoryPage(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new MrkHistoryPage();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('MrkClientService_getMrkUserHistoryPage_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
MrkClientService_getAllDocumentPatterns_args = class {
  constructor(args) {
    this.token = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('MrkClientService_getAllDocumentPatterns_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 2);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
MrkClientService_getAllDocumentPatterns_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [DocumentPattern]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp367 = input.readListBegin();
          const _size66 = _rtmp367.size || 0;
          for (let _i68 = 0; _i68 < _size66; ++_i68) {
            let elem69 = null;
            elem69 = new DocumentPattern();
            elem69.read(input);
            this.success.push(elem69);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('MrkClientService_getAllDocumentPatterns_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter70 in this.success) {
        if (this.success.hasOwnProperty(iter70)) {
          iter70 = this.success[iter70];
          iter70.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
MrkClientService_prepareDocumentByPattern_args = class {
  constructor(args) {
    this.token = null;
    this.docPatternId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.docPatternId !== undefined && args.docPatternId !== null) {
        this.docPatternId = args.docPatternId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.docPatternId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('MrkClientService_prepareDocumentByPattern_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.docPatternId !== null && this.docPatternId !== undefined) {
      output.writeFieldBegin('docPatternId', Thrift.Type.STRING, 2);
      output.writeString(this.docPatternId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
MrkClientService_prepareDocumentByPattern_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new MrkDocumentData(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new MrkDocumentData();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('MrkClientService_prepareDocumentByPattern_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
MrkClientService_logout_args = class {
  constructor(args) {
    this.token = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('MrkClientService_logout_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
MrkClientService_logout_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('MrkClientService_logout_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
MrkClientServiceClient = class {
  constructor(input, output) {
    this.input = input;
    this.output = (!output) ? input : output;
    this.seqid = 0;
  }

  getInfo () {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getInfo((error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getInfo (callback) {
    const args = new MrkClientService_getInfo_args();
    try {
      this.output.writeMessageBegin('getInfo', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getInfo();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getInfo () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new MrkClientService_getInfo_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.success) {
      return result.success;
    }
    throw 'getInfo failed: unknown result';
  }

  getAllLanguages () {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllLanguages((error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllLanguages (callback) {
    const args = new MrkClientService_getAllLanguages_args();
    try {
      this.output.writeMessageBegin('getAllLanguages', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllLanguages();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllLanguages () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new MrkClientService_getAllLanguages_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllLanguages failed: unknown result';
  }

  authMrkClient (login, password, ip, langCode, cacheVersion) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_authMrkClient(login, password, ip, langCode, cacheVersion, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_authMrkClient (login, password, ip, langCode, cacheVersion, callback) {
    const params = {
      login: login,
      password: password,
      ip: ip,
      langCode: langCode,
      cacheVersion: cacheVersion
    };
    const args = new MrkClientService_authMrkClient_args(params);
    try {
      this.output.writeMessageBegin('authMrkClient', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_authMrkClient();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_authMrkClient () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new MrkClientService_authMrkClient_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'authMrkClient failed: unknown result';
  }

  refreshMrkClientSession (token) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_refreshMrkClientSession(token, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_refreshMrkClientSession (token, callback) {
    const params = {
      token: token
    };
    const args = new MrkClientService_refreshMrkClientSession_args(params);
    try {
      this.output.writeMessageBegin('refreshMrkClientSession', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_refreshMrkClientSession();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_refreshMrkClientSession () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new MrkClientService_refreshMrkClientSession_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'refreshMrkClientSession failed: unknown result';
  }

  registration (cl, password, organization) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_registration(cl, password, organization, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_registration (cl, password, organization, callback) {
    const params = {
      cl: cl,
      password: password,
      organization: organization
    };
    const args = new MrkClientService_registration_args(params);
    try {
      this.output.writeMessageBegin('registration', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_registration();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_registration () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new MrkClientService_registration_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'registration failed: unknown result';
  }

  changePassword (token, oldPassword, password, confirmation) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_changePassword(token, oldPassword, password, confirmation, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_changePassword (token, oldPassword, password, confirmation, callback) {
    const params = {
      token: token,
      oldPassword: oldPassword,
      password: password,
      confirmation: confirmation
    };
    const args = new MrkClientService_changePassword_args(params);
    try {
      this.output.writeMessageBegin('changePassword', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_changePassword();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_changePassword () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new MrkClientService_changePassword_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'changePassword failed: unknown result';
  }

  getFullAccountInfo (token) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getFullAccountInfo(token, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getFullAccountInfo (token, callback) {
    const params = {
      token: token
    };
    const args = new MrkClientService_getFullAccountInfo_args(params);
    try {
      this.output.writeMessageBegin('getFullAccountInfo', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getFullAccountInfo();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getFullAccountInfo () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new MrkClientService_getFullAccountInfo_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getFullAccountInfo failed: unknown result';
  }

  changeAccountInfo (token, mrkAccount) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_changeAccountInfo(token, mrkAccount, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_changeAccountInfo (token, mrkAccount, callback) {
    const params = {
      token: token,
      mrkAccount: mrkAccount
    };
    const args = new MrkClientService_changeAccountInfo_args(params);
    try {
      this.output.writeMessageBegin('changeAccountInfo', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_changeAccountInfo();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_changeAccountInfo () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new MrkClientService_changeAccountInfo_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'changeAccountInfo failed: unknown result';
  }

  getProfileInfoForSing (token) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getProfileInfoForSing(token, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getProfileInfoForSing (token, callback) {
    const params = {
      token: token
    };
    const args = new MrkClientService_getProfileInfoForSing_args(params);
    try {
      this.output.writeMessageBegin('getProfileInfoForSing', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getProfileInfoForSing();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getProfileInfoForSing () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new MrkClientService_getProfileInfoForSing_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getProfileInfoForSing failed: unknown result';
  }

  signProfile (token, signature, publicKey) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_signProfile(token, signature, publicKey, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_signProfile (token, signature, publicKey, callback) {
    const params = {
      token: token,
      signature: signature,
      publicKey: publicKey
    };
    const args = new MrkClientService_signProfile_args(params);
    try {
      this.output.writeMessageBegin('signProfile', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_signProfile();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_signProfile () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new MrkClientService_signProfile_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'signProfile failed: unknown result';
  }

  getMrkDocumentPage (token, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getMrkDocumentPage(token, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getMrkDocumentPage (token, filter, callback) {
    const params = {
      token: token,
      filter: filter
    };
    const args = new MrkClientService_getMrkDocumentPage_args(params);
    try {
      this.output.writeMessageBegin('getMrkDocumentPage', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getMrkDocumentPage();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getMrkDocumentPage () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new MrkClientService_getMrkDocumentPage_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getMrkDocumentPage failed: unknown result';
  }

  markMrkDocumentAsRead (token, documentId, read) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_markMrkDocumentAsRead(token, documentId, read, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_markMrkDocumentAsRead (token, documentId, read, callback) {
    const params = {
      token: token,
      documentId: documentId,
      read: read
    };
    const args = new MrkClientService_markMrkDocumentAsRead_args(params);
    try {
      this.output.writeMessageBegin('markMrkDocumentAsRead', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_markMrkDocumentAsRead();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_markMrkDocumentAsRead () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new MrkClientService_markMrkDocumentAsRead_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'markMrkDocumentAsRead failed: unknown result';
  }

  getMrkDocumentData (token, documentId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getMrkDocumentData(token, documentId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getMrkDocumentData (token, documentId, callback) {
    const params = {
      token: token,
      documentId: documentId
    };
    const args = new MrkClientService_getMrkDocumentData_args(params);
    try {
      this.output.writeMessageBegin('getMrkDocumentData', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getMrkDocumentData();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getMrkDocumentData () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new MrkClientService_getMrkDocumentData_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getMrkDocumentData failed: unknown result';
  }

  createOrUpdateMrkDocument (token, document) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_createOrUpdateMrkDocument(token, document, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_createOrUpdateMrkDocument (token, document, callback) {
    const params = {
      token: token,
      document: document
    };
    const args = new MrkClientService_createOrUpdateMrkDocument_args(params);
    try {
      this.output.writeMessageBegin('createOrUpdateMrkDocument', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_createOrUpdateMrkDocument();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_createOrUpdateMrkDocument () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new MrkClientService_createOrUpdateMrkDocument_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'createOrUpdateMrkDocument failed: unknown result';
  }

  getDocumentInfoForSing (token, documentId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getDocumentInfoForSing(token, documentId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getDocumentInfoForSing (token, documentId, callback) {
    const params = {
      token: token,
      documentId: documentId
    };
    const args = new MrkClientService_getDocumentInfoForSing_args(params);
    try {
      this.output.writeMessageBegin('getDocumentInfoForSing', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getDocumentInfoForSing();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getDocumentInfoForSing () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new MrkClientService_getDocumentInfoForSing_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getDocumentInfoForSing failed: unknown result';
  }

  sendDocument (token, documentId, signature, attachmentSignature, publicKey) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_sendDocument(token, documentId, signature, attachmentSignature, publicKey, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_sendDocument (token, documentId, signature, attachmentSignature, publicKey, callback) {
    const params = {
      token: token,
      documentId: documentId,
      signature: signature,
      attachmentSignature: attachmentSignature,
      publicKey: publicKey
    };
    const args = new MrkClientService_sendDocument_args(params);
    try {
      this.output.writeMessageBegin('sendDocument', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_sendDocument();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_sendDocument () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new MrkClientService_sendDocument_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'sendDocument failed: unknown result';
  }

  getMrkAttachmentById (token, attachmentId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getMrkAttachmentById(token, attachmentId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getMrkAttachmentById (token, attachmentId, callback) {
    const params = {
      token: token,
      attachmentId: attachmentId
    };
    const args = new MrkClientService_getMrkAttachmentById_args(params);
    try {
      this.output.writeMessageBegin('getMrkAttachmentById', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getMrkAttachmentById();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getMrkAttachmentById () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new MrkClientService_getMrkAttachmentById_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getMrkAttachmentById failed: unknown result';
  }

  getAllMrkAttachments (token, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllMrkAttachments(token, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllMrkAttachments (token, filter, callback) {
    const params = {
      token: token,
      filter: filter
    };
    const args = new MrkClientService_getAllMrkAttachments_args(params);
    try {
      this.output.writeMessageBegin('getAllMrkAttachments', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllMrkAttachments();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllMrkAttachments () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new MrkClientService_getAllMrkAttachments_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllMrkAttachments failed: unknown result';
  }

  getCountAllMrkAttachments (token, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getCountAllMrkAttachments(token, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getCountAllMrkAttachments (token, filter, callback) {
    const params = {
      token: token,
      filter: filter
    };
    const args = new MrkClientService_getCountAllMrkAttachments_args(params);
    try {
      this.output.writeMessageBegin('getCountAllMrkAttachments', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getCountAllMrkAttachments();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getCountAllMrkAttachments () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new MrkClientService_getCountAllMrkAttachments_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getCountAllMrkAttachments failed: unknown result';
  }

  createLoadableMrkAttachment (token, mrkDocumentId, fileName, totalSize, countPortions, attachmentId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_createLoadableMrkAttachment(token, mrkDocumentId, fileName, totalSize, countPortions, attachmentId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_createLoadableMrkAttachment (token, mrkDocumentId, fileName, totalSize, countPortions, attachmentId, callback) {
    const params = {
      token: token,
      mrkDocumentId: mrkDocumentId,
      fileName: fileName,
      totalSize: totalSize,
      countPortions: countPortions,
      attachmentId: attachmentId
    };
    const args = new MrkClientService_createLoadableMrkAttachment_args(params);
    try {
      this.output.writeMessageBegin('createLoadableMrkAttachment', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_createLoadableMrkAttachment();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_createLoadableMrkAttachment () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new MrkClientService_createLoadableMrkAttachment_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'createLoadableMrkAttachment failed: unknown result';
  }

  uploadMrkAttachmentPortions (token, attachmentId, numberPortion, fileContentBytes) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_uploadMrkAttachmentPortions(token, attachmentId, numberPortion, fileContentBytes, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_uploadMrkAttachmentPortions (token, attachmentId, numberPortion, fileContentBytes, callback) {
    const params = {
      token: token,
      attachmentId: attachmentId,
      numberPortion: numberPortion,
      fileContentBytes: fileContentBytes
    };
    const args = new MrkClientService_uploadMrkAttachmentPortions_args(params);
    try {
      this.output.writeMessageBegin('uploadMrkAttachmentPortions', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_uploadMrkAttachmentPortions();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_uploadMrkAttachmentPortions () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new MrkClientService_uploadMrkAttachmentPortions_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'uploadMrkAttachmentPortions failed: unknown result';
  }

  getMrkUserHistoryPage (token, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getMrkUserHistoryPage(token, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getMrkUserHistoryPage (token, filter, callback) {
    const params = {
      token: token,
      filter: filter
    };
    const args = new MrkClientService_getMrkUserHistoryPage_args(params);
    try {
      this.output.writeMessageBegin('getMrkUserHistoryPage', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getMrkUserHistoryPage();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getMrkUserHistoryPage () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new MrkClientService_getMrkUserHistoryPage_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getMrkUserHistoryPage failed: unknown result';
  }

  getAllDocumentPatterns (token, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllDocumentPatterns(token, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllDocumentPatterns (token, filter, callback) {
    const params = {
      token: token,
      filter: filter
    };
    const args = new MrkClientService_getAllDocumentPatterns_args(params);
    try {
      this.output.writeMessageBegin('getAllDocumentPatterns', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllDocumentPatterns();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllDocumentPatterns () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new MrkClientService_getAllDocumentPatterns_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllDocumentPatterns failed: unknown result';
  }

  prepareDocumentByPattern (token, docPatternId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_prepareDocumentByPattern(token, docPatternId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_prepareDocumentByPattern (token, docPatternId, callback) {
    const params = {
      token: token,
      docPatternId: docPatternId
    };
    const args = new MrkClientService_prepareDocumentByPattern_args(params);
    try {
      this.output.writeMessageBegin('prepareDocumentByPattern', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_prepareDocumentByPattern();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_prepareDocumentByPattern () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new MrkClientService_prepareDocumentByPattern_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'prepareDocumentByPattern failed: unknown result';
  }

  logout (token) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_logout(token, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_logout (token, callback) {
    const params = {
      token: token
    };
    const args = new MrkClientService_logout_args(params);
    try {
      this.output.writeMessageBegin('logout', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_logout();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_logout () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new MrkClientService_logout_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'logout failed: unknown result';
  }
};
//
// Autogenerated by Thrift Compiler (0.13.0)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//
if (typeof Int64 === 'undefined' && typeof require === 'function') {
  const Int64 = require('node-int64');
}


//HELPER FUNCTIONS AND STRUCTURES

MrkUserService_authMrkUser_args = class {
  constructor(args) {
    this.login = null;
    this.password = null;
    this.ip = null;
    this.langCode = null;
    this.cacheVersion = null;
    if (args) {
      if (args.login !== undefined && args.login !== null) {
        this.login = args.login;
      }
      if (args.password !== undefined && args.password !== null) {
        this.password = args.password;
      }
      if (args.ip !== undefined && args.ip !== null) {
        this.ip = args.ip;
      }
      if (args.langCode !== undefined && args.langCode !== null) {
        this.langCode = args.langCode;
      }
      if (args.cacheVersion !== undefined && args.cacheVersion !== null) {
        this.cacheVersion = args.cacheVersion;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.login = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.password = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.ip = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.langCode = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.I32) {
          this.cacheVersion = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('MrkUserService_authMrkUser_args');
    if (this.login !== null && this.login !== undefined) {
      output.writeFieldBegin('login', Thrift.Type.STRING, 1);
      output.writeString(this.login);
      output.writeFieldEnd();
    }
    if (this.password !== null && this.password !== undefined) {
      output.writeFieldBegin('password', Thrift.Type.STRING, 2);
      output.writeString(this.password);
      output.writeFieldEnd();
    }
    if (this.ip !== null && this.ip !== undefined) {
      output.writeFieldBegin('ip', Thrift.Type.STRING, 3);
      output.writeString(this.ip);
      output.writeFieldEnd();
    }
    if (this.langCode !== null && this.langCode !== undefined) {
      output.writeFieldBegin('langCode', Thrift.Type.STRING, 4);
      output.writeString(this.langCode);
      output.writeFieldEnd();
    }
    if (this.cacheVersion !== null && this.cacheVersion !== undefined) {
      output.writeFieldBegin('cacheVersion', Thrift.Type.I32, 5);
      output.writeI32(this.cacheVersion);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
MrkUserService_authMrkUser_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new MrkUserSession(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new MrkUserSession();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('MrkUserService_authMrkUser_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
MrkUserService_getMrkUserPage_args = class {
  constructor(args) {
    this.token = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('MrkUserService_getMrkUserPage_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 2);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
MrkUserService_getMrkUserPage_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new MrkUserPage(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new MrkUserPage();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('MrkUserService_getMrkUserPage_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
MrkUserService_changeMrkUser_args = class {
  constructor(args) {
    this.token = null;
    this.toUpdate = null;
    this.password = null;
    this.idToRemove = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.toUpdate !== undefined && args.toUpdate !== null) {
        this.toUpdate = new MrkUser(args.toUpdate);
      }
      if (args.password !== undefined && args.password !== null) {
        this.password = args.password;
      }
      if (args.idToRemove !== undefined && args.idToRemove !== null) {
        this.idToRemove = args.idToRemove;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.toUpdate = new MrkUser();
          this.toUpdate.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.password = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.idToRemove = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('MrkUserService_changeMrkUser_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.toUpdate !== null && this.toUpdate !== undefined) {
      output.writeFieldBegin('toUpdate', Thrift.Type.STRUCT, 2);
      this.toUpdate.write(output);
      output.writeFieldEnd();
    }
    if (this.password !== null && this.password !== undefined) {
      output.writeFieldBegin('password', Thrift.Type.STRING, 3);
      output.writeString(this.password);
      output.writeFieldEnd();
    }
    if (this.idToRemove !== null && this.idToRemove !== undefined) {
      output.writeFieldBegin('idToRemove', Thrift.Type.STRING, 4);
      output.writeString(this.idToRemove);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
MrkUserService_changeMrkUser_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new MrkUser(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new MrkUser();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('MrkUserService_changeMrkUser_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
MrkUserService_getAllMrkClients_args = class {
  constructor(args) {
    this.token = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('MrkUserService_getAllMrkClients_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 2);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
MrkUserService_getAllMrkClients_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [MrkClient]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp372 = input.readListBegin();
          const _size71 = _rtmp372.size || 0;
          for (let _i73 = 0; _i73 < _size71; ++_i73) {
            let elem74 = null;
            elem74 = new MrkClient();
            elem74.read(input);
            this.success.push(elem74);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('MrkUserService_getAllMrkClients_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter75 in this.success) {
        if (this.success.hasOwnProperty(iter75)) {
          iter75 = this.success[iter75];
          iter75.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
MrkUserService_getCountAllMrkClients_args = class {
  constructor(args) {
    this.token = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('MrkUserService_getCountAllMrkClients_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 2);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
MrkUserService_getCountAllMrkClients_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.I32) {
          this.success = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('MrkUserService_getCountAllMrkClients_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.I32, 0);
      output.writeI32(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
MrkUserService_getAllMrkAccounts_args = class {
  constructor(args) {
    this.token = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('MrkUserService_getAllMrkAccounts_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 2);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
MrkUserService_getAllMrkAccounts_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [MrkAccount]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp377 = input.readListBegin();
          const _size76 = _rtmp377.size || 0;
          for (let _i78 = 0; _i78 < _size76; ++_i78) {
            let elem79 = null;
            elem79 = new MrkAccount();
            elem79.read(input);
            this.success.push(elem79);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('MrkUserService_getAllMrkAccounts_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter80 in this.success) {
        if (this.success.hasOwnProperty(iter80)) {
          iter80 = this.success[iter80];
          iter80.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
MrkUserService_getCountAllMrkAccounts_args = class {
  constructor(args) {
    this.token = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('MrkUserService_getCountAllMrkAccounts_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 2);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
MrkUserService_getCountAllMrkAccounts_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.I32) {
          this.success = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('MrkUserService_getCountAllMrkAccounts_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.I32, 0);
      output.writeI32(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
MrkUserService_changeMrkAccount_args = class {
  constructor(args) {
    this.token = null;
    this.toChange = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.toChange !== undefined && args.toChange !== null) {
        this.toChange = new MrkAccount(args.toChange);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.toChange = new MrkAccount();
          this.toChange.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('MrkUserService_changeMrkAccount_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.toChange !== null && this.toChange !== undefined) {
      output.writeFieldBegin('toChange', Thrift.Type.STRUCT, 2);
      this.toChange.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
MrkUserService_changeMrkAccount_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new MrkAccount(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new MrkAccount();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('MrkUserService_changeMrkAccount_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
MrkUserService_getMrkAlmexSysUserPage_args = class {
  constructor(args) {
    this.token = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('MrkUserService_getMrkAlmexSysUserPage_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 2);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
MrkUserService_getMrkAlmexSysUserPage_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new MrkAlmexSysUserPage(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new MrkAlmexSysUserPage();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('MrkUserService_getMrkAlmexSysUserPage_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
MrkUserServiceClient = class {
  constructor(input, output) {
    this.input = input;
    this.output = (!output) ? input : output;
    this.seqid = 0;
  }

  authMrkUser (login, password, ip, langCode, cacheVersion) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_authMrkUser(login, password, ip, langCode, cacheVersion, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_authMrkUser (login, password, ip, langCode, cacheVersion, callback) {
    const params = {
      login: login,
      password: password,
      ip: ip,
      langCode: langCode,
      cacheVersion: cacheVersion
    };
    const args = new MrkUserService_authMrkUser_args(params);
    try {
      this.output.writeMessageBegin('authMrkUser', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_authMrkUser();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_authMrkUser () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new MrkUserService_authMrkUser_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'authMrkUser failed: unknown result';
  }

  getMrkUserPage (token, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getMrkUserPage(token, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getMrkUserPage (token, filter, callback) {
    const params = {
      token: token,
      filter: filter
    };
    const args = new MrkUserService_getMrkUserPage_args(params);
    try {
      this.output.writeMessageBegin('getMrkUserPage', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getMrkUserPage();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getMrkUserPage () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new MrkUserService_getMrkUserPage_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getMrkUserPage failed: unknown result';
  }

  changeMrkUser (token, toUpdate, password, idToRemove) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_changeMrkUser(token, toUpdate, password, idToRemove, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_changeMrkUser (token, toUpdate, password, idToRemove, callback) {
    const params = {
      token: token,
      toUpdate: toUpdate,
      password: password,
      idToRemove: idToRemove
    };
    const args = new MrkUserService_changeMrkUser_args(params);
    try {
      this.output.writeMessageBegin('changeMrkUser', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_changeMrkUser();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_changeMrkUser () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new MrkUserService_changeMrkUser_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'changeMrkUser failed: unknown result';
  }

  getAllMrkClients (token, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllMrkClients(token, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllMrkClients (token, filter, callback) {
    const params = {
      token: token,
      filter: filter
    };
    const args = new MrkUserService_getAllMrkClients_args(params);
    try {
      this.output.writeMessageBegin('getAllMrkClients', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllMrkClients();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllMrkClients () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new MrkUserService_getAllMrkClients_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllMrkClients failed: unknown result';
  }

  getCountAllMrkClients (token, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getCountAllMrkClients(token, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getCountAllMrkClients (token, filter, callback) {
    const params = {
      token: token,
      filter: filter
    };
    const args = new MrkUserService_getCountAllMrkClients_args(params);
    try {
      this.output.writeMessageBegin('getCountAllMrkClients', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getCountAllMrkClients();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getCountAllMrkClients () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new MrkUserService_getCountAllMrkClients_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getCountAllMrkClients failed: unknown result';
  }

  getAllMrkAccounts (token, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllMrkAccounts(token, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllMrkAccounts (token, filter, callback) {
    const params = {
      token: token,
      filter: filter
    };
    const args = new MrkUserService_getAllMrkAccounts_args(params);
    try {
      this.output.writeMessageBegin('getAllMrkAccounts', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllMrkAccounts();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllMrkAccounts () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new MrkUserService_getAllMrkAccounts_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllMrkAccounts failed: unknown result';
  }

  getCountAllMrkAccounts (token, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getCountAllMrkAccounts(token, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getCountAllMrkAccounts (token, filter, callback) {
    const params = {
      token: token,
      filter: filter
    };
    const args = new MrkUserService_getCountAllMrkAccounts_args(params);
    try {
      this.output.writeMessageBegin('getCountAllMrkAccounts', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getCountAllMrkAccounts();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getCountAllMrkAccounts () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new MrkUserService_getCountAllMrkAccounts_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getCountAllMrkAccounts failed: unknown result';
  }

  changeMrkAccount (token, toChange) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_changeMrkAccount(token, toChange, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_changeMrkAccount (token, toChange, callback) {
    const params = {
      token: token,
      toChange: toChange
    };
    const args = new MrkUserService_changeMrkAccount_args(params);
    try {
      this.output.writeMessageBegin('changeMrkAccount', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_changeMrkAccount();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_changeMrkAccount () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new MrkUserService_changeMrkAccount_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'changeMrkAccount failed: unknown result';
  }

  getMrkAlmexSysUserPage (token, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getMrkAlmexSysUserPage(token, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getMrkAlmexSysUserPage (token, filter, callback) {
    const params = {
      token: token,
      filter: filter
    };
    const args = new MrkUserService_getMrkAlmexSysUserPage_args(params);
    try {
      this.output.writeMessageBegin('getMrkAlmexSysUserPage', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getMrkAlmexSysUserPage();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getMrkAlmexSysUserPage () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new MrkUserService_getMrkAlmexSysUserPage_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getMrkAlmexSysUserPage failed: unknown result';
  }
};
//
// Autogenerated by Thrift Compiler (0.13.0)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//
if (typeof Int64 === 'undefined' && typeof require === 'function') {
  const Int64 = require('node-int64');
}


UserOrGroupType = {
  'USER' : 0,
  'GROUP' : 1,
  'USER_GUEST' : 2,
  'PROCESS_ROLE' : 3
};
GroupSelector = {
  'ALL' : 0,
  'MAX_FREE' : 1,
  'LAST_EXEC' : 2,
  'ANY' : 3
};
UserType = {
  'CHIEF' : 0,
  'DEPUTY' : 1,
  'EMPLOYEE' : 2,
  'TECHNICAL' : 3
};
AttachmentStatus = {
  'CREATED' : 0,
  'LOADED' : 1,
  'PUBLISHED' : 2,
  'REBUILD' : 3,
  'PROCESSED' : 4,
  'FAIL' : 5,
  'PROCESSING' : 6
};
FileType = {
  'PICTURE' : 0,
  'PDF' : 1,
  'OFFICE' : 2,
  'OTHER' : 3
};
AttachmentEditMode = {
  'SINGLE' : 0,
  'MULTIPLE' : 1,
  'PUBLISHED' : 2
};
DecisionType = {
  'NULL' : 0,
  'YES' : 1,
  'NO' : 2,
  'OTHER_TIME' : 3
};
RemoveActionType = {
  'IGNORE' : 0,
  'CASCADE' : 1
};
UserOrGroup = class {
  constructor(args) {
    this.type = null;
    this.userOrGroupId = null;
    this.nameGroup = null;
    this.descriptionGroup = null;
    this.userFirstName = null;
    this.userLastName = null;
    this.userMiddleName = null;
    this.attrs = null;
    this.deleteDate = null;
    this.avatarUrl = null;
    this.groupSelector = null;
    this.position = null;
    this.userCount = null;
    this.email = null;
    this.workPhone = null;
    this.haveAccess = null;
    this.scMask = null;
    this.employeeNumber = null;
    this.departments = null;
    this.fixed = null;
    this.endlessPassword = null;
    this.needChangePassword = null;
    this.accountIdGroup = null;
    this.userType = null;
    this.id = null;
    this.ldapId = null;
    this.company = null;
    this.mobilePhone = null;
    this.favorite = null;
    this.remark = null;
    this.fixedExec = null;
    this.chiefId = null;
    if (args) {
      if (args.type !== undefined && args.type !== null) {
        this.type = args.type;
      }
      if (args.userOrGroupId !== undefined && args.userOrGroupId !== null) {
        this.userOrGroupId = args.userOrGroupId;
      }
      if (args.nameGroup !== undefined && args.nameGroup !== null) {
        this.nameGroup = args.nameGroup;
      }
      if (args.descriptionGroup !== undefined && args.descriptionGroup !== null) {
        this.descriptionGroup = args.descriptionGroup;
      }
      if (args.userFirstName !== undefined && args.userFirstName !== null) {
        this.userFirstName = args.userFirstName;
      }
      if (args.userLastName !== undefined && args.userLastName !== null) {
        this.userLastName = args.userLastName;
      }
      if (args.userMiddleName !== undefined && args.userMiddleName !== null) {
        this.userMiddleName = args.userMiddleName;
      }
      if (args.attrs !== undefined && args.attrs !== null) {
        this.attrs = Thrift.copyMap(args.attrs, [null]);
      }
      if (args.deleteDate !== undefined && args.deleteDate !== null) {
        this.deleteDate = args.deleteDate;
      }
      if (args.avatarUrl !== undefined && args.avatarUrl !== null) {
        this.avatarUrl = args.avatarUrl;
      }
      if (args.groupSelector !== undefined && args.groupSelector !== null) {
        this.groupSelector = args.groupSelector;
      }
      if (args.position !== undefined && args.position !== null) {
        this.position = args.position;
      }
      if (args.userCount !== undefined && args.userCount !== null) {
        this.userCount = args.userCount;
      }
      if (args.email !== undefined && args.email !== null) {
        this.email = args.email;
      }
      if (args.workPhone !== undefined && args.workPhone !== null) {
        this.workPhone = args.workPhone;
      }
      if (args.haveAccess !== undefined && args.haveAccess !== null) {
        this.haveAccess = args.haveAccess;
      }
      if (args.scMask !== undefined && args.scMask !== null) {
        this.scMask = args.scMask;
      }
      if (args.employeeNumber !== undefined && args.employeeNumber !== null) {
        this.employeeNumber = args.employeeNumber;
      }
      if (args.departments !== undefined && args.departments !== null) {
        this.departments = Thrift.copyList(args.departments, [null]);
      }
      if (args.fixed !== undefined && args.fixed !== null) {
        this.fixed = args.fixed;
      }
      if (args.endlessPassword !== undefined && args.endlessPassword !== null) {
        this.endlessPassword = args.endlessPassword;
      }
      if (args.needChangePassword !== undefined && args.needChangePassword !== null) {
        this.needChangePassword = args.needChangePassword;
      }
      if (args.accountIdGroup !== undefined && args.accountIdGroup !== null) {
        this.accountIdGroup = args.accountIdGroup;
      }
      if (args.userType !== undefined && args.userType !== null) {
        this.userType = args.userType;
      }
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.ldapId !== undefined && args.ldapId !== null) {
        this.ldapId = args.ldapId;
      }
      if (args.company !== undefined && args.company !== null) {
        this.company = args.company;
      }
      if (args.mobilePhone !== undefined && args.mobilePhone !== null) {
        this.mobilePhone = args.mobilePhone;
      }
      if (args.favorite !== undefined && args.favorite !== null) {
        this.favorite = args.favorite;
      }
      if (args.remark !== undefined && args.remark !== null) {
        this.remark = args.remark;
      }
      if (args.fixedExec !== undefined && args.fixedExec !== null) {
        this.fixedExec = args.fixedExec;
      }
      if (args.chiefId !== undefined && args.chiefId !== null) {
        this.chiefId = args.chiefId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I32) {
          this.type = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.userOrGroupId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.nameGroup = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.descriptionGroup = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRING) {
          this.userFirstName = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.STRING) {
          this.userLastName = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.STRING) {
          this.userMiddleName = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.MAP) {
          this.attrs = {};
          const _rtmp31 = input.readMapBegin();
          const _size0 = _rtmp31.size || 0;
          for (let _i2 = 0; _i2 < _size0; ++_i2) {
            if (_i2 > 0 ) {
              if (input.rstack.length > input.rpos[input.rpos.length -1] + 1) {
                input.rstack.pop();
              }
            }
            let key3 = null;
            let val4 = null;
            key3 = input.readString().value;
            val4 = input.readString().value;
            this.attrs[key3] = val4;
          }
          input.readMapEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 9:
        if (ftype == Thrift.Type.I64) {
          this.deleteDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 10:
        if (ftype == Thrift.Type.STRING) {
          this.avatarUrl = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 11:
        if (ftype == Thrift.Type.I32) {
          this.groupSelector = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 12:
        if (ftype == Thrift.Type.STRING) {
          this.position = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 13:
        if (ftype == Thrift.Type.I32) {
          this.userCount = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 14:
        if (ftype == Thrift.Type.STRING) {
          this.email = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 15:
        if (ftype == Thrift.Type.STRING) {
          this.workPhone = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 16:
        if (ftype == Thrift.Type.BOOL) {
          this.haveAccess = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 17:
        if (ftype == Thrift.Type.STRING) {
          this.scMask = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 18:
        if (ftype == Thrift.Type.STRING) {
          this.employeeNumber = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 19:
        if (ftype == Thrift.Type.LIST) {
          this.departments = [];
          const _rtmp36 = input.readListBegin();
          const _size5 = _rtmp36.size || 0;
          for (let _i7 = 0; _i7 < _size5; ++_i7) {
            let elem8 = null;
            elem8 = new Department();
            elem8.read(input);
            this.departments.push(elem8);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 20:
        if (ftype == Thrift.Type.BOOL) {
          this.fixed = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 21:
        if (ftype == Thrift.Type.BOOL) {
          this.endlessPassword = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 22:
        if (ftype == Thrift.Type.BOOL) {
          this.needChangePassword = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 23:
        if (ftype == Thrift.Type.STRING) {
          this.accountIdGroup = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 24:
        if (ftype == Thrift.Type.I32) {
          this.userType = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 25:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 26:
        if (ftype == Thrift.Type.STRING) {
          this.ldapId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 27:
        if (ftype == Thrift.Type.STRING) {
          this.company = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 28:
        if (ftype == Thrift.Type.STRING) {
          this.mobilePhone = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 29:
        if (ftype == Thrift.Type.BOOL) {
          this.favorite = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 30:
        if (ftype == Thrift.Type.STRING) {
          this.remark = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 31:
        if (ftype == Thrift.Type.BOOL) {
          this.fixedExec = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 32:
        if (ftype == Thrift.Type.STRING) {
          this.chiefId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('UserOrGroup');
    if (this.type !== null && this.type !== undefined) {
      output.writeFieldBegin('type', Thrift.Type.I32, 1);
      output.writeI32(this.type);
      output.writeFieldEnd();
    }
    if (this.userOrGroupId !== null && this.userOrGroupId !== undefined) {
      output.writeFieldBegin('userOrGroupId', Thrift.Type.STRING, 2);
      output.writeString(this.userOrGroupId);
      output.writeFieldEnd();
    }
    if (this.nameGroup !== null && this.nameGroup !== undefined) {
      output.writeFieldBegin('nameGroup', Thrift.Type.STRING, 3);
      output.writeString(this.nameGroup);
      output.writeFieldEnd();
    }
    if (this.descriptionGroup !== null && this.descriptionGroup !== undefined) {
      output.writeFieldBegin('descriptionGroup', Thrift.Type.STRING, 4);
      output.writeString(this.descriptionGroup);
      output.writeFieldEnd();
    }
    if (this.userFirstName !== null && this.userFirstName !== undefined) {
      output.writeFieldBegin('userFirstName', Thrift.Type.STRING, 5);
      output.writeString(this.userFirstName);
      output.writeFieldEnd();
    }
    if (this.userLastName !== null && this.userLastName !== undefined) {
      output.writeFieldBegin('userLastName', Thrift.Type.STRING, 6);
      output.writeString(this.userLastName);
      output.writeFieldEnd();
    }
    if (this.userMiddleName !== null && this.userMiddleName !== undefined) {
      output.writeFieldBegin('userMiddleName', Thrift.Type.STRING, 7);
      output.writeString(this.userMiddleName);
      output.writeFieldEnd();
    }
    if (this.attrs !== null && this.attrs !== undefined) {
      output.writeFieldBegin('attrs', Thrift.Type.MAP, 8);
      output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.STRING, Thrift.objectLength(this.attrs));
      for (let kiter9 in this.attrs) {
        if (this.attrs.hasOwnProperty(kiter9)) {
          let viter10 = this.attrs[kiter9];
          output.writeString(kiter9);
          output.writeString(viter10);
        }
      }
      output.writeMapEnd();
      output.writeFieldEnd();
    }
    if (this.deleteDate !== null && this.deleteDate !== undefined) {
      output.writeFieldBegin('deleteDate', Thrift.Type.I64, 9);
      output.writeI64(this.deleteDate);
      output.writeFieldEnd();
    }
    if (this.avatarUrl !== null && this.avatarUrl !== undefined) {
      output.writeFieldBegin('avatarUrl', Thrift.Type.STRING, 10);
      output.writeString(this.avatarUrl);
      output.writeFieldEnd();
    }
    if (this.groupSelector !== null && this.groupSelector !== undefined) {
      output.writeFieldBegin('groupSelector', Thrift.Type.I32, 11);
      output.writeI32(this.groupSelector);
      output.writeFieldEnd();
    }
    if (this.position !== null && this.position !== undefined) {
      output.writeFieldBegin('position', Thrift.Type.STRING, 12);
      output.writeString(this.position);
      output.writeFieldEnd();
    }
    if (this.userCount !== null && this.userCount !== undefined) {
      output.writeFieldBegin('userCount', Thrift.Type.I32, 13);
      output.writeI32(this.userCount);
      output.writeFieldEnd();
    }
    if (this.email !== null && this.email !== undefined) {
      output.writeFieldBegin('email', Thrift.Type.STRING, 14);
      output.writeString(this.email);
      output.writeFieldEnd();
    }
    if (this.workPhone !== null && this.workPhone !== undefined) {
      output.writeFieldBegin('workPhone', Thrift.Type.STRING, 15);
      output.writeString(this.workPhone);
      output.writeFieldEnd();
    }
    if (this.haveAccess !== null && this.haveAccess !== undefined) {
      output.writeFieldBegin('haveAccess', Thrift.Type.BOOL, 16);
      output.writeBool(this.haveAccess);
      output.writeFieldEnd();
    }
    if (this.scMask !== null && this.scMask !== undefined) {
      output.writeFieldBegin('scMask', Thrift.Type.STRING, 17);
      output.writeString(this.scMask);
      output.writeFieldEnd();
    }
    if (this.employeeNumber !== null && this.employeeNumber !== undefined) {
      output.writeFieldBegin('employeeNumber', Thrift.Type.STRING, 18);
      output.writeString(this.employeeNumber);
      output.writeFieldEnd();
    }
    if (this.departments !== null && this.departments !== undefined) {
      output.writeFieldBegin('departments', Thrift.Type.LIST, 19);
      output.writeListBegin(Thrift.Type.STRUCT, this.departments.length);
      for (let iter11 in this.departments) {
        if (this.departments.hasOwnProperty(iter11)) {
          iter11 = this.departments[iter11];
          iter11.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.fixed !== null && this.fixed !== undefined) {
      output.writeFieldBegin('fixed', Thrift.Type.BOOL, 20);
      output.writeBool(this.fixed);
      output.writeFieldEnd();
    }
    if (this.endlessPassword !== null && this.endlessPassword !== undefined) {
      output.writeFieldBegin('endlessPassword', Thrift.Type.BOOL, 21);
      output.writeBool(this.endlessPassword);
      output.writeFieldEnd();
    }
    if (this.needChangePassword !== null && this.needChangePassword !== undefined) {
      output.writeFieldBegin('needChangePassword', Thrift.Type.BOOL, 22);
      output.writeBool(this.needChangePassword);
      output.writeFieldEnd();
    }
    if (this.accountIdGroup !== null && this.accountIdGroup !== undefined) {
      output.writeFieldBegin('accountIdGroup', Thrift.Type.STRING, 23);
      output.writeString(this.accountIdGroup);
      output.writeFieldEnd();
    }
    if (this.userType !== null && this.userType !== undefined) {
      output.writeFieldBegin('userType', Thrift.Type.I32, 24);
      output.writeI32(this.userType);
      output.writeFieldEnd();
    }
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 25);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.ldapId !== null && this.ldapId !== undefined) {
      output.writeFieldBegin('ldapId', Thrift.Type.STRING, 26);
      output.writeString(this.ldapId);
      output.writeFieldEnd();
    }
    if (this.company !== null && this.company !== undefined) {
      output.writeFieldBegin('company', Thrift.Type.STRING, 27);
      output.writeString(this.company);
      output.writeFieldEnd();
    }
    if (this.mobilePhone !== null && this.mobilePhone !== undefined) {
      output.writeFieldBegin('mobilePhone', Thrift.Type.STRING, 28);
      output.writeString(this.mobilePhone);
      output.writeFieldEnd();
    }
    if (this.favorite !== null && this.favorite !== undefined) {
      output.writeFieldBegin('favorite', Thrift.Type.BOOL, 29);
      output.writeBool(this.favorite);
      output.writeFieldEnd();
    }
    if (this.remark !== null && this.remark !== undefined) {
      output.writeFieldBegin('remark', Thrift.Type.STRING, 30);
      output.writeString(this.remark);
      output.writeFieldEnd();
    }
    if (this.fixedExec !== null && this.fixedExec !== undefined) {
      output.writeFieldBegin('fixedExec', Thrift.Type.BOOL, 31);
      output.writeBool(this.fixedExec);
      output.writeFieldEnd();
    }
    if (this.chiefId !== null && this.chiefId !== undefined) {
      output.writeFieldBegin('chiefId', Thrift.Type.STRING, 32);
      output.writeString(this.chiefId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
OrgStructure = class {
  constructor(args) {
    this.id = null;
    this.accountGroupId = null;
    this.name = null;
    this.order = null;
    this.main = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.accountGroupId !== undefined && args.accountGroupId !== null) {
        this.accountGroupId = args.accountGroupId;
      }
      if (args.name !== undefined && args.name !== null) {
        this.name = args.name;
      }
      if (args.order !== undefined && args.order !== null) {
        this.order = args.order;
      }
      if (args.main !== undefined && args.main !== null) {
        this.main = args.main;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.accountGroupId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.name = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I32) {
          this.order = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.BOOL) {
          this.main = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('OrgStructure');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.accountGroupId !== null && this.accountGroupId !== undefined) {
      output.writeFieldBegin('accountGroupId', Thrift.Type.STRING, 2);
      output.writeString(this.accountGroupId);
      output.writeFieldEnd();
    }
    if (this.name !== null && this.name !== undefined) {
      output.writeFieldBegin('name', Thrift.Type.STRING, 3);
      output.writeString(this.name);
      output.writeFieldEnd();
    }
    if (this.order !== null && this.order !== undefined) {
      output.writeFieldBegin('order', Thrift.Type.I32, 4);
      output.writeI32(this.order);
      output.writeFieldEnd();
    }
    if (this.main !== null && this.main !== undefined) {
      output.writeFieldBegin('main', Thrift.Type.BOOL, 5);
      output.writeBool(this.main);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
Department = class {
  constructor(args) {
    this.id = null;
    this.parentId = null;
    this.name = null;
    this.orgStructureCode = null;
    this.orgStructureId = null;
    this.userCount = null;
    this.path = null;
    this.main = null;
    this.order = null;
    this.rank = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.parentId !== undefined && args.parentId !== null) {
        this.parentId = args.parentId;
      }
      if (args.name !== undefined && args.name !== null) {
        this.name = args.name;
      }
      if (args.orgStructureCode !== undefined && args.orgStructureCode !== null) {
        this.orgStructureCode = args.orgStructureCode;
      }
      if (args.orgStructureId !== undefined && args.orgStructureId !== null) {
        this.orgStructureId = args.orgStructureId;
      }
      if (args.userCount !== undefined && args.userCount !== null) {
        this.userCount = args.userCount;
      }
      if (args.path !== undefined && args.path !== null) {
        this.path = args.path;
      }
      if (args.main !== undefined && args.main !== null) {
        this.main = args.main;
      }
      if (args.order !== undefined && args.order !== null) {
        this.order = args.order;
      }
      if (args.rank !== undefined && args.rank !== null) {
        this.rank = args.rank;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.parentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.name = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.orgStructureCode = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRING) {
          this.orgStructureId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.I64) {
          this.userCount = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.STRING) {
          this.path = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.BOOL) {
          this.main = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 9:
        if (ftype == Thrift.Type.I32) {
          this.order = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 10:
        if (ftype == Thrift.Type.I32) {
          this.rank = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('Department');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.parentId !== null && this.parentId !== undefined) {
      output.writeFieldBegin('parentId', Thrift.Type.STRING, 2);
      output.writeString(this.parentId);
      output.writeFieldEnd();
    }
    if (this.name !== null && this.name !== undefined) {
      output.writeFieldBegin('name', Thrift.Type.STRING, 3);
      output.writeString(this.name);
      output.writeFieldEnd();
    }
    if (this.orgStructureCode !== null && this.orgStructureCode !== undefined) {
      output.writeFieldBegin('orgStructureCode', Thrift.Type.STRING, 4);
      output.writeString(this.orgStructureCode);
      output.writeFieldEnd();
    }
    if (this.orgStructureId !== null && this.orgStructureId !== undefined) {
      output.writeFieldBegin('orgStructureId', Thrift.Type.STRING, 5);
      output.writeString(this.orgStructureId);
      output.writeFieldEnd();
    }
    if (this.userCount !== null && this.userCount !== undefined) {
      output.writeFieldBegin('userCount', Thrift.Type.I64, 6);
      output.writeI64(this.userCount);
      output.writeFieldEnd();
    }
    if (this.path !== null && this.path !== undefined) {
      output.writeFieldBegin('path', Thrift.Type.STRING, 7);
      output.writeString(this.path);
      output.writeFieldEnd();
    }
    if (this.main !== null && this.main !== undefined) {
      output.writeFieldBegin('main', Thrift.Type.BOOL, 8);
      output.writeBool(this.main);
      output.writeFieldEnd();
    }
    if (this.order !== null && this.order !== undefined) {
      output.writeFieldBegin('order', Thrift.Type.I32, 9);
      output.writeI32(this.order);
      output.writeFieldEnd();
    }
    if (this.rank !== null && this.rank !== undefined) {
      output.writeFieldBegin('rank', Thrift.Type.I32, 10);
      output.writeI32(this.rank);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
CompositeId = class {
  constructor(args) {
    this.id = null;
    this.version = null;
    if (args) {
      if (args.id !== undefined && args.id !== null) {
        this.id = args.id;
      }
      if (args.version !== undefined && args.version !== null) {
        this.version = args.version;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.id = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.version = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('CompositeId');
    if (this.id !== null && this.id !== undefined) {
      output.writeFieldBegin('id', Thrift.Type.STRING, 1);
      output.writeString(this.id);
      output.writeFieldEnd();
    }
    if (this.version !== null && this.version !== undefined) {
      output.writeFieldBegin('version', Thrift.Type.I32, 2);
      output.writeI32(this.version);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
//
// Autogenerated by Thrift Compiler (0.13.0)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//
if (typeof Int64 === 'undefined' && typeof require === 'function') {
  const Int64 = require('node-int64');
}


ServerException = class {
  constructor(args) {
    this.serverExceptionKey = null;
    if (args) {
      if (args.serverExceptionKey !== undefined && args.serverExceptionKey !== null) {
        this.serverExceptionKey = args.serverExceptionKey;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.serverExceptionKey = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('ServerException');
    if (this.serverExceptionKey !== null && this.serverExceptionKey !== undefined) {
      output.writeFieldBegin('serverExceptionKey', Thrift.Type.STRING, 1);
      output.writeString(this.serverExceptionKey);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
PreconditionException = class {
  constructor(args) {
    this.preconditionExceptionKey = null;
    this.params = null;
    this.message = null;
    this.verWarnining = null;
    if (args) {
      if (args.preconditionExceptionKey !== undefined && args.preconditionExceptionKey !== null) {
        this.preconditionExceptionKey = args.preconditionExceptionKey;
      }
      if (args.params !== undefined && args.params !== null) {
        this.params = Thrift.copyList(args.params, [null]);
      }
      if (args.message !== undefined && args.message !== null) {
        this.message = args.message;
      }
      if (args.verWarnining !== undefined && args.verWarnining !== null) {
        this.verWarnining = args.verWarnining;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.preconditionExceptionKey = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.LIST) {
          this.params = [];
          const _rtmp31 = input.readListBegin();
          const _size0 = _rtmp31.size || 0;
          for (let _i2 = 0; _i2 < _size0; ++_i2) {
            let elem3 = null;
            elem3 = input.readString().value;
            this.params.push(elem3);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.message = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.BOOL) {
          this.verWarnining = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('PreconditionException');
    if (this.preconditionExceptionKey !== null && this.preconditionExceptionKey !== undefined) {
      output.writeFieldBegin('preconditionExceptionKey', Thrift.Type.STRING, 1);
      output.writeString(this.preconditionExceptionKey);
      output.writeFieldEnd();
    }
    if (this.params !== null && this.params !== undefined) {
      output.writeFieldBegin('params', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.STRING, this.params.length);
      for (let iter4 in this.params) {
        if (this.params.hasOwnProperty(iter4)) {
          iter4 = this.params[iter4];
          output.writeString(iter4);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.message !== null && this.message !== undefined) {
      output.writeFieldBegin('message', Thrift.Type.STRING, 3);
      output.writeString(this.message);
      output.writeFieldEnd();
    }
    if (this.verWarnining !== null && this.verWarnining !== undefined) {
      output.writeFieldBegin('verWarnining', Thrift.Type.BOOL, 4);
      output.writeBool(this.verWarnining);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
//
// Autogenerated by Thrift Compiler (0.13.0)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//
if (typeof Int64 === 'undefined' && typeof require === 'function') {
  const Int64 = require('node-int64');
}


FilterFieldType = {
  'STRING' : 0,
  'NUMBER' : 1,
  'DATE' : 2,
  'BOOLEAN' : 3,
  'ENUMERATED' : 4,
  'DOUBLE' : 5,
  'STRING_FOR_REPLACE' : 6
};
FilterCondition = {
  'EQUAL' : 0,
  'NOT_EQUAL' : 1,
  'CONTAIN' : 2,
  'NOT_CONTAIN' : 3,
  'LESS' : 4,
  'LESS_OR_EQUAL' : 5,
  'MORE' : 6,
  'MORE_OR_EQUAL' : 7,
  'IN' : 8,
  'NOT_IN' : 9,
  'NULL' : 10,
  'NOT_NULL' : 11,
  'BETWEEN' : 12,
  'SEMANTIC_ANY' : 13
};
FilterItem = class {
  constructor(args) {
    this.field = null;
    this.fType = null;
    this.condition = null;
    this.value = null;
    this.additionValue = null;
    if (args) {
      if (args.field !== undefined && args.field !== null) {
        this.field = args.field;
      }
      if (args.fType !== undefined && args.fType !== null) {
        this.fType = args.fType;
      }
      if (args.condition !== undefined && args.condition !== null) {
        this.condition = args.condition;
      }
      if (args.value !== undefined && args.value !== null) {
        this.value = args.value;
      }
      if (args.additionValue !== undefined && args.additionValue !== null) {
        this.additionValue = args.additionValue;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.field = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.fType = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I32) {
          this.condition = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.value = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRING) {
          this.additionValue = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('FilterItem');
    if (this.field !== null && this.field !== undefined) {
      output.writeFieldBegin('field', Thrift.Type.STRING, 1);
      output.writeString(this.field);
      output.writeFieldEnd();
    }
    if (this.fType !== null && this.fType !== undefined) {
      output.writeFieldBegin('fType', Thrift.Type.I32, 2);
      output.writeI32(this.fType);
      output.writeFieldEnd();
    }
    if (this.condition !== null && this.condition !== undefined) {
      output.writeFieldBegin('condition', Thrift.Type.I32, 3);
      output.writeI32(this.condition);
      output.writeFieldEnd();
    }
    if (this.value !== null && this.value !== undefined) {
      output.writeFieldBegin('value', Thrift.Type.STRING, 4);
      output.writeString(this.value);
      output.writeFieldEnd();
    }
    if (this.additionValue !== null && this.additionValue !== undefined) {
      output.writeFieldBegin('additionValue', Thrift.Type.STRING, 5);
      output.writeString(this.additionValue);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
KazFilter = class {
  constructor(args) {
    this.position = null;
    this.countFilter = null;
    this.items = null;
    this.orders = null;
    if (args) {
      if (args.position !== undefined && args.position !== null) {
        this.position = args.position;
      }
      if (args.countFilter !== undefined && args.countFilter !== null) {
        this.countFilter = args.countFilter;
      }
      if (args.items !== undefined && args.items !== null) {
        this.items = Thrift.copyList(args.items, [FilterItem]);
      }
      if (args.orders !== undefined && args.orders !== null) {
        this.orders = Thrift.copyList(args.orders, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.I32) {
          this.position = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I32) {
          this.countFilter = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.items = [];
          const _rtmp31 = input.readListBegin();
          const _size0 = _rtmp31.size || 0;
          for (let _i2 = 0; _i2 < _size0; ++_i2) {
            let elem3 = null;
            elem3 = new FilterItem();
            elem3.read(input);
            this.items.push(elem3);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.LIST) {
          this.orders = [];
          const _rtmp35 = input.readListBegin();
          const _size4 = _rtmp35.size || 0;
          for (let _i6 = 0; _i6 < _size4; ++_i6) {
            let elem7 = null;
            elem7 = input.readString().value;
            this.orders.push(elem7);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('KazFilter');
    if (this.position !== null && this.position !== undefined) {
      output.writeFieldBegin('position', Thrift.Type.I32, 1);
      output.writeI32(this.position);
      output.writeFieldEnd();
    }
    if (this.countFilter !== null && this.countFilter !== undefined) {
      output.writeFieldBegin('countFilter', Thrift.Type.I32, 2);
      output.writeI32(this.countFilter);
      output.writeFieldEnd();
    }
    if (this.items !== null && this.items !== undefined) {
      output.writeFieldBegin('items', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRUCT, this.items.length);
      for (let iter8 in this.items) {
        if (this.items.hasOwnProperty(iter8)) {
          iter8 = this.items[iter8];
          iter8.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.orders !== null && this.orders !== undefined) {
      output.writeFieldBegin('orders', Thrift.Type.LIST, 4);
      output.writeListBegin(Thrift.Type.STRING, this.orders.length);
      for (let iter9 in this.orders) {
        if (this.orders.hasOwnProperty(iter9)) {
          iter9 = this.orders[iter9];
          output.writeString(iter9);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
